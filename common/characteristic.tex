
{\actuality}
%% Параллельные вычисления являются неотъемлимой частью современных
%% информационных систем. В настоящее время абсолютное большинство процессоров, используемых
%% в настольных компьютерах, серверах и смартфонах, являются многоядерными,
%% а большинство критичных к производительности программ --- многопоточными.
%% Многопоточность предоставляет программисту широкие возможности для ускорения вычислений,
%% потенциально позволяя уменьшить время исполнения или увеличить производительность программы
%% во столько же раз, сколько процессоров (ядер) находится в вычислительной системе.
%% Недостатком многопоточных программ является то, что они сложны для разработки и поддержки --- их поведение
%% зависит не только от входных данных, но и от планировщика задач в процессоре, который
%% управляет исполнением потоков программы на процессорных ядрах.
%% Как следствие,
Многопоточные программы являются источниками специфических, трудно поддающихся
тестированию и ручной отладке ошибок, таких как \emph{состояние гонки}, \emph{взаимная блокировка} и др.
Эти ошибки могут воспроизводиться очень редко, например, в одном из 10 тысяч запусков
программы, или в 0.01\% случаев, однако даже это может быть критично,
%% ---
%% подобная ``редкая" \, ошибка в ядре операционной системы Linux, которая
%% используется как минимум в 20 миллионах серверов по всему миру, будет приводить
%% к 200 тысячам неправильных срабатываний каждый день.
%% Таким образом,
поэтому необходимо иметь специализированные методы для анализа многопоточных программ.

Базовым и ключевым инструментом любого анализа является семантика языка,
на котором анализируемая программа написана. Семантики для языков и систем (процессоров)
с многопоточностью называют \emph{моделями памяти}.
\emph{Последовательная консистентность} --- это самая простая и естественная модель;
она подразумевает, что каждое поведение многопоточной программы может быть
получено некоторым поочередным исполнением команд из каждого потока на одном ядре
(процессоре). Эта модель не соответствует современным системам ---
в результате обработки оптимизирующими компиляторами и запуска на суперскалярных 
процессорах, многопоточная программа приобретает поведения, которые не могут
быть описаны подобным образом. Реалистичные модели памяти, позволяющие
упомянутые поведения, называются \emph{слабыми} (weak memory models).

На данный момент научное сообщество в тесном сотрудничестве с индустрией
разработало и продолжает совершенствовать множество слабых моделей памяти для
наиболее распространенных процессорных архитектур и языков программирования.
При этом процессорные и языковые модели существенно влияют на друг друга.
Модель процессора должна отражать поведения, наблюдаемые при запуске программ
на существующих процессорах, и давать пространство для развития
обратносовместимых архитектур. В то же время, языковая модель должна не только
предоставлять разумную и удобную абстракцию для программиста, не запрещать основные
компиляторные оптимизации, но и быть совместной с моделям целевых архитектур,
т.е. поддерживать эффективную трансляцию в низкоуровневый код без изменения
семантики программы.

%% Стандарты некоторых промышленных языков программирования содержат формальные модели памяти.
%% Языки C и C++ обладают наиболее продвинутой и разработанной моделью памяти, которая
%% появилась в редакции стандартов от 2011 года. Далее мы будем писать ``модель C/C++11''
%% для обозначения этой модели памяти.

%% Несмотря на свою продвинутость, модель C/C++11 обладает рядом недостатков.
%% Так, модель поддерживает не все компиляторные оптимизации, которые должны быть поддержаны;
%% некоторые аспекты модели противоречат существующим эффективным схемам компиляции
%% в распространенные архитектуры (в частности, в архитектуру Power);
%% модель разрешает т.н. \emph{значения из воздуха} (Out-Of-Thin-Air values, OOTA).
%% В работах M.Batty, H.-J.Boehm, O.Lahav, P.Sewell, V. Vafeiadis и других
%% были предложены локальные изменения модели для решения упомянутых проблем.
%% Более принципиальной проблемой модели C/C++11 является то, что для некоторых программ
%% модель разрешает поведения с т.н.

%% Одним из них является то, что модель разрешает т.н.
%% \emph{значения из воздуха} (Out-Of-Thin-Air values, OOTA), которые делают некорректными
%% даже базовые рассуждения о поведнии программ.
%% Например, согласно модели C/C++11 программа слева может завершиться с результатом $a = b = 42$,
%% даже несмотря на отсутствие и данного значения, и арифметики в программе:
%% \[
%% %% \begin{array}{c c}
%% \begin{array}{c}
%% {} [x] := 0; [y] := 0; \\
%% \begin{array}{l || l}
%%    a := [x]; & b := [y]; \\
%% {} [y] := a; & [x] := b; \\
%% \end{array}
%% \end{array}
%% %% &
%% %% \begin{array}{c}
%% %% {} [x] := 0; [y] := 0; \\
%% %% \begin{array}{l || l}
%% %%    a := [x]; & b := [y]; \\
%% %% {} [y] := 42; & [x] := 42; \\
%% %% \end{array}
%% %% \end{array}
%% %% \end{array}
%% \]
%% При этом, естественно, значения из воздуха разрешаются только в рамках формальной модели C/С++11
%% и не наблюдаются при реальных запусках аналогичных программ.

%% Наличие данной проблемы связано с тем, что модель C/C++11 является аксиоматической, а не
%% операционной, и при этом поддерживает множество оптимизаций

%% План:
%% \begin{enumerate}
%% \item Наличие этой проблемы связано с тем, что модель C++11 является аксиоматической
%%       и пытается поддерживать множество оптимизаций.
%% \item Одним из способов решить эту проблему является разработка операционного варианта
%%       модели памяти C++.
%% \item Операционная модель также обладает рядом достоинств. Так, в частности, операционная
%%       модель подразумевает наличие интерпретатора, а значит -- отладчика.
%% \item Как следствие, актуальной является задача разработка операционной модели памяти
%%       для языка программирования. При этом за основу стоит взять синтаксис модели памяти C++11.
%% \end{enumerate}

Существующие модели памяти для наиболее популярных языков программирования обладают рядом недостатков.
Так, известно, что модель памяти Java (the Java Memory Model) некорректна по отношению
к базовым оптимизациям, а модель памяти C/С++ (the C/C++11 Memory Model) разрешает
поведения программ, в которых появляются т.н. \emph{значения из воздуха} (Out-Of-Thin-Air values),
что делает некорректными даже базовые предположения о программах.
Кроме того, модель памяти C/C++ определяет лишь многопоточную составляющую семантики, что, вместе со стилем
описания модели (аксиоматическим), оставляет открытым вопрос её интеграции с остальной частью семантики,
описанной в стандарте операционно.

Таким образом, для развития инструментов анализа многопоточных программ необходимо
разработать операционные подходы к заданию слабых моделей памяти.

%% \textbf{Comment.} Много описания контекста. Почему x86, Power и ARM важны (с цифрами)?
%% Следить, если Promise станет стандартом для C++ и/или Java.

%% Обзор, введение в тему, обозначение места данной работы в
%% мировых исследованиях и~т.\:п., можно использовать ссылки на другие
%% работы~\cite{Gosele1999161} (если их нет, то в автореферате
%% автоматически пропадёт раздел <<Список литературы>>). Внимание! Ссылки
%% на другие работы в разделе общей характеристики работы можно
%% использовать только при использовании \verb!biblatex! (из-за технических
%% ограничений \verb!bibtex8!. Это связано с тем, что одна и та же
%% характеристика используются и в тексте диссертации, и в
%% автореферате. В последнем, согласно ГОСТ, должен присутствовать список
%% работ автора по теме диссертации, а \verb!bibtex8! не умеет выводить в одном
%% файле два списка литературы).

%% Для генерации содержимого титульного листа автореферата, диссертации и
%% презентации используются данные из файла \verb!common/data.tex!. Если,
%% например, вы меняете название диссертации, то оно автоматически
%% появится в итоговых файлах после очередного запуска \LaTeX. Согласно
%% ГОСТ 7.0.11-2011 <<5.1.1 Титульный лист является первой страницей
%% диссертации, служит источником информации, необходимой для обработки и
%% поиска документа.>> Наличие логотипа организации на титульном листе
%% упрощает обработку и поиск, для этого разметите логотип вашей
%% организации в папке images в формате PDF (лучше найти его в векторном
%% варианте, чтобы он хорошо смотрелся при печати) под именем
%% \verb!logo.pdf!. Настроить размер изображения с логотипом можно в
%% соответствующих местах файлов \verb!title.tex!  отдельно для
%% диссертации и автореферата. Если вам логотип не нужен, то просто
%% удалите файл с логотипом.

{\progress}
С 1990-ых годов велась работа по
разработке семантики многопоточности с учетом слабых поведений.
Формальные модели для наиболее распространенных процессорных архитектур (x86, Power, ARM)
были разработаны Alglave, Ishtiaq, Maranget, Zappa Nardelli, Sarkar, Sewell и другими. Новые версии моделей
продолжают появлятся в связи с развитием архитектур; в частности, в 2016 и 2017 годах были представлены
модели для архитектур ARMv8.0 и ARMv8.3.
%% В настоящее время также ведутся работы по формализации моделей памяти графических процессоров.
Язык Java, первым среди популярных промышленных языков программирования,
стандартизовал слабую модель памяти в 1995 году. В дальнейшем модель существенно менялась вплоть до 2005 года.
В 2011 году появилась аксиоматическая модель памяти для языков C и C++. И модель памяти Java, и модель памяти C/C++ обладают рядом недостатков.
Так модель памяти Java некорректна по отношению к базовым оптимизациям, а модель памяти C/С++ разрешает поведения
программ, в которых появляются т.н. \emph{значения из воздуха} (Out-Of-Thin-Air values),
что делает некорректными даже базовые рассуждения о программах.

В 2017 году была представлена ``обещающая'' модель памяти (promising memory model), которая является перспективным
решением проблемы задания семантики для языка с многопоточностью. Авторы (Kang, Hur, Lahav, Vafeiadis, Dreyer)
формально доказали, что модель разрешает большинство необходимых оптимизаций, а также показали корректность
эффективных схем компиляции в архитектуры x86 и Power; открытым остался вопрос о корректности компиляции
в архитектуру ARM.

%% Один из основополагающих результатов в области формальной верификации, логика Хоара (Hoare logic), была
%% предложена Hoare в 1969 году. В конце 1990-ых Reynolds, O'Hearn и другие разработали ее расширение,
%% логику разделения (separation logic), которая позволила доказывать свойства однопоточных программ
%% композиционально относительно использованной памяти. Далее O'Hearn и Reynolds предложили логику разделения
%% для многопоточности (concurrent separation logic). Она базируется на денотационной семантике Brookes,
%% которая, в свою очередь, является композициональным представлением модели памяти последовательной
%% консистентности Lamport. С помощью логики разделения для многопоточности десятки многопоточных алгоритмов
%% были верифицированы в модели последовательной консистентности
%% (работы Birkedal, Dreyer, Gardner, Gotsman, Nanevski, Sergey, Vafeiadis и других).

%% Параллельно с развитием логик для последовательной консистентности,

%% \cite{Kang-al:POPL17}

%% Этот раздел должен быть отдельным структурным элементом по
%% ГОСТ, но он, как правило, включается в описание актуальности
%% темы. Нужен он отдельным структурынм элемементом или нет ---
%% смотрите другие диссертации вашего совета, скорее всего не нужен.

{\aim} данной работы является исследование применимости операционных
подходов для определения реалистичных моделей памяти и анализа
многопоточных программ на примере языков C/C++.

Для~достижения поставленной цели были поставлены следующие {\tasks}.
\begin{enumerate}
  %% \item Провести обзор существующих операционных моделей слабой памяти.
  \item Разработать операционный аналог модели памяти С/С++11.
  %% \item Формализовать модель памяти ARMv8 и доказать дополнительные свойства о ней, необходимые для
  %%       доказательства корректности компиляции. 
  \item Разработать методы для доказательства корректности компиляции из операционного аналога модели памяти C/C++11 в модели памяти
        процессорных архитектур.
  \item Апробировать применимость метода на примере доказательства корректности компиляции из ``обещающей'' модели памяти в
        операционныую модель памяти ARMv8 POP и аксиоматическую модели памяти процессора ARMv8.3.
  %% \item Доказать корректность эффективной схемы компиляции из подмножества ``обещающей" \; семантики в операционную модель памяти ARMv8 POP.
  %% \item Доказать корректность эффективной схемы компиляции из подмножества ``обещающей" \; семантики в аксиоматическую модель памяти ARMv8.3.
\end{enumerate}

Постановка цели и задач исследования соответствует следующим пунктам паспорта специальности 05.13.11:
модели, методы и алгоритмы проектирования и анализа программ и программных систем, их эквивалентных преобразований, верификации и тестирования (пункт 1);
языки программирования и системы программирования, семантика программ (пункт 2);
модели и методы создания программ и программных систем для параллельной и распределенной обработки данных,
языки и инструментальные средства параллельного программирования (пункт 8).

{\methods}
В работе используется представление операционной семантики программы с помощью помеченной системы переходов, а также
метода вычислительных контекстов, предложенного M. Felleisen.
Программная реализация интерпретатора операционного аналога модели памяти C/C++11 выполнена на языке Racket с использованием
предметно-ориентированого расширения PLT/Redex.
Для доказательств корректности компиляции используется техника прямой симуляции.

{\defpositions}
\begin{enumerate}
  %% \item Проведён обзор существующих операционных моделей слабой памяти.
  %%       \todo{(пока не сделано)}
  \item Предложена операционная модель памяти для подмножества стандарта C/С++11.
  %% \item Создан компонентный метод описания интерпретаторов для модели C/C++11 в системе PLT/Redex.
  %% \item Разработан реляционный интерпретатор для модели C/C++11, позволяющий исправлять ошибки синхронизации
  %%       в программах.
  %%       \todo{(пока не сделано)}
  %% \item Реализован метод автоматического поиска сертификата в ``обещающей" \; модели памяти.
  %%       \todo{(пока не сделано)}
  %% \item Проведена формализация операционной модели памяти ARMv8 POP, доказаны вспомогательные утверждения про
  %%       модель, полезные для проверки корректности компиляции.
  \item Доказана корректность компиляции из подмножества ``обещающей" \; семантики в операционную модель памяти ARMv8 POP.
  \item Разработан метод построения операционной семантики по аксиоматической, позволяющий доказывать корректность
        компиляции из ``обещающей'' модели памяти в аксиоматические модели памяти.
  \item Доказана корректность компиляции из подмножества ``обещающей" \; семантики в аксиоматическую модель памяти ARMv8.3
  с помощью метода построения операционной семантики.
\end{enumerate}

{\novelty} результатов, полученных в рамках исследования, заключается в следующем:
\begin{enumerate}
  \item Модель памяти для подмножества стандарта C/C++11, предложенная в работе, отличается от ``обещающей'' модели
  памяти тем, что является запускаемой, т.е. для нее возможно создание интерпретатора (что и было сделано как часть работы).
  Данное отличие является следствием того, что для получения эффекта отложенного чтения предложенная модель использует
  синтаксический подход (буферизация инструкций), тогда как ``обещающая'' модель --- семантический (обещание потоком сделать
  запись в будущем).
  \item Доказательство корректности компиляции из ``обещающей'' модели памяти в операционную модель ARMv8 POP, представленное
  в работе, является единственным формальным результатом о модели ARMv8 POP на данный момент.
  \item Доказательство корректности компиляции из ``обещающей'' модели памяти в аксиоматическую модель ARMv8.3, представленное
  в работе, не опирается на специальные свойства целевой модели, такие как представимость модели в виде набора оптимизаций
  поверх более строгой модели. Это отличает использованный метод от аналогичных доказательств в модели x86 и Power
  (работы Lahav, Vafeiadis и других). Кроме того, представленный подход может быть использован и для доказательства
  корректности компиляции в модели x86 и Power, а значит обладает большой областью применимости.
\end{enumerate}

{\influence} \ldots

%% \textcolor{blue}{План публикаций ВАК:}
%% \begin{enumerate}
%%   \item \emph{Operational Aspects of C/C++ Concurrency.}
  
%%   %% \item \emph{Сертифицируемость шагов ``обещающей" \; семантики в контексте доказательства корректности компиляции
%%   %%   в модель памяти ARMv8 POP.}

%%   %%   В этой статье я собираюсь описать часть доказательства, которая не описана в моей статье на ECOOP'17.
%%   %%   \textcolor{red}{Подготовить черновой вариант за июль.}
%%   %%   \textcolor{green}{Вестник Политеха.}
    
%%   %%   \textbf{Гранты}. Посмотреть, что есть с грантами СПбГУ.

%%   \item \emph{О корректности компиляции подмножествa обещающей модели памяти в аксиоматическую модель ARMv8.3.}
%%     НТВ СПбГПУ. Информатика. Телекоммуникации. Управление. 2017 г.

%%   \item \emph{Обещающая компиляция в ARMv8.3.}
%%     ?Открытая конференция ИСП РАН?
    
%%   \item \emph{Слабые модели памяти языков программирования. Проблемы и решения.}
%%     Обзорная статья. Можем попробовать успеть опубликовать в первом выпуске НТВ СПбГПУ 2018 года.
    
%%   \item Кирпич нужно подготовить к концу декабря.
%%   %% \item Новый вариант названия ``Слабые модели памяти для языка C/C++".
%% \end{enumerate}

{\reliability} полученных результатов обеспечивается формальными доказательствами,
а также инженерными экспериментами.
Результаты находятся в соответствии с результатами, полученными другими авторами.

{\probation}
Основные результаты работы докладывались~на следующих научных конференциях и семинарах:
внутренние семинары School of Computing of the University of Kent (август 2017, Кентербери, Великобритания),
внутренние семинары Department of Computer Science of UCL (август 2017, Лондон, Великобритания),
внутренние семинары MPI-SWS (май 2017, Кайзерслаутерн, Германия),
ECOOP 2017 the European Conference on Object-Oriented Programming (18-23 июня 2017, Барселона, Испания),
Языки Программирования и Компиляторы (PLC 2017, 3-5 апреля 2017, Ростов-на-Дону, Россия),
VTSS 2016 Verified Trustworthy Software Systems (4-7 апреля 2016, Лондон, Великобритания),
POPL 2016 Student Research Competition (POPL 2016 SRC, 21 января 2016, Санкт-Петербург, Флорида, США).

%% {\contribution} Автор принимал активное участие \ldots

%% \publications\ Основные результаты по теме диссертации изложены в ХХ печатных изданиях~\cite{Sokolov,Gaidaenko,Lermontov,Management},
%% Х из которых изданы в журналах, рекомендованных ВАК~\cite{Sokolov,Gaidaenko}, 
%% ХХ --- в тезисах докладов~\cite{Lermontov,Management}.

\ifnumequal{\value{bibliosel}}{0}{% Встроенная реализация с загрузкой файла через движок bibtex8
    \publications\ Основные результаты по теме диссертации изложены в XX печатных изданиях, 
    X из которых изданы в журналах, рекомендованных ВАК, 
    X "--- в тезисах докладов.%
}{% Реализация пакетом biblatex через движок biber
%Сделана отдельная секция, чтобы не отображались в списке цитированных материалов
    \begin{refsection}[vak,papers,conf]% Подсчет и нумерация авторских работ. Засчитываются только те, которые были прописаны внутри \nocite{}.
        %Чтобы сменить порядок разделов в сгрупированном списке литературы необходимо перетасовать следующие три строчки, а также команды в разделе \newcommand*{\insertbiblioauthorgrouped} в файле biblio/biblatex.tex
        \printbibliography[heading=countauthorvak, env=countauthorvak, keyword=biblioauthorvak, section=1]%
        \printbibliography[heading=countauthorconf, env=countauthorconf, keyword=biblioauthorconf, section=1]%
        \printbibliography[heading=countauthornotvak, env=countauthornotvak, keyword=biblioauthornotvak, section=1]%
        \printbibliography[heading=countauthor, env=countauthor, keyword=biblioauthor, section=1]%
        \nocite{%Порядок перечисления в этом блоке определяет порядок вывода в списке публикаций автора
                Podkopaev-al:NTV17,
                %% vakbib1,vakbib2,%
                %% confbib1,confbib2,%
                Podkopaev-al:ECOOP17,
                Podkopaev-al:PLC17, Podkopaev-al:CoRR16,
                %% bib1,bib2,%
        }%
        \publications
        Основные результаты по теме диссертации изложены в \arabic{citeauthor} печатных работах.
        Одна статья опубликована в издании, входящем в базу цитирования SCOPUS.
        
        Вклад автора в публикациях распределён следующим образом.
        В рамках работы \cite{Podkopaev-al:NTV17} автор предложил схему доказательства корректности компиляции
        для аксиоматических семантик и провёл само доказательство. В работах \cite{Podkopaev-al:ECOOP17, Podkopaev-al:PLC17}
        автор провёл формализацию семантики ARMv8 POP и провёл доказательство корректности компиляции методом симуляции.
        В работе \cite{Podkopaev-al:CoRR16} автор разработал идею меток времени и фронтов, компонентный метод задания
        семантики и реализовал интерпретатор для предложенной в работе семантики; соавторы предложили синтаксический способ
        обработки отложенных операций.
    \end{refsection}
    \begin{refsection}[vak,papers,conf]%Блок, позволяющий отобрать из всех работ автора наиболее значимые, и только их вывести в автореферате, но считать в блоке выше общее число работ
        \printbibliography[heading=countauthorvak, env=countauthorvak, keyword=biblioauthorvak, section=2]%
        \printbibliography[heading=countauthornotvak, env=countauthornotvak, keyword=biblioauthornotvak, section=2]%
        \printbibliography[heading=countauthorconf, env=countauthorconf, keyword=biblioauthorconf, section=2]%
        \printbibliography[heading=countauthor, env=countauthor, keyword=biblioauthor, section=2]%
        \nocite{Podkopaev-al:NTV17}%vak
        \nocite{Podkopaev-al:ECOOP17}%conf
        \nocite{Podkopaev-al:PLC17,Podkopaev-al:CoRR16}%notvak
    \end{refsection}
}
%% При использовании пакета \verb!biblatex! для автоматического подсчёта
%% количества публикаций автора по теме диссертации, необходимо
%% их здесь перечислить с использованием команды \verb!\nocite!.
