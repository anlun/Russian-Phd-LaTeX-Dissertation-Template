
{\actuality}
Параллельные вычисления являются неотъемлимой частью современных
информационных систем. В настоящее время абсолютное большинство процессоров, используемых
в настольных компьютерах, серверах и смартфонах, являются многоядерными,
а большинство критичных к производительности программ --- многопоточными.
Многопоточность предоставляет программисту широкие возможности для ускорения вычислений,
потенциально позволяя уменьшить время исполнения, или увеличить производительность программы,
во столько же раз, сколько процессоров (ядер) находится в вычислительной системе.
Однако многопоточные программы сложны для разработки и поддержки --- их поведение
зависит не только от входных данных, но и от планировщика задач в процессоре, который
управляет исполнением потоков программы на процессорных ядрах.
Как следствие, многопоточные программы являются источниками специфических, трудно поддающихся
тестированию и ручной отладке ошибок, таких как \emph{состояние гонки}, \emph{взаимная блокировка} и др.
Эти ошибки могут воспроизводиться очень редко, например, в одном из 10 тысяч запусков
программы, или в 0.01\% случаев, однако даже это может быть критично ---
подобная ``редкая" \, ошибка в ядре операционной системы Linux, которая
используется как минимум в 20 миллионах серверов по всему миру, будет приводить
к 200 тысячам неправильных срабатываний каждый день.
Таким образом, необходимо иметь специализированные методы для анализа многопоточных программ.

Базовым и ключевым инструментом любого анализа является семантика языка,
на котором анализируемая программа написана. Семантики для языков и систем (процессоров)
с многопоточностью называют \emph{моделями памяти}.
\emph{Последовательная консистентность} --- это самая простая и естественная модель;
она подразумевает, что каждое поведение многопоточной программы может быть
получено некоторым поочередным исполнением команд из каждого потока на одном ядре
(процессоре). Однако эта модель не соответствует современным системам ---
в результате обработки оптимизирующими компиляторами и запуска на суперскалярных 
процессорах, многопоточная программа приобретает поведения, которые не могут
быть описаны подобным образом. Реалистичные модели памяти, позволяющие
упомянутые поведения, называются \emph{слабыми} (weak memory models).

На данный момент научное сообщество в тесном сотрудничестве с индустрией
разработало и продолжает совершенствовать множество слабых моделей памяти для
наиболее распространенных процессорных архитектур и языков программирования.
При этом процессорные и языковые модели существенно влияют на друг друга.
Модель процессора должна отражать поведения, наблюдаемые при запуске программ
на существующих процессорах, и давать пространство для развития
обратносовместимых архитектур. В то же время, языковая модель должна не только
предоставлять разумную и удобную абстракцию для программиста, не запрещать основные
компиляторные оптимизации, но и быть совместной с моделям целевых архитектур,
т.е. поддерживать эффективную трансляцию в низкоуровневый код без изменения
семантики программы.

Существующие модели памяти для наиболее популярных языков программирования обладают рядом недостатков.
Так, известно, что модель памяти Java (the Java Memory Model) некорректна по отношению
к базовым оптимизациям, а модель памяти C/С++ (the C/C++11 Memory Model) разрешает
поведения программ, в которых появляются т.н. \emph{значения из воздуха} (Out-Of-Thin-Air values),
что существенно усложняет семантику и рассуждения о программах.
Кроме того, модель памяти C/C++ определяет лишь многопоточную составляющую семантики, что, вместе со стилем
описания модели (аксиоматическим), оставляет открытым вопрос её интеграции с остальной частью семантики,
описанной в стандарте операционно.

Таким образом, для развития инструментов анализа многопоточных программ необходимо
разработать операционные подходы к заданию слабых моделей памяти.

%% Обзор, введение в тему, обозначение места данной работы в
%% мировых исследованиях и~т.\:п., можно использовать ссылки на другие
%% работы~\cite{Gosele1999161} (если их нет, то в автореферате
%% автоматически пропадёт раздел <<Список литературы>>). Внимание! Ссылки
%% на другие работы в разделе общей характеристики работы можно
%% использовать только при использовании \verb!biblatex! (из-за технических
%% ограничений \verb!bibtex8!. Это связано с тем, что одна и та же
%% характеристика используются и в тексте диссертации, и в
%% автореферате. В последнем, согласно ГОСТ, должен присутствовать список
%% работ автора по теме диссертации, а \verb!bibtex8! не умеет выводить в одном
%% файле два списка литературы).

%% Для генерации содержимого титульного листа автореферата, диссертации и
%% презентации используются данные из файла \verb!common/data.tex!. Если,
%% например, вы меняете название диссертации, то оно автоматически
%% появится в итоговых файлах после очередного запуска \LaTeX. Согласно
%% ГОСТ 7.0.11-2011 <<5.1.1 Титульный лист является первой страницей
%% диссертации, служит источником информации, необходимой для обработки и
%% поиска документа.>> Наличие логотипа организации на титульном листе
%% упрощает обработку и поиск, для этого разметите логотип вашей
%% организации в папке images в формате PDF (лучше найти его в векторном
%% варианте, чтобы он хорошо смотрелся при печати) под именем
%% \verb!logo.pdf!. Настроить размер изображения с логотипом можно в
%% соответствующих местах файлов \verb!title.tex!  отдельно для
%% диссертации и автореферата. Если вам логотип не нужен, то просто
%% удалите файл с логотипом.

{\progress} \dots
%% Этот раздел должен быть отдельным структурным элементом по
%% ГОСТ, но он, как правило, включается в описание актуальности
%% темы. Нужен он отдельным структурынм элемементом или нет ---
%% смотрите другие диссертации вашего совета, скорее всего не нужен.

{\aim} данной работы является исследование применимости операционных
подходов для определения реалистичных моделей памяти и анализа
многопоточных программ на примере языков C/C++.

Для~достижения поставленной цели необходимо были поставлены следующие {\tasks}:
\begin{enumerate}
  \item Провести обзор существующих операционных моделей слабой памяти.
  \item Разработать операционный аналог модели памяти С/С++11.
  \item Формализовать модель памяти ARMv8 и доказать дополнительные свойства о ней, необходимые для
        доказательства корректности компиляции. 
  \item Доказать корректность компиляции из ``обещающей" \; семантики в модель памяти ARMv8.
\end{enumerate}

{\novelty}
\begin{enumerate}
  \item Впервые \ldots
  \item Впервые \ldots
  \item Было выполнено оригинальное исследование \ldots
\end{enumerate}

{\influence} \ldots

{\methods} \ldots

{\defpositions}
\begin{enumerate}
  \item Проведён обзор существующих операционных моделей слабой памяти.
        \todo{(пока не сделано)}
  \item Предложена операционная модель памяти для подмножества стандарта C/С++11.
  \item Реализован компонентный метод описания интерпретаторов для модели C/C++11 в системе PLT/Redex.
  \item Разработан реляционный интерпретатор для модели C/C++11, позволяющий исправлять ошибки синхронизации
        в программах.
        \todo{(пока не сделано)}
  \item Реализован метод автоматического поиска сертификата в ``обещающей" \; модели памяти.
        \todo{(пока не сделано)}
  \item Создана формализация модели памяти ARMv8, доказаны вспомогательные утверждения про
        модель, полезные для проверки корректности компиляции.
  \item Доказана корректность компиляции из ``обещающей" \; семантики в модель памяти ARMv8.
  %% \item Показано, что операционные модели x86-TSO и Power есть ограниченные версии модели ARMv8.
\end{enumerate}

{\reliability} полученных результатов обеспечивается \ldots \ Результаты находятся в соответствии с результатами, полученными другими авторами.

{\probation}
Основные результаты работы докладывались~на:
перечисление основных конференций, симпозиумов и~т.\:п.

{\contribution} Автор принимал активное участие \ldots

%\publications\ Основные результаты по теме диссертации изложены в ХХ печатных изданиях~\cite{Sokolov,Gaidaenko,Lermontov,Management},
%Х из которых изданы в журналах, рекомендованных ВАК~\cite{Sokolov,Gaidaenko}, 
%ХХ --- в тезисах докладов~\cite{Lermontov,Management}.

\ifnumequal{\value{bibliosel}}{0}{% Встроенная реализация с загрузкой файла через движок bibtex8
    \publications\ Основные результаты по теме диссертации изложены в XX печатных изданиях, 
    X из которых изданы в журналах, рекомендованных ВАК, 
    X "--- в тезисах докладов.%
}{% Реализация пакетом biblatex через движок biber
%Сделана отдельная секция, чтобы не отображались в списке цитированных материалов
    \begin{refsection}[vak,papers,conf]% Подсчет и нумерация авторских работ. Засчитываются только те, которые были прописаны внутри \nocite{}.
        %Чтобы сменить порядок разделов в сгрупированном списке литературы необходимо перетасовать следующие три строчки, а также команды в разделе \newcommand*{\insertbiblioauthorgrouped} в файле biblio/biblatex.tex
        \printbibliography[heading=countauthorvak, env=countauthorvak, keyword=biblioauthorvak, section=1]%
        \printbibliography[heading=countauthorconf, env=countauthorconf, keyword=biblioauthorconf, section=1]%
        \printbibliography[heading=countauthornotvak, env=countauthornotvak, keyword=biblioauthornotvak, section=1]%
        \printbibliography[heading=countauthor, env=countauthor, keyword=biblioauthor, section=1]%
        \nocite{%Порядок перечисления в этом блоке определяет порядок вывода в списке публикаций автора
                vakbib1,vakbib2,%
                confbib1,confbib2,%
                bib1,bib2,%
        }%
        \publications\ Основные результаты по теме диссертации изложены в \arabic{citeauthor} печатных изданиях, 
        \arabic{citeauthorvak} из которых изданы в журналах, рекомендованных ВАК, 
        \arabic{citeauthorconf} "--- в тезисах докладов.
    \end{refsection}
    \begin{refsection}[vak,papers,conf]%Блок, позволяющий отобрать из всех работ автора наиболее значимые, и только их вывести в автореферате, но считать в блоке выше общее число работ
        \printbibliography[heading=countauthorvak, env=countauthorvak, keyword=biblioauthorvak, section=2]%
        \printbibliography[heading=countauthornotvak, env=countauthornotvak, keyword=biblioauthornotvak, section=2]%
        \printbibliography[heading=countauthorconf, env=countauthorconf, keyword=biblioauthorconf, section=2]%
        \printbibliography[heading=countauthor, env=countauthor, keyword=biblioauthor, section=2]%
        \nocite{vakbib2}%vak
        \nocite{bib1}%notvak
        \nocite{confbib1}%conf
    \end{refsection}
}
При использовании пакета \verb!biblatex! для автоматического подсчёта
количества публикаций автора по теме диссертации, необходимо
их здесь перечислить с использованием команды \verb!\nocite!.
    

