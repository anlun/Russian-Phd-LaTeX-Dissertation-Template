%% \iffalse
%% \fi

%% \fri{\Huge Результаты данной работы}{
%% \LARGE
%%   \item Доказана корректность компиляции подмножества\tikzmark{subset} обещающей семантики \cite{Kang-al:POPL17}
%%         в модель ARMv8 \cite{Flur-al:POPL16}

%%   \mycallout<2>[left]{green}{(subset)}{(-0.5cm, 1.0cm)}{Расслабленные (relaxed) \\ чтения и записи,\\
%%                                                         высвобождающие (release) и \\
%%                                                         преобретающие (acquire) \\ барьеры памяти}

%%   \onslide<3->{
%%     \item Формализована модель ARMv8 \cite{Flur-al:POPL16} и доказаны вспомогательные утверждения про неё
%%   }
%% }

%% \phrase{Корректность компиляции...\\ \pause Что это значит?}

%% %% \fr{\LARGE Корректность компиляции (1/2)}{
%% %%   \LARGE

%% %%   $\onslide<3->{compile :} \tikzmark{proglang}S \onslide<3->{\rightarrow} \tikzmark{hardlang}\onslide<2->{T}$\\
%% %%   \onslide<4->{
%% %%   $\onslide<6->{\forall Prog \in S.}$ \\
%% %%   ${} \quad \onslide<5->{\semState{\onslide<6->{compile(\tikzmark{hardsem}Prog)}}{T}}$
%% %%   $\onslide<6->{\subseteq}$
%% %%   $\semState{\onslide<6->{Prog}\tikzmark{progsem}}{S}$.
%% %%   }

%% %%   \mycallout<1>{green}{(proglang)}{(0.0cm, 1.0cm)}{Исходный язык}
%% %%   \mycallout<2>{green}{(hardlang)}{(0.0cm, 1.0cm)}{Целевой язык}

%% %%   \mycallout<4>{green}{(progsem)}{( 1.0cm, 1.0cm)}{Модель Памяти исходного языка}
%% %%   \mycallout<5>{green}{(hardsem)}{(-1.0cm, 1.0cm)}{Модель Памяти целевого языка}
%% %% }

%% %% \phrase{И обещающая, и ARMv8- семантики заданы {\bf операционно}:}
  
%% \fr{\huge Корректность компиляции из $S$ в $T$}{
%%   \LARGE
%%   $\onslide<2->{\forall \tikzmark{prog}Prog \in Syntax,}$ \\
%%   \onslide<3->{${} \;\; \{t_j\}_{j \in [1..k]}$ --} \tikzmark{hardlang}$T$\onslide<3->{-исполнение}
%%          \tikzmark{cprog}\only<2-7>{$compile(Prog)$}\only<8->{$Prog$}\onslide<3->{.} \\
%%   \onslide<4->{${} \quad \exists \{s_i\}_{i \in [1..n]}$ --} \tikzmark{proglang}$S$\onslide<4->{-исполнение $Prog$,} \\
%%   \onslide<5->{${} \quad s_n \tikzmark{stateeq}\simeq t_k.$}

%%   \mycallout<1>{green}{(proglang)}{(0.0cm, 1.0cm)}{Исходная модель}
%%   \mycallout<1>{green}{(hardlang)}{(0.0cm, -1.0cm)}{Целевая модель}
%%   \mycallout<2>{green}{(prog)}{(-2.0cm, -1.0cm)}{Исходная программа}
%%   \mycallout<2>{green}{(cprog)}{(0.0cm, 1.0cm)}{Результат компиляции}
%%   \mycallout<6>{green}{(stateeq)}{(-2.0cm, 1.0cm)}{e.g., финальное состояние \\ памяти совпадает}
%%   \mycallout<7>{yellow}{(cprog)}{(0.0cm, 1.0cm)}{Рассматриваем $compile = id$}
%% }

%% %% \phrase{А в случае \\ обещающей и ``ARM''- семантик?}

%% %% \fr{\huge Корректность компиляции \\ из $Promise$ в $ARM$}{
%% %%   \LARGE
%% %%   $\forall Prog \in Syntax,$ \\
%% %%   ${} \quad\{a_j\}_{j \in [1..k]}$ -- $ARM$-исполнение \only<2->{$Prog$.}\\
%% %%   \only<1>{${} \quad \quad com\tikzmark{cprog}pile(Prog)$. \\} %%   ${} \quad \exists \{p_i\}_{i \in [1..n]}$ -- $Promise$-исполнение $Prog$, \\
%% %%   ${} \quad p_n \tikzmark{stateeq}\simeq a_k.$
%% %% }

%% \phrase{Стандартная техника --- симуляция}

%% \fr{\huge Пример симуляции}{
%%   \cntrd{
%%   \begin{tikzpicture}
%%     \fill<-1>[gray!40!white , draw=black] (1,0) rectangle (2,1);
%%     \fill<2->[green!40!white, draw=black] (1,0) rectangle (2,1);

%%     \fill<-3>[gray!40!white , draw=black] (2,0) rectangle (3,1);
%%     \fill<4->[green!40!white, draw=black] (2,0) rectangle (3,1);

%%     \fill<-5>[gray!40!white , draw=black] (3,0) rectangle (4,1);
%%     \fill<6->[green!40!white, draw=black] (3,0) rectangle (4,1);

%%     \fill<-7>[gray!40!white , draw=black] (4,0) rectangle (5,1);
%%     \fill<8->[green!40!white, draw=black] (4,0) rectangle (5,1);

%%     \fill<- 9>[gray!40!white , draw=black] (5,0) rectangle (6,1);
%%     \fill<10->[green!40!white, draw=black] (5,0) rectangle (6,1);

%%     \node[opacity=.6] at (3.5,0.5) {\LARGE $Prog$};

%%     \draw<1,2>[->,ultra thick] (1,-0.4) -- (1,0);
%%     \node<1,2> at (1,-0.8) {\LARGE $S$};

%%     \draw<3,4>[->,ultra thick] (2,-0.4) -- (2,0);
%%     \node<3,4> at (2,-0.8) {\LARGE $S$};

%%     \draw<5,6>[->,ultra thick] (3,-0.4) -- (3,0);
%%     \node<5,6> at (3,-0.8) {\LARGE $S$};

%%     \draw<7,8>[->,ultra thick] (4,-0.4) -- (4,0);
%%     \node<7,8> at (4,-0.8) {\LARGE $S$};

%%     \draw<9,10>[->,ultra thick] (5,-0.4) -- (5,0);
%%     \node<9,10> at (5,-0.8) {\LARGE $S$};

%%     \draw<11>[->,ultra thick] (6,-0.4) -- (6,0);
%%     \node<11> at (6,-0.8) {\LARGE $S$};
%%   \end{tikzpicture}
%%   }

%%   Инвариант
%%   \onslide<2,4,6,8,10>{\textcolor{red}{не}}
%%   \only<2,4,6,8,10>{\textcolor{red}{выполняется}}\only<1,3,5,7,9,11>{\textcolor{darkGreen}{выполняется}}
  
%%   \vspace{1cm}
%%   \hrule
%%   \vspace{1cm}
  
%%   \begin{columns}

%%   \colu{.4\textwidth}{
%%     \begin{tikzpicture}
%%       \fill[green!40!white, draw=black] (0,0) rectangle (1,1);
%%       \node[right] at (1.2,0.5) {-- выполнено $T$};
%%     \end{tikzpicture}
%%   }

%%   \colu{.4\textwidth}{
%%     $S$ -- исходная модель\\
%%     $T$ -- целевая модель\\
%%   }

%%   \end{columns}
%% }

%% %% \fr{\huge Пример симуляции}{
%% %%   %% \cntrd{
%% %%   \begin{tikzpicture}
%% %%     \node at (3.7,2.2) {Состояние целевой машины};
%% %%     \draw[rounded corners] (-1,2.0) rectangle (6.2,4.2);
%% %%     \fill[gray!40!white, draw=black] (1,3) rectangle (2,4);
%% %%     \fill[gray!40!white, draw=black] (2,3) rectangle (3,4);
%% %%     \fill[gray!40!white, draw=black] (3,3) rectangle (4,4);
%% %%     \fill[gray!40!white, draw=black] (4,3) rectangle (5,4);
%% %%     \fill[gray!40!white, draw=black] (5,3) rectangle (6,4);

%% %%     \node at (-1,0.5) {Исходная машина};
%% %%     \fill[gray!40!white, draw=black] (1,0) rectangle (2,1);
%% %%     \fill[gray!40!white, draw=black] (2,0) rectangle (3,1);
%% %%     \fill[gray!40!white, draw=black] (3,0) rectangle (4,1);
%% %%     \fill[gray!40!white, draw=black] (4,0) rectangle (5,1);
%% %%     \fill[gray!40!white, draw=black] (5,0) rectangle (6,1);
    
%% %%     \node[opacity=.6] at (3.5,3.5) {\LARGE $compile(Prog)$};
%% %%     \node[opacity=.6] at (3.5,0.5) {\LARGE $Prog$};
%% %%     \node[left] at (4, -2) {Инвариант};
%% %%     %% \node[left] at (6.8, -2) {\textcolor{red}{не выполняется}};
%% %%     \node[left] at (6.3, -2) {\textcolor{darkGreen}{выполняется}};
%% %%   \end{tikzpicture}
%% %%   %% }
%% %% }

%% \fr{}{
%% \huge
%% ...но симуляция напрямую не применина в нашем случае\pause:
%%   \iteN{
%%     \LARGE
%%     \item ARM выполняет инструкции не по порядку;
%%     \item Обещающая семантика имеет больше явных ограничений.
%%   }
%% }

%% \fr{\huge План доказательства}{
%%   \LARGE
%%   \iteN{
%%     \pause
%%     \item \toGray{5}{6}{Вводим промежуточную семантику ARM+$\tau$}
%%     \pause
%%     \ite{
%%       \Large
%%       \item \toGray{5}{6}{обладает явными ограниченями, похожими на обещающую семантику;}
%%     }
%%     \pause
%%     \item \toGray{5}{6}{Доказываем бисимуляцию между ARM+$\tau$ и ARM;}
%%     \pause
%%     \item Показываем ``запаздывающую'' симуляцию ARM+$\tau$ обещающей семантикой.
%%   }
%% }

%% \fr{\huge ``Запаздывающая'' симуляция}{
%%   \cntrd{
%%   \begin{tikzpicture}
%%     \fill<-1>[gray!40!white , draw=black] (1,0) rectangle (2,1);
%%     \fill<2->[green!40!white, draw=black] (1,0) rectangle (2,1);

%%     \fill<-5,7-9>[gray!40!white , draw=black] (2,0) rectangle (3,1);
%%     \fill<6,10>[yellow!40!white, draw=black] (2,0) rectangle (3,1);
%%     \fill<11->[green!40!white, draw=black] (2,0) rectangle (3,1);

%%     \fill<-4>[gray!40!white , draw=black] (3,0) rectangle (4,1);
%%     \fill<5-8>[yellow!40!white, draw=black] (3,0) rectangle (4,1);
%%     \fill<9->[green!40!white, draw=black] (3,0) rectangle (4,1);

%%     \fill<-7>[gray!40!white , draw=black] (4,0) rectangle (5,1);
%%     \fill<8->[green!40!white, draw=black] (4,0) rectangle (5,1);

%%     \fill<-3>[gray!40!white , draw=black] (5,0) rectangle (6,1);
%%     \fill<4->[green!40!white, draw=black] (5,0) rectangle (6,1);

%%     \node[opacity=.6] at (3.5,0.5) {\LARGE $Prog$};

%%     \draw<1,2>[->,ultra thick] (1,-0.4) -- (1,0);
%%     \node<1,2> at (1,-0.8) {\LARGE $Promise$};

%%     \draw<3-11>[->,ultra thick] (2,-0.4) -- (2,0);
%%     \node<3-11> at (2,-0.8) {\LARGE $Promise$};

%%     \draw<12>[->,ultra thick] (3,-0.4) -- (3,0);
%%     \node<12> at (3,-0.8) {\LARGE $Promise$};

%%     \draw<13>[->,ultra thick] (4,-0.4) -- (4,0);
%%     \node<13> at (4,-0.8) {\LARGE $Promise$};

%%     \draw<14>[->,ultra thick] (5,-0.4) -- (5,0);
%%     \node<14> at (5,-0.8) {\LARGE $Promise$};

%%     \draw<15>[->,ultra thick] (6,-0.4) -- (6,0);
%%     \node<15> at (6,-0.8) {\LARGE $Promise$};
%%   \end{tikzpicture}
%%   }

%%   Инвариант: обещающая машина
%%   \only<2,11-14>{\textcolor{darkGreen}{исполняется}}\only<1,3-10,15->{\textcolor{darkGreen}{ждёт}}
  
%%   \vspace{0.5cm}
%%   \hrule
%%   \vspace{0.5cm}
  
%%   %% \begin{columns}

%%   %% \colu{.4\textwidth}{
%%     \begin{tikzpicture}
%%       \fill[green!40!white, draw=black] (0,0) rectangle (1,1);
%%       \node[right] at (1.2,0.5) {-- выполнено $ARMv8$};

%%       \fill[yellow!40!white, draw=black] (0,1.5) rectangle (1,2.5);
%%       \node[right] at (1.2,2.0) {-- частично выполнено $ARMv8$};
%%     \end{tikzpicture}
%%   %% }

%%   %% \colu{.4\textwidth}{
%%     $Promise$ -- обещающая модель\\
%%     %% $ARM$ -- целевая модель\\
%%   %% }

%%   %% \end{columns}
%% }

%% %% \fr{\huge ``Запаздывающая'' симуляция (1/3)}{
%% %%   \LARGE
%% %%   Базовое отношение на состояниях $\simrelBase \subset \ARMt_{state} \times \Promise_{state}:$ \\
%% %%   \light{$\simrelBase \triangleq$ $\invCf$ $\cap \invPrefix$ $\cap \invMem$ $\cap \invView$ $\cap \invState$.}
%% %% }

%% %% \fr{\huge ``Запаздывающая'' симуляция (2/3)}{
%% %%   \LARGE
%% %%   $\invPromUptoARM(\aT,\p) \triangleq$ \\
%% %%   ${} \quad \forall \tId, \invPromUptoARMtId(\tId,\aT,\p)$; \\
%% %%   $\simrel \triangleq \simrelBase \cap \invPromUptoARM$ \\
%% %%   \vfill
%% %%   \pause
%% %%   $\invPromUptoARMnot(\aT,\p) \triangleq$ \\
%% %%   ${} \quad \exists! \tId, \lnot \invPromUptoARMtId(\tId,\aT,\p)$; \\
%% %%   $\simrelPre \triangleq \simrelBase \cap \invPromUptoARMnot$
%% %% }

%% \fr{\huge ``Запаздывающая'' симуляция. Формально}{
%% \tiny

%% {\bf Лемма 1:}  \\
%% $\forall (\aT, \p) \in \simrelPre, \exists \p', \p \promStep \p', (\aT, \p') \in \simrelPre \cup \simrel$.

%% \vfill
%% {\bf Лемма 2:}  \\
%% $\forall (\aT, \p) \in \simrelPre, \exists n, \{\p_i\}_{i \in [0, n]}, \p_0 = \p, (\forall i < n, \p_i \promStep \p_{i+1})$,\\
%% ${} \quad (\forall i < n, (\aT, \p_i) \in \simrelPre), (\aT, \p_n) \in \simrel$.\\

%% \vfill
%% {\bf Лемма 3:}  \\
%% $\forall (\aT, \p) \in \simrel$,\\
%% ${} \quad (\forall \aT', \aT \armStepgen{\lnot \; \transenv{Write commit}} \aT' \Rightarrow (\aT', \p) \in \simrelPre \cup \simrel) \land$\\
%% ${} \quad (\forall\aT', \aT \armStepgen{\transenv{Write commit}} \aT' \Rightarrow \exists \p', \p \promStepgen{\transenv{Promise write}} \p',  (\aT', \p') \in \simrelPre \cup \simrel)$.

%% \vfill
%% {\bf Лемма 4:}  \\
%% $\forall (\aT, \p) \in \simrel, \aT', \aT \armStep \aT' \Rightarrow$ \\
%% ${} \quad {} \exists \p', \p \promStep^{*} \p', (\aT', \p') \in \simrel$.

%% \vfill
%% {\bf Теорема:} \\
%% $\begin{array}{l}
%%   \forall \Cfprom, %\Cfarm = compilation(\Cfprom), \\
%%   \{\aT_i\}_{i \in [0..n]}, \\
%%   \quad \ainit(compile(\Cfarm)) = \aT_0 \armStep \dots \armStep \aT_n, \finalStateA(\aT_n),\\
%%   \exists \{\p_i\}_{i \in [0..k]}, \\
%%   \quad \pinit(\Cfprom) = \p_0 \promStep \dots \promStep \p_k, \finalStateProm(\p_k), \\
%%   \sameMemory(\aT_n, \p_k). \\
%% \end{array}$
%% }

%% %% \begin{frame}[plain]
%% %%  \cntrd{
%% %%    \shadowimage[width=.9\linewidth]{paperScreenshot.pdf}
%% %%  }
%% %% \end{frame}


%% \fr{\huge Планы на будущее}{
%% \ite{
%%   \LARGE
%%   \item Поддержка остальных конструкций обещающей семантики \\
%%         {\normalsize \light{(Read-Modify-Writes, Release/Acquire accesses, SC fences)}}
%%   \vfill
%%   \item Механизация доказательства в Coq
%% }

%% \vfill
%% \pause
%% \cntrd{\huge \it \textcolor{red}{Спасибо!}}
%% }


%% \phrase{The first step is a {\bf formal semantics}}
%% \phraseL{
%%   {\Huge PL semantics should}
%%   \vfill
%%   \ite{
%%     \pitem allow \alert{efficient implementation}; \\
%%     \pause (x86, Power, ARM)
%%     \pitem validate \alert{compiler optimizations}; \\
%%     \pause (merging, rearranging, etc)
%%     \pitem allow \alert{high-level reasoning}. \\
%%     %% \pitem avoid \alert{``undefined behavior''}.
%%   }
%% }

%% \fr{}{
%% \begin{center}
%% \begin{tabular}{l | l | l | l}
%%              & Eff. Impl. & Comp. Opt. & H.-l. Reasoning \\ % & No UB \\
%%              \hline
%% Lamport's SC & \fail      & \fail  & \tick \\ % & \tick \\
%% C/C++11 MM   & \tick      & \tick  & \fail \\ % ~ (OOTA) \\ % & \fail \\
%% Java    MM   & \tick      & \fail  & \tick \pause \\ % & \tick \pause \\
%% \multicolumn{4}{l}{} \\
%% \multicolumn{4}{l}{{\bf A promising semantics}} \\
%% \cite{Kang-al:POPL17} & \tick & \tick & \tick \\ % \tick \\
%% \end{tabular}
%% \end{center}
%% }

%% \fr{}{

%% {\Large The Promise machine \cite{Kang-al:POPL17} is {\bf proved} to be {\bf compilable} to
%% x86 and Power.} \\

%% \pause
%% {\bf Sketch of the proof}:
%% \ite{
%%   \pitem x86 = SC + transformations, \\
%%          Power = ``StrongPower'' + transformations \cite{Lahav-Vafeiadis:FM16};
%%   \pitem the transformations are proved to be {\bf sound} in the Promise machine;
%%   \pitem For every program, SC behaviors $\subset$ ``StrongPower'' behaviors $\subset$
%%          behaviors of an axiomatic promise-free version of the Promise machine.
%% }

%% \pause

%% \only<6->{
%% \dimslide
%% \begin{textblock*}{\textwidth}(0.1\textwidth,0.4\textheight)
%% \begin{alertblock}{}
%%   \LARGE
%%   The proof scheme isn't applicable to {\bf ARM}
%%   \onslide<7->{ \\ and here is why:}
%% \end{alertblock}
%% \end{textblock*}
%% }

%% %% \pause but has {\bf not} been proved for {\bf ARM}\pause,
%% %% and the {\bf same proof} techique is {\bf not applicable}.
%% }

%% \fr{}{
%% \LARGE
%% $$\begin{array}{c}
%% [x] := 0; [y] := 0 \\
%% \begin{array}{l||l||l}
%% \inarr{
%%   a := [x]; \uncover<2->{\comment{1}} \tikzmark{comment} \\
%%   {} [x] := 1
%% } &
%% \inarr{
%%   b := [x]; \\
%%   {} [y] := b
%% } &
%% \inarr{
%%   c := [y]; \\
%%   {} [x] := c \\
%% }
%% \end{array}\end{array}$$

%% \mycallout<2>{green}{(comment)}{(-0.5cm, -1.0cm)}{Allowed by ARMv8 \cite{Flur-al:POPL16}}

%% \onslide<3>{
%% \begin{alertblock}{}
%% The behavior cannot be explained by transformations over a strong enough model.
%% \end{alertblock}
%% }
%% }

%% \fr{\LARGE Compilation scheme}{
%%   \huge
%%   \[\begin{array}{l | l}
%%     \Promise & \ARM \\
%%     \hline
%%     [x]_{\sf rlx} := a & [x] := a \\
%%     a := [x]_{\sf rlx} & a := [x] \\
%%     \hline
%%     \acqFence & \dmb \; \LD \\
%%     \relFence & \dmb \; \SY \\
%%   \end{array}\]
%% %% \pause

%% \only<2->{
%% \dimslide
%% \begin{textblock*}{\textwidth}(0.1\textwidth,0.4\textheight)
%% \begin{alertblock}{}
%%   \LARGE
%%   As the compilation scheme is bijection, we use {\bf one} syntax in
%%   examples.
%% \end{alertblock}
%% \end{textblock*}
%% }
%% }

%% \fr{\LARGE Example 1}{
%% \LARGE
%% $$\begin{array}{c}
%% \markExecuted{4}{5}{[x] := 0; [y] := 0} \\
%% \begin{array}{l||l}
%% \inarr{
%%   {} \markExecuted{5}{6}{[x] := 1}; \\
%%   {} \markExecuted{6}{7}{[y] := 1}
%% } &
%% \inarr{
%%   \markExecuted{7}{8}{a := [y]};   \uncover<2-3,15->{\comment{1}} \\
%%   \markExecuted{8}{9}{b := [x]} \; \uncover<3,16->  {\comment{0}}
%% }
%% \end{array}\end{array}$$

%%   \uncover<4->{
%%     \Large
%%     \cntrd{
%%     \begin{tikzpicture}[scale = 0.8, transform shape]
%%       \storageTwoThreads{1}{2}
%%       \node<6-9>[right] at (1, -0.1) {$[x] := 1$};
%%       \node<7-9>[right] at (1,  0.7) {$[y] := 1$};
%%       \node<8-12>[right] at (3.5, -0.1) {$a := [y]$};
%%       \node<9-13>[right] at (3.5,  0.7) {$b := [x]$};

%%       \node<10-16>[right] at (1,  0.7) {$[x] := 1$};
%%       \node<10>   [right] at (1, -0.1) {$[y] := 1$};

%%       \node<11>   [right] at (2.25, -1.4) {$[y] := 1$};
%%       \node<13-14>[right] at (2.25, -1.4) {$a := [y]$};
%%       \node<14-15>[right] at (2.25, -0.8) {$b := [x]$};

%%       \node<17>   [right] at (2.25, -1.4) {$[x] := 1$};

%%       \node<5-11>  at (2.25, -2.7) {$[x] := 0; [y] := 0$};
%%       \node<12-17> at (2.25, -2.7) {$[x] := 0; [y] := 1$};
%%       \node<18->   at (2.25, -2.7) {$[x] := 1; [y] := 1$};
%%     \end{tikzpicture}
%%     }
%%   }
%% }

%% \fr{\LARGE Example 2}{
%% \LARGE
%% $$\begin{array}{c}
%% \markExecuted{4}{5}{[x] := 0; [y] := 0} \\
%% \begin{array}{l||l}
%% \inarr{
%%   \markExecuted{5}{6}{[x] := 1}; \\
%%   \markExecuted{6}{7}{\tikzmark{dmbsy} \dmb ~\SY}; \\
%%   \markExecuted{7}{8}{[y] := 1}
%% } &
%% \inarr{
%%   \markExecuted{8}{9}{a := [y]}; \uncover<2-3>{\comment{1}} \\
%%   \dmb \tikzmark{dmbld} ~\LD; \\
%%   b := [x] \; \uncover<3>  {\nocomment{0}}
%% }
%% \end{array}\end{array}$$

%%   \uncover<4->{
%%     \Large
%%     \cntrd{
%%     \begin{tikzpicture}[scale = 0.8, transform shape]
%%       \storageTwoThreads{1.5}{2}
%%       \node<6->[right] at (1, -0.1) {$[x] := 1$};
%%       \node<7->[right] at (1,  0.5) {$\dmb ~\SY$};
%%       \node<8->[right] at (1,  1.1) {$[y] := 1$};
%%       %% \node<7-9>[right] at (1,  0.7) {$[y] := 1$};
%%       \node<9->[right] at (3.5, -0.1) {$a := [y]$};
%%       %% \node<9-13>[right] at (3.5,  0.7) {$b := [x]$};

%%       %% \node<10-16>[right] at (1,  0.7) {$[x] := 1$};
%%       %% \node<10>   [right] at (1, -0.1) {$[y] := 1$};

%%       %% \node<11>   [right] at (2.25, -1.4) {$[y] := 1$};
%%       %% \node<13-14>[right] at (2.25, -1.4) {$a := [y]$};
%%       %% \node<14-15>[right] at (2.25, -0.8) {$b := [x]$};

%%       %% \node<17>   [right] at (2.25, -1.4) {$[x] := 1$};

%%       \node<5->  at (2.25, -2.7) {$[x] := 0; [y] := 0$};
%%     \end{tikzpicture}
%%     }
%%   }

%%   \mycallout<10>{red}{(dmbsy)}{(-0.5cm, -1.0cm)}{Prevents reordering}
%%   \mycallout<11>{red}{(dmbld)}{(-0.5cm, -1.0cm)}{Forbids issuing until \\ $a := [y]$ is satisfied}
%% }

%% \fr{Example 3} {
%% % TODO: decrease slide numbers > 2 by 1.
%% \LARGE
%% $$\begin{array}{c}
%% \hspace{12pt} \markExecuted{4}{5}{[x] := 0; [y] := 0} \\
%% \begin{array}{l||l||l}
%% \inarr{
%%   \markExecuted{5}{6}{a := [x]}; \uncover<2,26->{\comment{1}} \tikzmark{comment} \\
%%   \markExecuted{6}{7}{[x] := 1}
%% } &
%% \inarr{
%%   \markExecuted{9}{10}{b := [x]}; \uncover<12->{\comment{1}} \\
%%   \markExecuted{12}{13}{[y] := b}
%% } &
%% \inarr{
%%   \markExecuted{18}{19}{c := [y]};  \uncover<21->{\comment{1}} \\
%%   \markExecuted{21}{22}{[x] := c}} \\
%% \end{array}\end{array}$$

%% \uncover<4->{
%%   \Large
%%   \begin{center}
%%   \begin{tikzpicture}[scale = 0.8, transform shape]
%%     \storageThreeThreads{1.2}{1.8}{1.2}
%%     \node<7-8>[right] at (1.0,  0.15) {$[x] := 1$};
%%     \node<6-7>[right] at (1.0, -0.4 ) {$a := [x]$};

%%     \node<10>[right] at (5.0, -0.125) {$b := [x]$};
%%     \node<13>[right] at (5.0, -0.125) {$[y] := \progval{1}$};

%%     \node<11>[right] at (3.0, -1.0 ) {$b := [x]$};
%%     \node<9-14>[right] at (3.0, -1.55) {$[x] := 1$};
%%     \node<8-15>[right] at (3.0, -2.1 ) {$a := [x]$};

%%     \node<14> [right] at (3.0, -1.0 ) {$[y] := \progval{1}$};
%%     \node<15> [right] at (3.0, -1.55) {$[y] := \progval{1}$};
%%     \node<15-26>[right] at (3.0, -1.0 ) {$[x] := 1$};
%%     \node<16> [right] at (3.0, -2.1 ) {$[y] := \progval{1}$};
%%     \node<16-24>[right] at (3.0, -1.55) {$a := [x]$};

%%     \node<17> [right] at (5.75, -3.0) {$[y] := \progval{1}$};
    
%%     \node<19>[right] at (8.5, -0.125) {$c := [y]$};
%%     \node<20>[right] at (5.75, -3.0 ) {$c := [y]$};

%%     \node<22>[right] at (8.5, -0.125) {$[x] := \progval{1}$};
%%     \node<23>[right] at (5.75, -3.0 ) {$[x] := \progval{1}$};

%%     \node<25>[right] at (5.75, -3.0) {$a := [x]$};
%%     \node<27>[right] at (5.75, -3.0) {$[x] := 1$};

%%     \node<5-17> at (5.75, -0.2 -1.2 - 1.8 - 1.2) {$[x] := 0; [y] := 0$};
%%     \node<18-23> at (5.75, -0.2 -1.2 - 1.8 - 1.2) {$[x] := 0; [y] := \progval{1}$};
%%     \node<24-27> at (5.75, -0.2 -1.2 - 1.8 - 1.2) {$[x] := \progval{1}; [y] := \progval{1}$};
%%     \node<28-> at (5.75, -0.2 -1.2 - 1.8 - 1.2) {$[x] := 1; [y] := \progval{1}$};
%%   \end{tikzpicture}
%%   \end{center}
%% }
%% }

%% \fr{Simulation}{
%%   \LARGE
%%   \iteN{
%%     \item  Introduce $SimInvariant : T_{State} \times S_{State}$;
%%     \pitem Show that \\
%%     $\forall t, t' \in T_{State}, s \in S_{State}.$ \\
%%     \pause
%%     $\quad correct(t), t \xrightarrow[T]{} t', SimInvariant(t, s)$, \\
%%     \pause
%%     $\exists s' \in S_{State}. s \xrightarrow[S]{}^{*} s', SimInvariant(t', s')$.
%%   }
%% }

%% \fri{\LARGE The ARM+$\tau$ machine}{ 
%%   \LARGE
%%   \item Add $\tau$-map component to the ARM state;
%%   \item Modify {\bf Write Commit} rule;
%%   \item Modify {\bf Propagate} rule.
%% }

%% \fr{\LARGE ARM+$\tau$ simulates ARM}{ 
%% \Large
%% $\forall \Cfarm, \{\s_i\}_{i \in [0..n]}$, \\ \pause
%% $\quad \sinit(\Cfarm) = \s_0 \armStepP \dots \armStepP \s_n, \finalStateP(\s_n)$,\\ \pause
%% $\exists \{\aT_i | \s_i = \armState{\aT_i} \}_{i \in [0..n]}$, \\
%% ${} \quad {} \aT_0 \armStep \dots \armStep \aT_n$.

%% \vfill

%% \pause
%% {\bf Sketch of the proof:}
%% \ite{
%%   \pitem Construct an order on writes from $\s_n$;
%%   \pitem Show $\s_i$ doesn't contradict the order for all $i$;
%%   \pitem Show the order may coincide with $\tau$s in $\{\aT_i\}_{i \in [0..n]}$.
%% }
%% }
