\ifdefined\ishandout
  %% \documentclass[handout,xcolor=dvipsnames]{beamer}
  \documentclass[xcolor=dvipsnames]{beamer}
\else
  \documentclass[xcolor=dvipsnames]{beamer}
\fi

\mode<presentation>
{
%% \usetheme{Frankfurt}
%% \useoutertheme{split}
	%% \usetheme{CambridgeUS}
	%% \usetheme{Hannover}
  \usetheme{Singapore}
	\usecolortheme{rose}
\beamertemplatenavigationsymbolsempty
\setbeamertemplate{mini frames}{}
}
\usepackage{amsmath,stmaryrd}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{pifont}
\usepackage{cmap}
\usepackage{listings}
\usepackage{lmodern}
\usepackage{xparse}
\usepackage{color}
\usepackage{minted}
\usepackage{graphicx}
\usepackage{tikz}
\usetikzlibrary{positioning}
\usetikzlibrary{fadings,decorations.pathmorphing,decorations.pathreplacing}
\usetikzlibrary{shapes}
\usetikzlibrary{shapes.multipart,matrix,calc}
\usetikzlibrary{arrows}
\usetikzlibrary{patterns}
\usetikzlibrary{shapes.callouts} 
\usetikzlibrary{shadows,calc}
\usepackage{wrapfig}
\usepackage{stmaryrd}
\usepackage{hyperref}
\usepackage{mathtools}
\usepackage[absolute,overlay]{textpos}
\usepackage{xspace}
\usepackage[nomessages]{fp}% http://ctan.org/pkg/fp
\usepackage{wasysym}

\usepackage[labelformat=empty]{caption}
\usepackage{fontspec}
%% \usepackage{polyglossia}
%% \setdefaultlanguage{russian}
\usepackage{ebproof}

\setmainfont[Ligatures=TeX]{CMU Serif}
\setsansfont[Ligatures=TeX]{CMU Sans Serif}
%% \setmonofont{Nimbus Mono PS}

\tikzset{
    invisible/.style={opacity=0,text opacity=0},
    visible on/.style={alt=#1{}{invisible}},
    alt/.code args={<#1>#2#3}{%
      \alt<#1>{\pgfkeysalso{#2}}{\pgfkeysalso{#3}} % \pgfkeysalso doesn't change the path
    },
}

\NewDocumentCommand{\mycallout}{r<> O{center} O{opacity=1.0,text opacity=1} m m m +m}{%
\tikz[remember picture, overlay]\node[align=#2, fill=#4!20, %text width=3cm,
#3,visible on=<#1>, rounded corners,
draw,rectangle callout,anchor=pointer,callout relative pointer={#6}
]
at #5 {#7};
}

\newcommand{\tikzmark}[1]{\tikz[overlay,remember picture,baseline=-0.5ex] \node (#1) {};}
\newcommand{\prevFr}[2]{\FPeval{#1}{clip(#2-1)}}
\newcommand{\nextFr}[2]{\FPeval{#1}{clip(#2+1)}}
\newcommand{\toGray}[3]{\only<-#1>{#3} \only<#2->{\textcolor{gray!30}{#3}}}

\newcommand{\toShadow}[3]{
  \only<#1>{#3}\only<#2>{\textcolor{colorSHADE}{#3}}
}

\definecolor{myGray}{RGB}{50,50,50}

\newcommand{\itab}[1]{\hspace{0em}\rlap{#1}}
\newcommand{\tab}[1]{\hspace{.2\textwidth}\rlap{#1}}

\newcommand{\inarr}[1]{\begin{array}{@{}l@{}}#1\end{array}}
\newcommand{\inarrII}[2]{\begin{array}{@{}l@{~~}||@{~~}l@{}}\inarr{#1}&\inarr{#2}\end{array}}
\newcommand{\inarrIII}[3]{\begin{array}{@{}l@{~~}||@{~~}l@{~~}||@{~~}l@{}}\inarr{#1}&\inarr{#2}&\inarr{#3}\end{array}}
\newcommand{\inarrIV}[4]{\begin{array}{@{}l@{~~}||@{~~}l@{~~}||@{~~}l@{~~}||@{~~}l@{}}\inarr{#1}&\inarr{#2}&\inarr{#3}&\inarr{#4}\end{array}}
\newcommand{\inarrV}[5]{\begin{array}{@{}l@{~~}||@{~~}l@{~~}||@{~~}l@{~~}||@{~~}l@{~~}||@{~~}l@{}}\inarr{#1}&\inarr{#2}&\inarr{#3}&\inarr{#4}&\inarr{#5}\end{array}}
\newcommand{\inarrc}[1]{\begin{array}{@{}c@{}}#1\end{array}}
\newcommand{\inarrIIId}[3]{\begin{array}{@{}l@{~}||@{~}l@{~}||@{~}l@{}}\inarr{#1}&\inarr{#2}&\inarr{#3}\end{array}}

\newcommand{\myblock}[1]{\begin{block}{} #1 \end{block}}


\definecolor{CommentColor}{rgb}{0.0,0.4,0.1}

\newcommand{\commenta}[1]{\color{CommentColor}{\texttt{/*}\textit{ #1 }\texttt{*/}}}
\newcommand{\comment}[1]{{\color{CommentColor}~\texttt{/\!\!/}\,{#1}}}
\newcommand{\nocomment}[1]{{\color{red}~~\texttt{/\!\!/}\,{#1}}}
\newcommand{\progval}[1]{{\color{CommentColor} #1}}

\newcommand\semState[2]{\llbracket #1 \rrbracket _{#2}}

\newcommand{\storageThreeThreads}[3]{
    \draw (0,0.5) rectangle (3,1) node [pos=.5] {Thread 1};
    \draw (3.5,0.5) rectangle (6.5 ,1) node [pos=.5] {Thread 2};
    \draw (7.0,0.5) rectangle (10.0,1) node [pos=.5] {Thread 3};
    \draw (1,0.5) -- (1, 0.5 -#1) -- (5.0, 0.5 -#1) -- (5.0,0.5);
    \draw (3.0, 0.5 -#1) -- (3.0, 0.5 -#1 - #2) -- (8.5, 0.5 -#1 - #2) -- (8.5, 0.5);
    \draw (5.75, 0.5 -#1 - #2) -- (5.75, 0.5 -#1 - #2 - #3);

    \node at (5.75, 0.3 -#1 - #2 - #3) {The main memory};
    \draw (4.75, 0.1 -#1 - #2 - #3) -- (6.75, 0.1 -#1 - #2 - #3);
}

\newcommand{\storageTwoThreads}[2]{
    \draw (0,#1) rectangle (2,#1 + 0.5) node [pos=.5] {Thread 1};
    \draw (2.5,#1) rectangle (4.5,#1 + 0.5) node [pos=.5] {Thread 2};
    \draw (1,#1) -- (1,-0.5) -- (3.5,-0.5) -- (3.5,#1);
    \draw (2.25, -0.5) -- (2.25, -#2);

    \node at (2.25, -#2 - 0.2) {The main memory};
    \draw (1.25, -#2 - 0.4) -- (3.25, -#2 - 0.4);
}

\newcommand{\executed}[1]{\colorbox{gray}{\ensuremath{#1}}}
\newcommand{\markExecuted}[3]{
  \only<-#1>{#3}
  \only<#2->{\executed{#3}}
}
\newcommand{\light}[1]{\textcolor{gray!30}{#1}}

\makeatletter
\def\ft@overlay{}

\addtobeamertemplate{footline}{}%
{%
  \lineskiplimit0pt
  \begin{tikzpicture}[remember picture,overlay]%
  \ft@overlay
  \end{tikzpicture}%
  \gdef\ft@overlay{}%
}

\newcommand<>{\addtooverlay}[1]{%
  \only#2{%
  \expandafter\gdef\expandafter\ft@overlay\expandafter{\ft@overlay #1}%
  }%
}

\def\shadowshift{3pt,-3pt}
\def\shadowradius{6pt}

\colorlet{innercolor}{black!60}
\colorlet{outercolor}{blue!05}

% this draws a shadow under a rectangle node
\newcommand\drawshadow[1]{
    \begin{pgfonlayer}{shadow}
        \shade[outercolor,inner color=innercolor,outer color=outercolor] ($(#1.south west)+(\shadowshift)+(\shadowradius/2,\shadowradius/2)$) circle (\shadowradius);
        \shade[outercolor,inner color=innercolor,outer color=outercolor] ($(#1.north west)+(\shadowshift)+(\shadowradius/2,-\shadowradius/2)$) circle (\shadowradius);
        \shade[outercolor,inner color=innercolor,outer color=outercolor] ($(#1.south east)+(\shadowshift)+(-\shadowradius/2,\shadowradius/2)$) circle (\shadowradius);
        \shade[outercolor,inner color=innercolor,outer color=outercolor] ($(#1.north east)+(\shadowshift)+(-\shadowradius/2,-\shadowradius/2)$) circle (\shadowradius);
        \shade[top color=innercolor,bottom color=outercolor] ($(#1.south west)+(\shadowshift)+(\shadowradius/2,-\shadowradius/2)$) rectangle ($(#1.south east)+(\shadowshift)+(-\shadowradius/2,\shadowradius/2)$);
        \shade[left color=innercolor,right color=outercolor] ($(#1.south east)+(\shadowshift)+(-\shadowradius/2,\shadowradius/2)$) rectangle ($(#1.north east)+(\shadowshift)+(\shadowradius/2,-\shadowradius/2)$);
        \shade[bottom color=innercolor,top color=outercolor] ($(#1.north west)+(\shadowshift)+(\shadowradius/2,-\shadowradius/2)$) rectangle ($(#1.north east)+(\shadowshift)+(-\shadowradius/2,\shadowradius/2)$);
        \shade[outercolor,right color=innercolor,left color=outercolor] ($(#1.south west)+(\shadowshift)+(-\shadowradius/2,\shadowradius/2)$) rectangle ($(#1.north west)+(\shadowshift)+(\shadowradius/2,-\shadowradius/2)$);
        %% \filldraw ($(#1.south west)+(\shadowshift)+(\shadowradius/2,\shadowradius/2)$) rectangle ($(#1.north east)+(\shadowshift)-(\shadowradius/2,\shadowradius/2)$);
    \end{pgfonlayer}
}

% create a shadow layer, so that we don't need to worry about overdrawing other things
\pgfdeclarelayer{shadow} 
\pgfsetlayers{shadow,main}

\newsavebox\mybox
\newlength\mylen

%% \newcommand\shadowimage[2][]{%
%% \begin{tikzpicture}
%% \node[anchor=south west,inner sep=0] (image) at (0,0) {\colorbox{white}{\includegraphics[#1]{#2}}};
%% \drawshadow{image}
%% \end{tikzpicture}}

\newcommand\shadowimage[2][]{%
\setbox0=\hbox{\includegraphics[#1]{#2}}
\setlength\mylen{\wd0}
\ifnum\mylen<\ht0
\setlength\mylen{\ht0}
\fi
\divide \mylen by 120
\def\shadowshift{\mylen,-\mylen}
\def\shadowradius{\the\dimexpr\mylen+\mylen+\mylen\relax}
\begin{tikzpicture}
  \node[anchor=south west,inner sep=0] (image) at (0,0) {\colorbox{white}{\includegraphics[#1]{#2}}};
  \begin{pgfonlayer}{shadow}
     \drawshadow{image}
  \end{pgfonlayer}
\end{tikzpicture}}

\makeatother

% SET OVERLAY NUMBER ORDER
\usepackage{etoolbox}
\usepackage{xstring}
\newcounter{mycounter}

% #1 is of the form <name>[=-|n], e.g. foo=- or foo=10 or foo
% Stores in #2 the overlay specification for <name> s.t. it can be appended to the content of <name>
\newcommand*{\getNewOverlayContent}[2]{%
    \getItemSpec{#1}{itemSpec}%
    \IfStrEq{\itemSpec}{-}{%
        \csedef{#2}{\arabic{beamerpauses}-}%
    }{%
        \IfStrEq{\itemSpec}{}{%
            \csedef{#2}{\arabic{beamerpauses}}%
        }{%
            \IfInteger{\itemSpec}{%
%               \mycounter=\
                \setcounter{mycounter}{\arabic{beamerpauses}}%
                \addtocounter{mycounter}{\itemSpec}%
                \addtocounter{mycounter}{-1}%
                \csedef{#2}{\arabic{beamerpauses}-\arabic{mycounter}}%
            }{%
                \PackageError{setorder}{Argument has illegal format}{Argument was #1}%
            }%
        }%
    }%
%   input: #1, itemspec:\itemSpec, beamervalue: \arabic{beamerpauses}, content: \csuse{#2} \\
}
% #1 is of the form 'foo=1' or 'foo=-' or 'foo'. 
% #2 Is the name of the macro which should hold the result
% This macro stores the part infront '=' (the name) in #2.
\newcommand*{\getItemName}[2]{% 
    \IfSubStr{#1}{=}{%
        \StrBefore{#1}{=}[\tmp]%
        \csdef{#2}{\tmp}%
    }{%
        \csdef{#2}{#1}% 
    }%
}
% #1 is of the form 'foo=1' or 'foo=-' or 'foo'. 
% #2 Is the name of the macro which should hold the result
% This macro stores the part behind '=' (the overlay spec) in #2. The stored part is empty iff there is no '=' in #1
\newcommand*{\getItemSpec}[2]{%
    \StrBehind{#1}{=}[\tmp]%
    \csdef{#2}{\tmp}%
}
% #2 is the name where content should be appended. 
% It has been ensured previously that #2 is a defined macro
% #1 is the content to append
% Depending on whether #2 is empty or not a (,) is added 
% before appending #1
\newcommand*{\appendToOverlaySpecification}[2]{%
    \IfStrEq{\csexpandonce{#2}}{}{%
        % #1 i.e. <name> is empty
        \cseappto{#2}{\csname#1\endcsname}%
    }{%
        \cseappto{#2}{,\csname#1\endcsname}%
    }%
}

\newcommand*{\setorderItem}[1]{%
    \getNewOverlayContent{#1}{overlaycontent}%
    \getItemName{#1}{cmdname}%
    \appendToOverlaySpecification{overlaycontent}{\cmdname}%
}

\newcommand*{\setorderList}[1]{%
    \forcsvlist{\setorderItem}{#1}%
    \stepcounter{beamerpauses}%
}
\newcommand*{\setorder}[1]{%    
    \clearNamesListofLists{#1}%
    \forcsvlist{\setorderList}{#1}%
    %% \createBef{#1}%
}

%% \newcommand*{\createBefItem}[1]{%
%%     \getItemName{#1}{cmdname}%
%%     \getItemName{bef#1}{cmdnameBef}%
%%     \csdef{\cmdnameBef}{}% 
%%     \prevFr{\cmdnameBef}{\cmdname}%
%% }

%% \newcommand*{\createBefList}[1]{%
%%     \forcsvlist{\createBefItem}{#1}%
%% }

%% \newcommand*{\createBef}[1]{%
%%     \forcsvlist{\createBefList}{#1}%
%% }

% takes a list of lists of the form: {foo=1, bla},{gar=-} and then defines empty macros for each name
\newcommand*{\clearNamesListofLists}[1]{%
    \forcsvlist{    \clearNamesList}{#1}%
}
\newcommand*{\clearNamesList}[1]{%
    \forcsvlist{    \clearName}{#1}%
}
\newcommand*{\clearName}[1]{%
    \getItemName{#1}{cmdname}%
    \csdef{\cmdname}{}% 
}

\lstdefinelanguage
   [sparc]{Assembler}     % add a "x64" dialect of Assembler
   [x86masm]{Assembler} % based on the "x86masm" dialect
   % with these extra keywords
   {morekeywords={ldw, stw, LD, ADD, SUB, ST, OP, BR, BLTZ, BGTZ, HALT, CMOZ, BL}} % etc.
\lstset{language={[sparc]Assembler}}

\include{defs}

%% \selectlanguage{russian}
%% \newtranslation[to=russian]{Section}{Раздел}
%% \AtBeginSection{\frame{\sectionpage}}
\AtBeginSection[]
{
  \begin{frame}<beamer>
    \large
    \LARGE
    %% \frametitle{Outline for section \thesection}
    \tableofcontents[currentsection]
  \end{frame}
}

\addtobeamertemplate{navigation symbols}{}{%
    \usebeamerfont{footline}%
    \usebeamercolor[fg]{footline}%
    \hspace{1em}%
    {\bf \huge \insertframenumber}
}

\definecolor{darkGreen}{RGB}{0,127,0}
\definecolor{darkYellow}{RGB}{127,127,0}
\definecolor{darkRed}{RGB}{127,0,0}
\definecolor{darkBlue}{RGB}{0,0,127}
\definecolor{darkPurple}{RGB}{127,0,127}
\colorlet{colorFETCH}{gray!40!white}
\colorlet{colorSAT}{yellow!40!white}
\colorlet{colorCOM}{green!40!white}
\colorlet{colorBUG}{red!20!white}
\colorlet{colorPROP}{green!80!black}
\colorlet{colorNPROP}{red!80!black}
\colorlet{colorVAL}{green!80!black}
\colorlet{colorPROM}{darkGreen}
\colorlet{colorPOSTPONE}{magenta!80!black}
\colorlet{colorSHADE}{gray!70}
\colorlet{colorCOV}{magenta!20}
\colorlet{colorISS}{green!30!white}

\colorlet{colorPO}{gray!60!black}
\colorlet{colorRF}{green!60!black}
\colorlet{colorMO}{orange}
\colorlet{colorFR}{purple}
\colorlet{colorECO}{red!80!black}
\colorlet{colorSYN}{green!40!black}
\colorlet{colorHB}{blue}
\colorlet{colorPPO}{magenta}
\colorlet{colorPB}{olive}
\colorlet{colorSBRF}{olive}
\colorlet{colorRMW}{olive!70!black}
\colorlet{colorRSEQ}{blue}
\colorlet{colorSC}{violet}
\colorlet{colorPSC}{violet}
\colorlet{colorREL}{olive}
\colorlet{colorCONFLICT}{olive}
\colorlet{colorRACE}{olive}
\colorlet{colorWB}{orange!70!black}
\colorlet{colorPSC}{violet}
\colorlet{colorSCB}{violet}
\colorlet{colorDEPS}{violet}

\tikzset{
   every path/.style={>=stealth},
   po/.style={->,color=brown,,shorten >=-0.5mm,shorten <=-0.5mm},
   rf/.style={->,color=green!60!black,dashed,,shorten >=-0.5mm,shorten <=-0.5mm},
   fr/.style={->,color=red,thick,shorten >=-0.5mm,shorten <=-0.5mm},
   mo/.style={->,color=orange!60!red,dotted,thick,shorten >=-0.5mm,shorten <=-0.5mm},
   no/.style={->,dotted,thick,shorten >=-0.5mm,shorten <=-0.5mm},
   deps/.style={->,color=violet,dotted,thick,shorten >=-0.5mm,shorten <=-0.5mm},
}

\newcommand{\lX}{\mathtt{X}}
\newcommand{\lPO}{{\color{colorPO}\mathtt{po}}}
\newcommand{\lRF}{{\color{colorRF} \mathtt{rf}}}
\newcommand{\lRMW}{{\color{colorRMW} \mathtt{rmw}}}
\newcommand{\lMO}{{\color{colorMO} \mathtt{mo}}}
\newcommand{\lMOx}{{\color{colorMO} \mathtt{mo}}_x}
\newcommand{\lMOy}{{\color{colorMO} \mathtt{mo}}_y}
\newcommand{\lCO}{{\color{colorMO} \mathtt{co}}}
\newcommand{\lCOx}{{\color{colorMO} \mathtt{co}}_x}
\newcommand{\lCOy}{{\color{colorMO} \mathtt{co}}_y}
\newcommand{\lFR}{{\color{colorFR} \mathtt{fr}}}
\newcommand{\lFRx}{{\color{colorFR} \mathtt{fr}}_x}
\newcommand{\lFRy}{{\color{colorFR} \mathtt{fr}}_y}
\newcommand{\lECO}{{\color{colorECO} \mathtt{eco}}}
\newcommand{\lSBRF}{{\color{colorSBRF} \mathtt{sbrf}}}
\newcommand{\lRSEQ}{{\color{colorRSEQ}\mathtt{rseq}}}
\newcommand{\lSW}{{\color{colorSYN}\mathtt{sw}}}
\newcommand{\lHB}{{\color{colorHB}\mathtt{hb}}}
%\newcommand{\lWB}{{\color{colorWB} \mathtt{wb}}}
\newcommand{\lDOB}{{\mathtt{dob}}}
\newcommand{\lBOB}{{\mathtt{bob}}}
\newcommand{\lAOB}{{\mathtt{aob}}}
\newcommand{\lOBS}{{\mathtt{obs}}}
\newcommand{\lEORD}{{\mathtt{eord}}}
\newcommand{\lTORD}{{\mathtt{tord}}}
\newcommand{\lSC}{{\mathtt{sc}}}

\tikzset{
    ncbar angle/.initial=90,
    ncbar/.style={
        to path=(\tikztostart)
        -- ($(\tikztostart)!#1!\pgfkeysvalueof{/tikz/ncbar angle}:(\tikztotarget)$)
        -- ($(\tikztotarget)!($(\tikztostart)!#1!\pgfkeysvalueof{/tikz/ncbar angle}:(\tikztotarget)$)!\pgfkeysvalueof{/tikz/ncbar angle}:(\tikztostart)$)
        -- (\tikztotarget)
    },
    ncbar/.default=0.5cm,
}

\tikzset{square left brace/.style={ncbar=0.3cm}}
\tikzset{square right brace/.style={ncbar=-0.3cm}}

\tikzset{round left paren/.style={ncbar=0.5cm,out=120,in=-120}}
\tikzset{round right paren/.style={ncbar=0.5cm,out=60,in=-60}}

%% Custom TikZ patterns

% defining the new dimensions and parameters
\newlength{\hatchspread}
\newlength{\hatchthickness}
\newlength{\hatchshift}
\newcommand{\hatchcolor}{}
% declaring the keys in tikz
\tikzset{hatchspread/.code={\setlength{\hatchspread}{#1}},
         hatchthickness/.code={\setlength{\hatchthickness}{#1}},
         hatchshift/.code={\setlength{\hatchshift}{#1}},% must be >= 0
         hatchcolor/.code={\renewcommand{\hatchcolor}{#1}}}
% setting the default values
\tikzset{hatchspread=10pt,
         hatchthickness=4pt,
         hatchshift=0pt,% must be >= 0
         hatchcolor=black}
% declaring the pattern
\pgfdeclarepatternformonly[\hatchspread,\hatchthickness,\hatchshift,\hatchcolor]% variables
   {custom north west lines}% name
   {\pgfqpoint{\dimexpr-2\hatchthickness}{\dimexpr-2\hatchthickness}}% lower left corner
   {\pgfqpoint{\dimexpr\hatchspread+2\hatchthickness}{\dimexpr\hatchspread+2\hatchthickness}}% upper right corner
   {\pgfqpoint{\dimexpr\hatchspread}{\dimexpr\hatchspread}}% tile size
   {% shape description
    \pgfsetlinewidth{\hatchthickness}
    \pgfpathmoveto{\pgfqpoint{0pt}{\dimexpr\hatchspread+\hatchshift}}
    \pgfpathlineto{\pgfqpoint{\dimexpr\hatchspread+0.15pt+\hatchshift}{-0.15pt}}
    \ifdim \hatchshift > 0pt
      \pgfpathmoveto{\pgfqpoint{0pt}{\hatchshift}}
      \pgfpathlineto{\pgfqpoint{\dimexpr0.15pt+\hatchshift}{-0.15pt}}
    \fi
    \pgfsetstrokecolor{\hatchcolor}
%    \pgfsetdash{{1pt}{1pt}}{0pt}% dashing cannot work correctly in all situation this way
    \pgfusepath{stroke}
   }

\pgfdeclarepatternformonly[\hatchspread,\hatchthickness,\hatchshift,\hatchcolor]% variables
   {custom north east lines}% name
   {\pgfqpoint{\dimexpr-2\hatchthickness}{\dimexpr-2\hatchthickness}}% lower left corner
   {\pgfqpoint{\dimexpr\hatchspread+2\hatchthickness}{\dimexpr\hatchspread+2\hatchthickness}}% upper right corner
   {\pgfqpoint{\dimexpr\hatchspread}{\dimexpr\hatchspread}}% tile size
   {% shape description
    \pgfsetlinewidth{\hatchthickness}
    \pgfpathmoveto{\pgfqpoint{\dimexpr\hatchshift-0.15pt}{-0.15pt}}
    \pgfpathlineto{\pgfqpoint{\dimexpr\hatchspread+0.15pt}{\dimexpr\hatchspread-\hatchshift+0.15pt}}
    \ifdim \hatchshift > 0pt
      \pgfpathmoveto{\pgfqpoint{-0.15pt}{\dimexpr\hatchspread-\hatchshift-0.15pt}}
      \pgfpathlineto{\pgfqpoint{\dimexpr\hatchshift+0.15pt}{\dimexpr\hatchspread+0.15pt}}
    \fi
    \pgfsetstrokecolor{\hatchcolor}
%    \pgfsetdash{{1pt}{1pt}}{0pt}% dashing cannot work correctly in all situation this way
    \pgfusepath{stroke}
   }

\newcommand{\cntrd}[1]{ \begin{center} #1 \end{center} }
\newcommand\titlebox[2][]{\tikz[overlay]\node[fill=black,
  text=white,inner sep=20pt, anchor=text,
  rectangle, rounded corners=2mm,#1] {#2};\phantom{#2}}

\begin{document}

\title
{Операционные методы в приложении к слабым моделям памяти}
\author
[А.В. Подкопаев]
{\textbf{Подкопаев Антон Викторович}}
\institute{
Специальность: 05.13.11
``Математическое и программное обеспечение вычислительных машин,
комплексов и компьютерных сетей'' \\
\vspace{1.0cm}
\begin{tabular}{r l}
Научный руководитель: & д.т.н., проф. Кознов Д.В. (СПбГУ) \\
\\
Официальные оппоненты: & д.т.н., проф. Гергель В.П. (ННГУ) \\
                       & к.т.н., доц. Лукашин А.А. (СПбГПУ) \\
\\
Ведущая организация: & ИСП РАН
\end{tabular}

\vspace{1.0cm}
Санкт-Петербург
%% Семинар ИСП РАН
}
\date[17-05-18]{17.05.2018}

\frame[noframenumbering,plain]{
  \includegraphics[width=1.7cm]{SPbGU_Logo.png}
  \vspace{-40pt}
  %% \hspace{-10pt}
  \begin{center}
    % \begin{tabular}{m{1.5cm}  m{0.48\textwidth}}
    %   \begin{center}\includegraphics[width=1.5cm]{SPbGU_Logo.png}\end{center} 
    %   &
    \begin{tabular}{c}
      \scriptsize{Санкт-Петербургский государственный университет} \\
      \scriptsize{Кафедра системного программирования}
    \end{tabular}
  \end{center}
  %% \vspace{0.2cm}
  %% \titlebox
  \cntrd{
  \color{darkBlue}
  {\Large Операционные методы в приложении \newline к слабым моделям памяти}%\\
  }
  % \vspace{0.7cm}
  % \titlebox{\large \hspace{1.4cm}\textbf{Березун Даниил}\hspace{1.4cm}$\;$}
  % \titlebox{\large \hspace{1.31cm}\textbf{Березун Даниил Андреевич}\hspace{1.31cm}$\;$}
  %% \vspace{0.1cm}
  \cntrd{
  \textbf{Подкопаев Антон Викторович}
  % \vfill
  % Санкт-Петербургский Государственный Университет\\
  % СПбГУ, мат.-мех. ф-т, кафедра системного программирования\\
  % СПбГУ, Мат-Мех, кафедра СП\\
  % Лаборатория языковых инструментов JetBrains\\
  %{\color{blue}{d.berezun@2009.spbu.ru}}\\
  %% \vfill

  \vspace{0.2cm}
  {\scriptsize  Специальность: {\color{blue}05.13.11}
  ``Математическое и программное обеспечение вычислительных
  машин, комплексов и компьютерных сетей''}\\
  }
  \vfill
  {\scriptsize
    {
      \begin{tabular} {p{0.5cm} r l} 
        &{Научный руководитель:}  & д.т.н., проф. Кознов Д.В. (СПбГУ)\\
        &{Официальные оппоненты:} & д.т.н., проф. Гергель В.П. (ННГУ) \\
        &                         & к.т.н., доц. Лукашин А.А. (СПбГПУ) \\
        &{Ведущая организация:} & ИСП РАН\\ 
      \end{tabular}
    }}
  % Научный руководитель: д.т.н., профессор Кознов Д.В. \hfill (СПбГУ)\\
  % Научные консультанты: Jones, Neil D. \hfill ({DIKU}, prof. em.)\\
  % \hspace{4.55cm}к.ф.-м.н. Булычев Д.Ю. \hfill (СПбГУ)\\ 
  \vfill
  \cntrd{{\scriptsize Санкт-Петербург, 2018}}
}

\newcommand{\fr} [2]{\begin{frame}{#1} #2 \end{frame}}
\newcommand{\frN}[2]{\begin{frame}[noframenumbering]{#1} #2 \end{frame}}
\newcommand{\ite}[1]{\begin{itemize} #1 \end{itemize}}
\newcommand{\iteN}[1]{\begin{enumerate} #1 \end{enumerate}}
\newcommand{\colu}[2]{\begin{column}{#1} #2 \end{column}}
\newcommand{\ex}{\textbf{Ex: }}
\newcommand{\exN}[1]{\textbf{Ex #1: }}
\newcommand{\df}{\textbf{Def: }}
\newcommand{\pitem}{\pause \item}
\newcommand{\lstasm}[1]{\lstinputlisting[language={[sparc]Assembler}]{codes/#1}}
\newcommand{\lstinlineasm}[1]{\lstinline[language={[sparc]Assembler}]{#1}}
\newcommand{\fri}[2]{\fr{#1}{\ite{#2}}}
\newcommand{\fre}[2]{\fr{#1}{\iteN{#2}}}
\newcommand{\frc}[2]{\fr{#1}{\begin{columns} #2 \end{columns}}}
\newcommand{\colui}[2]{\colu{#1}{\ite{#2}}}
\newcommand{\phrase}[1]{
  \fr{}{
  \begin{center}
    \Huge #1
  \end{center}
  }
}
\newcommand{\phraseL}[1]{
  \fr{}{
  \begin{center}
    \Large #1
  \end{center}
  }
}
\newcommand{\alertcolor}{red!60!black}
\setbeamercolor{alerted text}{fg=\alertcolor}
\newcommand\tick{{\color{green!50!black} \ding{51}}}
\newcommand\fail{{\color{red!50!black} \ding{55}}}

\newcommand{\relo}{{\texttt{rel}}}
\newcommand{\acqo}{{\texttt{acq}}}
\newcommand{\sco}{{\texttt{sc}}}
\newcommand{\na}{\texttt{na}}
\newcommand{\pln}{\texttt{pln}}
\newcommand{\atm}{\texttt{atm}}
\newcommand{\ra}{\texttt{ra}}
\newcommand{\rlx}{\texttt{rlx}}
%\newcommand{\unord}{\texttt{uno}}
\newcommand{\relacqo}{{\texttt{relacq}}}
\newcommand{\rlxmsg}[3]{\tup{#1\mathbin{:}#2\text{\smaller@}#3}}
\newcommand{\ts}[1]{\color{blue!60!green}{\mbox{\smaller#1}}}

\newcommand{\rlab}{\texttt{R}}
\newcommand{\wlab}{\texttt{W}}
\newcommand{\ulab}{\texttt{U}}
\newcommand{\slab}{\texttt{S}}
\newcommand{\tlab}{\texttt{T}}
\newcommand{\valw}{\mathit{val}_{\sf w}}
\newcommand{\flab}{\texttt{F}}

\newcommand{\dimslide}[1]{
   \addtooverlay<#1>{%
     \draw[fill=black,opacity=0.70] 
     (current page.north east) rectangle (current page.south west);
   }
}
\NewDocumentCommand{\dimalert}{r<> m}{%
\only<#1>{
\dimslide{#1}
\begin{textblock*}{\textwidth}(0.1\textwidth,0.4\textheight)
\begin{alertblock}{}
  \LARGE #2
\end{alertblock}
\end{textblock*}
}
}

\newcommand{\instBackground}[2]{
    \fill[#1, rounded corners=3pt] ($(#2)  + (-1.1,0.35)$) rectangle ++(2.2,-0.7);
}
\newcommand{\parLines}[1]{
      \draw[-,ultra thick] ($(#1) + (-0.1,0.5)$) -- ($(#1) + (-0.1,-0.5-0.8)$);
      \draw[-,ultra thick] ($(#1) + ( 0.1,0.5)$) -- ($(#1) + ( 0.1,-0.5-0.8)$);
}

\newcommand{\indepCommentLeft}[2]{
      \draw[-,red,ultra thick] ($(#1) + (0.1, 0)$)
        to[out=0,in=0] ($(#2) + (0.1, 0)$);
      \node[anchor=west] at ($(#1) + (0.3, -0.4)$)  {\Large \textcolor{red}{Independent}};
}

\newcommand{\indepCommentRight}[2]{
      \draw[-,red,ultra thick] ($(#1) + (0.1, 0)$)
        to[out=180,in=180] ($(#2) + (0.1, 0)$);
      \node[anchor=east] at ($(#1) + (-0.1, -0.4)$)  {\Large \textcolor{red}{Independent}};
}

\newcommand{\promMsg}[3]{\angled{#1:#2@\tstampWOsize{#3}}}

\newcommand{\promisedTXT}{Обещана} % Promised
\newcommand{\postponedTXT}{Отложена} % Postponed
\newcommand{\lviewTXT}{Л.фронт} % LView
\newcommand{\rviewTXT}{П.фронт} % RView

\newcommand{\ptrPromise}[1]{
    \draw[->,ultra thick] ($(#1)  + (-3.0,0.39)$) -- +(1.9, 0.0);
    \node at ($(#1) + (-2.1,0.62)$) {\large \Promise};
}
\newcommand{\ptrPromiseLeft}[1]{
    \draw[->,ultra thick] ($(#1)  + (-1.2,0.39)$) -- +(1.6, 0.0);
}
\newcommand{\ptrPromiseRight}[1]{
  \ptrPromiseLeft{#1}
    %% \draw[->,ultra thick] ($(#1)  + (3.0,0.39)$) -- +(-1.9, 0.0);
}
\newcommand{\postponedBorder}[1]{
    \draw[colorPOSTPONE, ultra thick] ($(#1)  + (-1.1,0.3)$) rectangle ++(2.2,-0.6);
}
\newcommand{\postponedCommentLeft}[1]{
    \node[anchor=east] at ($(#1) - (1.4, 0.0)$) {\Large \textcolor{colorPOSTPONE}{\postponedTXT}};
}
\newcommand{\promisedBorder}[1]{
    \draw[colorPROM, ultra thick, rounded corners=3pt] ($(#1)  + (-1.1,0.35)$) rectangle ++(2.2,-0.7);
}
\newcommand{\promisedCommentDown}[1]{
    \node at ($(#1) + (0, -0.6)$) {\Large \textcolor{colorPROM}{\promisedTXT}};
}
\newcommand{\promisedCommentLeft}[1]{
    \node[anchor=east] at ($(#1) - (1.4, 0.0)$) {\Large \textcolor{colorPROM}{\promisedTXT}};
}
\newcommand{\promisedCommentRight}[1]{
    \node[anchor=west] at ($(#1) + (1.4, 0.0)$) {\Large \textcolor{colorPROM}{\promisedTXT}};
}

\newcommand{\traverseSingleBorder}[2]{
    \draw[pattern=custom north east lines, hatchcolor=#1, thick, rounded corners] ($(#2)  + (-0.35,-0.3)$) rectangle ++(0.7,0.6);
}

\newcommand{\traverseTwoVertBorder}[3]{
    \draw[pattern=custom north east lines, hatchcolor=#1, thick, rounded corners] ($(#2)  + (-0.45,0.4)$) rectangle ($(#3)  + (0.45,-0.4)$);
}

%% {\setbeamertemplate{footline}{}
%% \setbeamertemplate{headline}{}
%% \frame[plain,noframenumbering]{\titlepage}}
%% \begin{frame}[plain,noframenumbering]
%%   \titlepage
%% \end{frame}

%% \fri{\huge Что нужно для быстрого ПО?}{
%% \LARGE
%% \pause
%% \item \only<-4>{Хороший Алгоритм} \only<5->{\textcolor{gray!30}{Хороший Алгоритм}}
%% \vfill
%% \pause
%% \item \only<-5>{Эффективный}\only<6>{{\bf ?Эффективный?}}\only<7->{{\bf Оптимизирующий}} Компилятор
%% \vfill
%% \pause
%% \item \only<-7>{Производительный}\only<8>{{\bf ?Производительный?}}\only<9->{{\bf Оптимизирующий}} Процессор
%% }

%% \section{Контекст, мотивация, задачи}
\phrase{
  {\bf Модель памяти} \\ (memory model, MM) --- семантика многопоточной системы\\
}

\phrase{
  Последовательная консистентность (SC) \cite{Lamport:TC79}
  \vfill
  %% \pause
  \emph{семантика системы --- попеременное исполнение потоков}
}

\newcommand{\loadBufferValues}[2]{
      \node (memoryValues) at ($(middleBuffer) + (2.0, -3.2)$) {};

      \onslide<\storageAppearFr->{
        %% \storageTwoThreadsRelative{(leftBuffer)}{(rightBuffer)}{1.7}{0.5}{-3.0}
        \draw[draw,fill=yellow!20] ($(memoryValues) + (-1.9,0.8)$) rectangle ($(memoryValues) + (1.9,-0.3)$) ;
        \node[anchor=north] at ($(memoryValues) + (0,0.85)$) {\Large Память};
      }

      \node at ($(memoryValues) + (-0.05, -0.1)$) {\Large $;$}; 
      \node<-\befPropWriteRightFr>[anchor=east] at (memoryValues) {\Large $\writeReq{x}{0}$}; 
      \node<\propWriteRightFr->[anchor=east] at (memoryValues) {\Large $\writeReq{x}{\textcolor{colorVAL}{1}}$}; 
      \node<-\befPropWriteLeftFr>[anchor=west] at (memoryValues) {\Large $\writeReq{y}{0}$}; 
      \node<\propWriteLeftFr->[anchor=west] at (memoryValues) {\Large $\writeReq{y}{\textcolor{colorVAL}{1}}$}; 

      \node (values) at ($(memoryValues) + (-4.0, 0.0)$) {};
      
      \onslide<\firstFr->
        { \draw[draw,fill=yellow!20] ($(values) + (-1.9,  0.8)$) rectangle
                                     ($(values) + ( 1.9, -0.3)$) ;
          \node[anchor=north] at ($(values) + (0,  0.85)$) {\Large Регистры}; }
      \node at ($(values) + (-0.05, -0.1)$) {\Large $;$}; 
      \node<-\befPropReadLeftFr>[anchor=east] at (values) {\Large $a = \bot$}; 
      \node<\propReadLeftFr->[anchor=east] at (values) {\Large $a = \textcolor{colorVAL}{#1}$}; 
      \node<-\befPropReadRightFr>[anchor=west] at (values) {\Large $b = \bot$}; 
      \node<\propReadRightFr->[anchor=west] at (values) {\Large $b = \textcolor{colorVAL}{#2}$}; 
}

\fr{\huge Исполнение в SC}{
  \setorder{{firstFr, storageAppearFr,pointerAppearFr},
            {propReadLeftFr},
            {propReadRightFr},
            {comRightFr, propWriteRightFr},
            {comLeftFr, propWriteLeftFr},
            {noWeakFr}}
  \prevFr{\befPropWriteLeftFr}{\propWriteLeftFr}
  \prevFr{\befPropReadLeftFr}{\propReadLeftFr}
  \prevFr{\befPropWriteRightFr}{\propWriteRightFr}
  \prevFr{\befPropReadRightFr}{\propReadRightFr}

  \cntrd{
    \begin{tikzpicture}
      \node (leftFirstInst)   {};
      \node (leftSecondInst)  [below of= leftFirstInst, node distance = 0.8cm] {};
      \node (leftThirdInst)   [below of= leftSecondInst, node distance = 0.8cm] {};
      \node (rightFirstInst)  [right of=  leftFirstInst, node distance = 3.0cm] {};
      \node (rightSecondInst) [below of= rightFirstInst, node distance = 0.8cm] {};
      \node (rightThirdInst)  [below of= rightSecondInst, node distance = 0.8cm] {};

      \node (instMiddle)   at ($.5*(leftFirstInst) + .5*(rightFirstInst)$) {};
      \node (leftBuffer)   at (leftSecondInst)  {};
      \node (rightBuffer)  at (rightSecondInst) {};
      \node (middleBuffer) at ($.5*(leftBuffer) + .5*(rightBuffer)$) {};
      \node (finalValues)  at ($(middleBuffer) + (0, -4.5)$) {};

      \onslide<\pointerAppearFr-\befPropReadLeftFr>
        { \ptrPromiseLeft{leftFirstInst} } 
      \onslide<\propReadLeftFr-\befPropWriteLeftFr>
        { \ptrPromiseLeft{leftSecondInst} } 
      \onslide<\propWriteLeftFr->
        { \ptrPromiseLeft{leftThirdInst} } 

      \onslide<\pointerAppearFr-\befPropReadRightFr>
        { \ptrPromiseRight{rightFirstInst} }
      \onslide<\propReadRightFr-\befPropWriteRightFr>
        { \ptrPromiseRight{rightSecondInst} } 
      \onslide<\propWriteRightFr->
        { \ptrPromiseRight{rightThirdInst} } 

      \loadBufferValues{0}{0}

      \node at (leftFirstInst)   {\Large $\readInst{a}{x};$};
      \node at (leftSecondInst)  {\Large $\writeInst{y}{1};$};
      \node at (rightFirstInst)  {\Large $\readInst{b}{y};$};
      \node at (rightSecondInst) {\Large $\writeInst{x}{1};$};

      \draw[-,ultra thick] ($(instMiddle) + (-0.1,0.5)$) -- ($(instMiddle) + (-0.1,-0.5-0.8)$);
      \draw[-,ultra thick] ($(instMiddle) + ( 0.1,0.5)$) -- ($(instMiddle) + ( 0.1,-0.5-0.8)$);
      
      \onslide<\noWeakFr>
        { \draw[fill=red!30,rounded corners=3pt]
            ($(middleBuffer) + (-5.4, -1.0)$) rectangle
            ($(middleBuffer) + ( 5.4, -2.0)$);
          \node at ($(middleBuffer) + (0, -1.5)$)
          { \huge Невозможно получить $a = b = 1$ }; }
    \end{tikzpicture}
  }
}

\phrase{
  \LARGE
  Не-SC исполнения --- {\bf слабые}
  \vfill
  %% \pause
  {\bf Слабые} MM разрешают \\ слабые исполнения 
  \vfill
  %% \pause
  Реальные системы имеют слабые MM \\
  %% \pause
  {\Large (x86, Power, ARM, C++, Java)}
}

%% \phrase{
%%   Почему системы имеют слабые MM?
%% }

\begin{frame}<3>{\huge Процессоры и компиляторы \newline {\bf оптимизируют} программы}
  \setorder{{firstFr, listFr}, {correctFr, oneThreadFr}, {weakFr}}
  \LARGE
  
  \uncover<\listFr->{
    \ite{
    \large
      \item переупорядочивание инструкций \tikzmark{reorder}
      \item кэш
      \item буфера
      \item удаление чтения после записи 
      \item спекулятивное исполнение \tikzmark{fakeelim}
      %% \item удаление антизависимости 
      \item {\Huge \dots} \tikzmark{dots}
    }
  }

  \vfill
  
  \onslide<\weakFr->{
    Приводит к слабым исполнениям
  }
  
  \onslide<\correctFr>{
    \tikz[remember picture, overlay]{
      \draw [decorate,decoration={brace,amplitude=10pt},xshift=-4pt,yshift=0pt,thick]
            let \p1 = (reorder) in
            let \p2 = (dots) in
            let \p3 = (reorder) in
            (\x3, \y1) -- (\x3, \y2)
            node [anchor=west,black,midway,xshift=0.4cm] {\Large Корректны};
    }
  }

  \onslide<\oneThreadFr->{
    \tikz[remember picture, overlay]{
      \draw [decorate,decoration={brace,amplitude=10pt},xshift=-4pt,yshift=0pt,thick]
            let \p1 = (reorder) in
            let \p2 = (dots) in
            let \p3 = (reorder) in
            (\x3, \y1) -- (\x3, \y2)
            node [anchor=west,black,midway,xshift=0.4cm] (test) {\Large Корректны};
      \node [anchor=west,below of=test, node distance=0.45cm,xshift=0.1cm] {\Large для {\bf одного}};
      \node [anchor=west,below of=test, node distance=0.9cm,xshift=-0.5cm] {\Large потока};
    }
  }
\end{frame}

%% \fr{}{
%% \LARGE
%% $$\begin{array}{c}
%% \uncover<7->{\hspace{12pt} [x] := 0; [y] := 0} \\
%% \begin{array}{l||l}
%% \only<-10,13->{\inarr{
%%   \tikzmark{reorder1} {} [x] := 1;  \\
%%   \tikzmark{reorder2} a := [y]
%% }}
%% \only<11-12>{\inarr{
%%   a := [y]; \\
%%   {} [x] := 1
%% }}
%% \uncover<7->{& \inarr{
%%   {} [y] := 1; \\
%%   b := [x]
%% }}
%% \end{array}\end{array}$$

%% \mycallout<2>{green}{(reorder1)}{(-0.5cm, -0.5cm)}{{\bf Компилятор:} \\ Независимые обращения. \\ Можно переупорядочить.}
%% \mycallout<3>{blue}{(reorder2)}{(-0.5cm, 1.0cm)}{{\bf Процессор:} \\ Независимые обращения. \\ Можно выполнить не по порядку.}

%% \dimalert<5>{Всегда ли корректны такие преобразования?}

%% \only<8-11>{\cntrd{\textcolor{red}{a = b = 0}}}

%% \dimalert<9>{А если переупорядочить?}

%% \only<12->{\cntrd{\textcolor{darkGreen}{a = b = 0}}}
%% \only<14->{\cntrd{\bf \alert{Такое поведение наблюдается для GCC + x86!}}}

%%     \tikz[remember picture, overlay]{ \draw<10,13->[<->,ultra thick] (reorder2) to[out=178,in=182] (reorder1); }
%% }

%% \fr{}{
%%   \huge
%%   Подобные поведения называются {\bf слабыми}\pause,
%%   а семантики --- {\bf слабыми моделями памяти}
%% }

%% \fr{}{

%%   Модели памяти процессоров
%%   \uncover<2->{
%%     \ite{
%%     \item \toGray{7}{8}{x86, \cite{Owens-al:TPHOL09}} \tikzmark{x86}
%%     \item \toGray{7}{8}{Power, \cite{Alglave-al:TOPLAS14}} \tikzmark{Power}
%%     \item ARM,\tikzmark{ARM} \cite{Flur-al:POPL16}
%%     \item ...
%%     }
%%   }
%%   \vfill

%%   Модели памяти ЯП
%%   \uncover<3->{
%%     \ite{
%%     %% \item \toGray{4}{5}{Последовательная консистентность, \cite{Lamport:TC79}}
%%     \item \toGray{4}{5}{C/C++11, \cite{Batty-al:POPL11}}
%%     \item \toGray{4}{5}{Java\tikzmark{jmm}, \cite{Manson-al:POPL05}}
%%     \uncover<5->{ \item Обещающая\tikzmark{Promise} семантика, \cite{Kang-al:POPL17} }
%%     }

%%     \mycallout<4>{red}{(jmm)}{(-2.0cm, 0.5cm)}{Имеют ряд существенных недостатков}
%%   }

%%   %% \uncover<6>{%
%%     \tikz[remember picture, overlay]{
%%       \draw<6-8>[-,ultra thick]
%%         let \p1 = (x86) in
%%         let \p2 = (Power) in
%%         (\x2, \y1) -- (\x2 ++ 0.5cm, \y1) --
%%         (\x2 ++ 0.5cm, \y2) -- (\x2, \y2);

%%         \node<7-8>[above right = -0.8cm and 1.0cm of x86, align=left, fill=green!20, rounded corners, draw,rectangle] (e) 
%%           {Корректность компиляции \\ показана в \cite{Kang-al:POPL17}};
%%         \node<8>[below right = 0.8cm and 1.0cm of x86, align=left, fill=red!20, rounded corners, draw,rectangle] (f) 
%%           {Та же схема доказательства \\ не подходит для ARM!};
%%         \draw<9>[->,red,ultra thick] (Promise) to[out=30,in=-30] (ARM);
%%     }
%%   %% }
%% }
\phrase{
  Модель памяти для ЯП \\
  должна соответствовать \\ \textbf{3} критериям
}

\begin{frame}<6>{\huge 1. Эффективная компиляция}
  \setorder{{firstFr},{programFr}, {scmmFr}, {powermmFr}, {compiledFr}, {noteffFr}}
  %% \LARGE
  %% {\bf Ex.} SC MM requires fences

  \cntrd{
    \begin{tikzpicture}
      \node (leftFirstInst)   {};
      \node (leftSecondInst)  [below of= leftFirstInst, node distance = 0.8cm] {};
      \node (leftThirdInst)   [below of= leftSecondInst, node distance = 0.8cm] {};
      \node (rightFirstInst)  [right of=  leftFirstInst, node distance = 3.0cm] {};
      \node (rightSecondInst) [below of= rightFirstInst, node distance = 0.8cm] {};
      \node (rightThirdInst)  [below of= rightSecondInst, node distance = 0.8cm] {};

      \node (instMiddle)   at ($.5*(leftFirstInst) + .5*(rightFirstInst)$) {};
      
      \uncover<\programFr->{
        \node at (leftFirstInst)   {\Large $\readInst{a}{x};$};
        \node at (leftSecondInst)  {\Large $\writeInst{y}{1};$};
        \node at (rightFirstInst)  {\Large $\readInst{b}{y};$};
        \node at (rightSecondInst) {\Large $\writeInst{x}{1};$};

        \draw[-,ultra thick] ($(instMiddle) + (-0.1,0.5)$) -- ($(instMiddle) + (-0.1,-0.5-0.8)$);
        \draw[-,ultra thick] ($(instMiddle) + ( 0.1,0.5)$) -- ($(instMiddle) + ( 0.1,-0.5-0.8)$);
      }
      
      \uncover<\scmmFr->{
        \node[anchor=west] at
          ($.5*(leftFirstInst) + .5*(leftSecondInst) + (-7.0, 0.0)$) {\large Исходная модель (SC MM)};
      }

      \node (leftFirstInstC)   [below of= leftFirstInst, node distance = 4cm] {};
      \node (leftSecondInstC)  [below of= leftFirstInstC, node distance = 0.8cm] {};
      \node (leftThirdInstC)   [below of= leftSecondInstC, node distance = 0.8cm] {};
      \node (rightFirstInstC)  [right of=  leftFirstInstC, node distance = 3.0cm] {};
      \node (rightSecondInstC) [below of= rightFirstInstC, node distance = 0.8cm] {};
      \node (rightThirdInstC)  [below of= rightSecondInstC, node distance = 0.8cm] {};

      \node (instMiddleC)   at ($.5*(leftFirstInstC) + .5*(rightFirstInstC)$) {};
      
      \uncover<\compiledFr->{
        \node at (leftFirstInstC)   {\Large $\readInst{a}{x};$};
        \node at (leftSecondInstC)  {\Large ${\rm lwsync};$};
        \node at (leftThirdInstC)  {\Large $\writeInst{y}{1};$};
        \node at (rightFirstInstC)  {\Large $\readInst{b}{y};$};
        \node at (rightSecondInstC) {\Large ${\rm lwsync};$};
        \node at (rightThirdInstC) {\Large $\writeInst{x}{1};$};

        \draw[-,ultra thick] ($(instMiddleC) + (-0.1,0.5)$) -- ($(instMiddleC) + (-0.1,-0.5-1.6)$);
        \draw[-,ultra thick] ($(instMiddleC) + ( 0.1,0.5)$) -- ($(instMiddleC) + ( 0.1,-0.5-1.6)$);
      }

      \node<\powermmFr->[anchor=west] at ($(leftSecondInstC) + (-7.0, 0.0)$) {\large Целевая модель (Power MM)};

      \draw<\compiledFr->[->,thick] ($(instMiddle) + (0.0,-1.5)$) -- ($(instMiddleC) + (0.0,1.0)$);
      \node<\noteffFr->[anchor=east] at ($.5*(instMiddle) + .5*(instMiddleC) + (0.0,-0.2)$)
        {\Large \bf \textcolor{darkRed}{Не эффективно!}};
    \end{tikzpicture}
  }
\end{frame}

\begin{frame}<8>{\huge 2. Компиляторные оптимизации}
  \setorder{{firstFr},{programFr}, {scmmFr}, {powermmFr, compiledFr}, {behFr}}

  \cntrd{
    \begin{tikzpicture}
      \node (leftFirstInst)   {};
      \node (leftSecondInst)  [below of= leftFirstInst, node distance = 0.8cm] {};
      \node (leftThirdInst)   [below of= leftSecondInst, node distance = 0.8cm] {};
      \node (rightFirstInst)  [right of=  leftFirstInst, node distance = 3.0cm] {};
      \node (rightSecondInst) [below of= rightFirstInst, node distance = 0.8cm] {};
      \node (rightThirdInst)  [below of= rightSecondInst, node distance = 0.8cm] {};

      \node (instMiddle)   at ($.5*(leftFirstInst) + .5*(rightFirstInst)$) {};
      
      \uncover<\programFr->{
        \node at (leftFirstInst)   {\Large $\readInst{a}{x};$};
        \node at (leftSecondInst)  {\Large $\writeInst{y}{1};$};
        \node at (rightFirstInst)  {\Large $\readInst{b}{y};$};
        \node at (rightSecondInst) {\Large $\writeInst{x}{1};$};

        \draw[-,ultra thick] ($(instMiddle) + (-0.1,0.5)$) -- ($(instMiddle) + (-0.1,-0.5-0.8)$);
        \draw[-,ultra thick] ($(instMiddle) + ( 0.1,0.5)$) -- ($(instMiddle) + ( 0.1,-0.5-0.8)$);
      }
      
      \uncover<\scmmFr->{
        \node[anchor=west] at
          ($.5*(leftFirstInst) + .5*(leftSecondInst) + (-7.0, 0.0)$) {\large Исходная};
      }

      \node (leftFirstInstC)   [below of= leftFirstInst, node distance = 4cm] {};
      \node (leftSecondInstC)  [below of= leftFirstInstC, node distance = 0.8cm] {};
      \node (leftThirdInstC)   [below of= leftSecondInstC, node distance = 0.8cm] {};
      \node (rightFirstInstC)  [right of=  leftFirstInstC, node distance = 3.0cm] {};
      \node (rightSecondInstC) [below of= rightFirstInstC, node distance = 0.8cm] {};
      \node (rightThirdInstC)  [below of= rightSecondInstC, node distance = 0.8cm] {};

      \node (instMiddleC)   at ($.5*(leftFirstInstC) + .5*(rightFirstInstC)$) {};
      
      \uncover<\compiledFr->{
        \node at (leftFirstInstC)   {\Large $\writeInst{y}{1};$};
        \node at (leftSecondInstC)  {\Large $\readInst{a}{x};$};
        \node at (rightFirstInstC)  {\Large $\readInst{b}{y};$};
        \node at (rightSecondInstC) {\Large $\writeInst{x}{1};$};

        \draw[-,ultra thick] ($(instMiddleC) + (-0.1,0.5)$) -- ($(instMiddleC) + (-0.1,-0.5-0.8)$);
        \draw[-,ultra thick] ($(instMiddleC) + ( 0.1,0.5)$) -- ($(instMiddleC) + ( 0.1,-0.5-0.8)$);
      }

      \uncover<\powermmFr->{
        \node[anchor=west] at
          ($.5*(leftFirstInstC) + .5*(leftSecondInstC) + (-7.0, 0.0)$) {\large Оптимизированная};
      }
      
      \uncover<\behFr->{
        \draw [thick] ($(leftFirstInst) + (-0.9, 0.5)$)
          to [square right brace] ($(leftSecondInst) + (-0.9, -0.5)$);
        \draw [thick] ($(leftFirstInst) + (-0.9-0.15, 0.5)$)
          to [square right brace] ($(leftSecondInst) + (-0.9-0.15, -0.5)$);
        \draw [thick] ($(rightFirstInst) + (0.9, 0.5)$)
          to [square left brace] ($(rightSecondInst) + (0.9, -0.5)$);
        \draw [thick] ($(rightFirstInst) + (0.9+0.15, 0.5)$)
          to [square left brace] ($(rightSecondInst) + (0.9+0.15, -0.5)$);

        \draw [thick] ($(leftFirstInstC) + (-0.9, 0.5)$)
          to [square right brace] ($(leftSecondInstC) + (-0.9, -0.5)$);
        \draw [thick] ($(leftFirstInstC) + (-0.9-0.15, 0.5)$)
          to [square right brace] ($(leftSecondInstC) + (-0.9-0.15, -0.5)$);
        \draw [thick] ($(rightFirstInstC) + (0.9, 0.5)$)
          to [square left brace] ($(rightSecondInstC) + (0.9, -0.5)$);
        \draw [thick] ($(rightFirstInstC) + (0.9+0.15, 0.5)$)
          to [square left brace] ($(rightSecondInstC) + (0.9+0.15, -0.5)$);
      }

      \node<\behFr->[rotate=90] at ($.5*(instMiddle) + .5*(instMiddleC) + (0.0,-0.5)$) {\Huge $\subseteq$};
      %% \node<\noteffFr->[anchor=east] at ($.5*(instMiddle) + .5*(instMiddleC) + (0.0,-0.2)$)
      %%   {\Large \bf \textcolor{darkRed}{Not efficient}};
    \end{tikzpicture}
  }
\end{frame}

\begin{frame}<2->{\huge 3. Отсутствие ``значений из воздуха''}
  \setorder{{firstFr}, {programFr}, {ootaFr}}

  \cntrd{
    \begin{tikzpicture}
      \node (leftFirstInst)   {};
      \node (leftSecondInst)  [below of= leftFirstInst, node distance = 0.8cm] {};
      \node (leftThirdInst)   [below of= leftSecondInst, node distance = 0.8cm] {};
      \node (rightFirstInst)  [right of=  leftFirstInst, node distance = 3.0cm] {};
      \node (rightSecondInst) [below of= rightFirstInst, node distance = 0.8cm] {};
      \node (rightThirdInst)  [below of= rightSecondInst, node distance = 0.8cm] {};

      \node (instMiddle)   at ($.5*(leftFirstInst) + .5*(rightFirstInst)$) {};
      
      \uncover<\programFr->{
        \node at (leftFirstInst)   {\Large $\readInst{a}{x};$};
        \node at (leftSecondInst)  {\Large $\writeInst{y}{a};$};
        \node at (rightFirstInst)  {\Large $\readInst{b}{y};$};
        \node at (rightSecondInst) {\Large $\writeInst{x}{b};$};

        \draw[-,ultra thick] ($(instMiddle) + (-0.1,0.5)$) -- ($(instMiddle) + (-0.1,-0.5-0.8)$);
        \draw[-,ultra thick] ($(instMiddle) + ( 0.1,0.5)$) -- ($(instMiddle) + ( 0.1,-0.5-0.8)$);
      }

      \onslide<\ootaFr>
        { \draw[fill=red!30,rounded corners=3pt]
            ($(instMiddle) + (-5.4, -3.0)$) rectangle
            ($(instMiddle) + ( 5.4, -4.0)$);
          \node at ($(instMiddle) + (0, -3.5)$)
          { \huge C/C++11 разрешает $a = b = 8$ }; }
    \end{tikzpicture}
  }
\end{frame}

\begin{frame}<6-7>{\huge MM для языков программирования}
  \setorder{{firstFr},{reqFr},{appearFr},
            {notionEffImplFr, effImplFr},
            {notionComplOptFr, complOptFr},
            {notionHighLevelFr, ootaFr, highLevelFr},
            {ootaCppFr},
            {notionUndefBehFr}, {undefBehFr},
            {promiseFr},{complCorFr}}

  %% \large

  \uncover<\appearFr->{
  \begin{tabular}{@{}l l | l | l | l}
    \uncover<\effImplFr->{& {\bf ЭК}}   \uncover<\complOptFr->{& {\bf КО}}
    \uncover<\highLevelFr->{& Нет {\bf ЗВ}} \uncover<\undefBehFr->{& No {\bf UB}} \\
    %% \tabitem
    SC MM, \cite{Lamport:TC79}
      \uncover<\effImplFr->{& \fail}   \uncover<\complOptFr->{& \fail}
      \uncover<\highLevelFr->{& \tick} \uncover<\undefBehFr->{& \tick} \\
    %% \tabitem
    Java MM\tikzmark{jmm}, \cite{Manson-al:POPL05} \tikzmark{java}
      \uncover<\effImplFr->{& \tick}   \uncover<\complOptFr->{& \fail}
      \uncover<\highLevelFr->{& \tick} \uncover<\undefBehFr->{& \tick} \\
    %% \tabitem
    C/C++11 MM, \cite{Batty-al:POPL11} \tikzmark{cpp}
      \uncover<\effImplFr->{& \tick}   \uncover<\complOptFr->{& \tick$^{*}$}
      \uncover<\highLevelFr->{& \fail\tikzmark{ootaCppMark}} \uncover<\undefBehFr->{& \fail} \\
    \\
    \uncover<\promiseFr->{%
      %% \tabitem
      Proposed solution \cite{Kang-al:POPL17}\tikzmark{Promise}
      \uncover<\effImplFr->{& \tick\tikzmark{effImplMark}}   \uncover<\complOptFr->{& \tick}
      \uncover<\highLevelFr->{& \tick} \uncover<\undefBehFr->{& \tick} \\
        $\quad ~~~\; \Promise$ MM, for C/C++ and Java
    } \\
  \end{tabular}
  }
  %% \vfill
  
  \uncover<\reqFr->{
  Требования:
  \ite{
    \item возможность {\bf Э}ффективной {\bf К}омпиляции \\ (x86, Power, ARM)
    \item разрешение {\bf К}омпиляторных {\bf О}птимизаций
    \item отсутствие {\bf З}начений из {\bf В}оздуха
    %% \uncover<\notionUndefBehFr-> {\item avoid {\bf U}ndefined {\bf B}ehavior}
  }
  }


  \addtooverlay<\ootaCppFr>{%
    \draw[ultra thick, rounded corners=3pt] ($(ootaCppMark) + (-0.35,-0.25)$) rectangle ++(0.5,0.55);
  }
  %% \addtooverlay<\complCorFr>{%
  %%   \draw[colorPROM, ultra thick, rounded corners=3pt] ($(effImplMark) + (-0.45,-0.3)$) rectangle ++(0.6,0.6);
  %% }

 %%  \mycallout<\ootaFr>{yellow}{(oota)}{(-1.0cm, -1.0cm)}{
 %%    $\comment{Out\text{-}Of\text{-}Thin\text{-}Air}$ \\
 %%    $\begin{array}{l || l}
 %%    a := [x]; \comment{8} & b := [y]; \comment{8} \\
 %% {} [y] := a; & [x] := b; \\
 %%    \end{array}$
 %%  }
\end{frame}

\phrase{C/C++11 MM --- {\bf аксиоматическая} MM}

\begin{frame}<4->{\huge Исполнение в C/C++11 MM}
  \setorder{{firstFr}, {lbHighlightFr}, {bigLBFr}, {axiomsFr}, {removeValueFr}, {randomValueFr}}
  \prevFr{\befBigLBFr}{\bigLBFr}
  \prevFr{\befRemoveValueFr}{\removeValueFr}
  \prevFr{\befRandomValueFr}{\randomValueFr}

  \cntrd{
    \vspace{-1.5cm}
    \begin{tikzpicture}[every node/.style={transform shape}]
      \node (leftFirstInst)   {};
      \node (leftSecondInst)  [below of= leftFirstInst, node distance = 0.8cm] {};
      \node (rightFirstInst)  [right of= leftFirstInst, node distance = 3.0cm] {};
      \node (rightSecondInst) [below of=rightFirstInst, node distance = 0.8cm] {};

      \node (instMiddle)   at ($.5*(leftFirstInst) + .5*(rightFirstInst)$) {};
      \node (leftBuffer)   at (leftSecondInst)  {};
      \node (rightBuffer)  at (rightSecondInst) {};
      \node (middleBuffer) at ($.5*(leftBuffer) + .5*(rightBuffer)$) {};
      \node (finalValues)  at ($(middleBuffer) + (0, -4.5)$) {};
      
      %% \node (ptrLeft)  at ($.5*(rightFirstInst) + .5*(rightSecondInst) + (1.5, 0)$) {};
      %% \node (ptrRight) at ($(ptrLeft) + (1.0, 0)$) {};
      \node (ptrLeft)  at ($(instMiddle) + (0.0, -1.7)$) {};
      \node (ptrRight) at ($(ptrLeft) + (0.0, -1.5)$) {};

      %% \node (leftCurlyCenter)  at ($(ptrRight) + (1.0, 0)$) {};
      \node (leftCurlyCenter)  at ($(leftSecondInst) +  (-3.25, -4.0)$) {};
      \node (rightCurlyCenter) at ($(rightSecondInst) + ( 3.25, -4.0)$) {};
      
      \node (curlyTopShift) at (0, -1.5) {};
      \node (curlyBotShift) at (0,  1.5) {};
      \node (leftCurlyTop)  at ($(leftCurlyCenter)  + (curlyTopShift)$) {};
      \node (rightCurlyTop) at ($(rightCurlyCenter) + (curlyTopShift)$) {};

      \node (leftCurlyBot)  at ($(leftCurlyCenter)  + (curlyBotShift)$) {};
      \node (rightCurlyBot) at ($(rightCurlyCenter) + (curlyBotShift)$) {};
      
      \node at (leftFirstInst)   {\Large $\readInst{a}{x};$};
      \node<-\befRemoveValueFr> at (leftSecondInst)  {\Large $\writeInst{y}{1};$};
      \node<\removeValueFr->    at (leftSecondInst)  {\Large $\writeInst{y}{a};$};
      \node at (rightFirstInst)  {\Large $\readInst{b}{y};$};
      \node<-\befRemoveValueFr> at (rightSecondInst) {\Large $\writeInst{x}{1};$};
      \node<\removeValueFr->    at (rightSecondInst) {\Large $\writeInst{x}{b};$};

      \draw[-,thick] ($(instMiddle) + (-0.1,0.5)$) -- ($(instMiddle) + (-0.1,-0.5-0.8)$);
      \draw[-,thick] ($(instMiddle) + ( 0.1,0.5)$) -- ($(instMiddle) + ( 0.1,-0.5-0.8)$);
      
  \uncover<-\befBigLBFr>{
      \draw[->, ultra thick] (ptrLeft) -- (ptrRight);
      \draw [decorate,decoration={brace,amplitude=10pt,raise=4pt},yshift=0pt,thick]
        (leftCurlyTop) -- (leftCurlyBot) node [black,midway,xshift=-0.8cm] {};
      \draw [decorate,decoration={brace,amplitude=10pt,mirror,raise=4pt},yshift=0pt,thick]
        (rightCurlyTop) -- (rightCurlyBot) node [black,midway,xshift=0.8cm] {};

  \node (aGraphCenter) at ($(leftCurlyCenter) + (1.0, 0.0)$) {};
  \node (a1)  at ($(aGraphCenter) + (-0.5, 0.5)$) {$\rlab{}{x}{0}$ };
  \node (a2)  at ($(a1)  + (0, -1)$)  {$\wlab{}{y}{1}$ };
  \node (a11) at ($(a1)  + (1,  0)$)  {$\rlab{}{y}{0}$ };
  \node (a12) at ($(a11) + (0, -1)$)  {$\wlab{}{x}{1}$ };
  \draw[po] (a1)  edge  (a2);
  \draw[po] (a11) edge (a12);
  \draw[fr] (a11)  edge node[below] {\small $\lFR$} (a2);
  \draw[fr] (a1)  edge node[below] {} (a12);
  %% \draw[fr,bend right=30] (12) edge node[below] {\small $\lFR$} (1);

  \node at ($(aGraphCenter) + (1.1, -0.3)$) {\Huge ,};

  \node (bGraphCenter) at ($(aGraphCenter) + (2.5, 0.0)$) {};
  \node (b1)  at ($(bGraphCenter) + (-0.5, 0.5)$) {$\rlab{}{x}{0}$ };
  \node (b2)  at ($(b1)  + (0, -1)$)  {$\wlab{}{y}{1}$ };
  \node (b11) at ($(b1)  + (1,  0)$)  {$\rlab{}{y}{1}$ };
  \node (b12) at ($(b11) + (0, -1)$)  {$\wlab{}{x}{1}$ };
  \draw[po] (b1)  edge  (b2);
  \draw[po] (b11) edge (b12);
  \draw[fr] (b1)  edge node[below] {\small $\lFR$} (b12);
  \draw[rf] (b2)  edge node[above] {\small $\lRF$} (b11);

  \node at ($(bGraphCenter) + (1.1, -0.3)$) {\Huge ,};

  \node (cGraphCenter) at ($(bGraphCenter) + (2.5, 0.0)$) {};
  \node (c1)  at ($(cGraphCenter) + (-0.5, 0.5)$) {$\rlab{}{x}{1}$ };
  \node (c2)  at ($(c1)  + (0, -1)$)  {$\wlab{}{y}{1}$ };
  \node (c11) at ($(c1)  + (1,  0)$)  {$\rlab{}{y}{0}$ };
  \node (c12) at ($(c11) + (0, -1)$)  {$\wlab{}{x}{1}$ };
  \draw[po] (c1)  edge  (c2);
  \draw[po] (c11) edge (c12);
  \draw[fr] (c11) edge node[below] {\small $\lFR$} (c2);
  \draw[rf] (c12) edge node[above] {\small $\lRF$} (c1);

  \node at ($(cGraphCenter) + (1.1, -0.3)$) {\Huge ,};
  

  \node (dGraphCenter) at ($(cGraphCenter) + (2.5, 0.0)$) {};
  \draw<\lbHighlightFr>[colorPROM, ultra thick, rounded corners=3pt] ($(dGraphCenter) + (-1.0,-1.0)$) rectangle ++(2.0,2.0);

  \node (d1)  at ($(dGraphCenter) + (-0.5, 0.5)$) {$\rlab{}{x}{1}$ };
  \node (d2)  at ($(d1)  + (0, -1)$)  {$\wlab{}{y}{1}$ };
  \node (d11) at ($(d1)  + (1,  0)$)  {$\rlab{}{y}{1}$ };
  \node (d12) at ($(d11) + (0, -1)$)  {$\wlab{}{x}{1}$ };
  \draw[po] (d1)  edge (d2);
  \draw[po] (d11) edge (d12);
  \draw[rf] (d2)  edge node[below] {\small $\lRF$} (d11);
  \draw[rf] (d12) edge node[below] {} (d1);
  }
  

  \uncover<\bigLBFr->{
  \node at ($(ptrRight) + (1.9, -1.0)$) {
    \begin{tikzpicture}[scale=2.0,every node/.style={transform shape}]
  \node (dGraphCenter) at ($(0.0, 0.0)$) {};
  
  \uncover<-\befRandomValueFr>{
    \node (d1)  at ($(dGraphCenter) + (-0.5, 0.5)$) {$\rlab{}{x}{1}$ };
    \node (d2)  at ($(d1)  + (0, -1)$)  {$\wlab{}{y}{1}$ };
    \node (d11) at ($(d1)  + (1,  0)$)  {$\rlab{}{y}{1}$ };
    \node (d12) at ($(d11) + (0, -1)$)  {$\wlab{}{x}{1}$ };
  }

  \uncover<\randomValueFr->{
    \node (d1)  at ($(dGraphCenter) + (-0.5, 0.5)$) {$\rlab{}{x}{8}$ };
    \node (d2)  at ($(d1)  + (0, -1)$)  {$\wlab{}{y}{8}$ };
    \node (d11) at ($(d1)  + (1,  0)$)  {$\rlab{}{y}{8}$ };
    \node (d12) at ($(d11) + (0, -1)$)  {$\wlab{}{x}{8}$ };
  }
  \draw[po, ultra thick] (d1)  edge node[left]  {\small $\lPO$} (d2);
  \draw[po, ultra thick] (d11) edge node[right] {\small $\lPO$} (d12);
  \draw[rf, ultra thick] (d2)  edge node[below] {\small $\lRF$} (d11);
  \draw[rf, ultra thick] (d12) edge node[below] {} (d1);
    \end{tikzpicture}
    };
  }
    
  \uncover<\axiomsFr->{
  \node[anchor=west] at ($(ptrRight) + (-5.5,  0.0)$)
    {\LARGE Аксиомы:};
  \node[anchor=west] at ($(ptrRight) + (-5.5, -1.0)$)
    {\LARGE 1. $\lPO|_{\mathtt{loc}} \cup \lRF$};
  \node[anchor=west] at ($(ptrRight) + (-4.8, -2.0)$)
    {\LARGE ациклично};
  \node[anchor=west] at ($(ptrRight) + (-5.5, -3.0)$)
    {\LARGE \dots};
  }

    \end{tikzpicture}
  }
\end{frame}



\begin{frame}{\huge Постановка задачи}
   \setorder{{opCppFr},{promiseFr},{armPOPSectionFr},{armAxSectionFr}}
\begin{itemize}
  \large

  \uncover<\opCppFr->{
  \item Разработать операционную модель памяти С/С++11, свободную от проблемы ``значений из воздуха''.
  }
  \vfill

    \only<\promiseFr>{
      \begin{block}{Обещающая семантика \cite{Kang-al:POPL17}}
        %% \cntrd{  }
        %% \uncover<\promisePropertiesFr->{
          \begin{itemize}
            \item Операционная
            \item Доказана корректность компиляции в MM x86 и Power
            \item Разрешает оптимизации
            \item Не имеет ``значений из воздуха''
            %% \uncover<\promisePerspectiveFr->{
              \item Может стать частью стандартов C/C++ и Java
            %% }
            %% \uncover<\promiseARMHoleFr->{
              %% \vfill 
              \item \alert{Нет доказательства корректности компиляции в MM ARM}!
            %% }
          \end{itemize}
        
      \end{block}
    }

  \uncover<\armPOPSectionFr->{
  \item Доказать корректность эффективной схемы компиляции из существенного подмножества обещающей модели (ККОМ) в операционную модель памяти ARMv8 POP.
  }

  \only<\armPOPSectionFr>{
\begin{block}{Корректность компиляции}
  $compile : S \rightarrow T$\\
  $\forall Prog \in S.$ \\
  $\quad \semState{compile(Prog)}{T}$
  $\subseteq$
  $\semState{Prog}{S}$.
\end{block}
}

  \vfill
  \uncover<\armAxSectionFr->{
  \item Доказать ККОМ в аксиоматическую модель памяти ARMv8.3.
  }
\end{itemize}
\end{frame}

%% \fr{\huge Постановка задачи}{
%% \Large
%% \begin{block}{Проблема}
%%   Не существует MM промышленного ЯП, удовлетворяющей основным критериям
%% \end{block}
%% \pause
%% \begin{block}{Цель}
%%   Разработать операционный аналог C/C++11 MM без значений из воздуха, \\ удовлетворяющий основным критериям
%% \end{block}
%% }

%% \section{Описание результатов}

\begin{frame}<8>[label=resultsFrame]{\huge Результаты}
  \setorder{{firstFr},{opCppFr},
    {promiseDiscussionFr},{promisePropertiesFr},{promisePerspectiveFr},{promiseARMHoleFr},
    {compilationFr},{compilationAxFr},
    {opCppSectionFr},{armPOPSectionFr},{armAxSectionFr},{fullResultFr},{interpreterLinkFr},{thanksFr}}
  \prevFr{\befCompilationFr}{\compilationFr}
  \nextFr{\nextPromisePropertiesFr}{\promisePropertiesFr}

  \prevFr{\befOpCppSectionFr}{\opCppSectionFr}
  \nextFr{\nextArmAxSectionFr}{\armAxSectionFr}

  \large
  \begin{itemize}
    \uncover<\opCppFr->{\item
      \toShadow
        {-\befOpCppSectionFr,\opCppSectionFr,\nextArmAxSectionFr-}
        {\armPOPSectionFr,\armAxSectionFr}
      {Предложена операционная модель памяти C/С++11, для этой модели реализован интерпретатор.}
    } \\
    \only<\interpreterLinkFr->{ {\scriptsize [Интерпретатор: \url{github.com/anlun/OperationalSemanticsC11}]} }
    \vfill
    
    \only<\promiseDiscussionFr-\promiseARMHoleFr>{
      \begin{block}{Конкурирующая работа}
        \cntrd{ Обещающая семантика \cite{Kang-al:POPL17} }
        \uncover<\promisePropertiesFr->{
          \begin{itemize}
            \item Операционная
            \item Доказана корректность компиляции в MM x86 и Power
            \item Разрешает оптимизации
            \item Не имеет значений из воздуха
            \uncover<\promisePerspectiveFr->{
              \item Может стать частью стандартов C/C++ и Java
            }
            \uncover<\promiseARMHoleFr->{
              \vfill 
              \item \alert{Нет д-ва корректности компиляции в MM ARM}!
            }
          \end{itemize}
        }
      \end{block}
    }
    
    \uncover<\compilationFr->{
      \item 
        \toShadow
          {-\befOpCppSectionFr,\armPOPSectionFr,\nextArmAxSectionFr-}
          {\opCppSectionFr,\armAxSectionFr}
        {Доказана корректность компиляции из существенного подмножества\tikzmark{subset} обещающей модели (ККОМ) в операционную модель памяти \ARMpop.}
    }
    \vfill
    \uncover<\compilationAxFr->{
      %% \item
      %%   \toShadow
      %%     {-\befOpCppSectionFr,\armAxSectionFr,\nextArmAxSectionFr-}
      %%     {\opCppSectionFr,\armPOPSectionFr}
      %%   {Разработан метод доказательства ККОМ в аксиоматические модели}
      %% \vfill
      \item
        \toShadow
          {-\befOpCppSectionFr,\armAxSectionFr,\nextArmAxSectionFr-}
          {\opCppSectionFr,\armPOPSectionFr}
        {Доказана ККОМ в аксиоматическую модель памяти $\ARMax$.}
    }
  \end{itemize}

  %% \mycallout<2>[left]{green}{(subset)}{(-0.5cm, 1.0cm)}{Расслабленные (relaxed) \\ чтения и записи,\\
  %%                                                       высвобождающие (release) и \\
  %%                                                       приобретающие (acquire) \\ барьеры памяти}

  \uncover<\thanksFr->{\cntrd{\huge \textcolor{red}{Спасибо!}}}
\end{frame}

\againframe<9>{resultsFrame}

\fri{\Large Операционная модель \OpCpp}{
  \large
  \item Недетерминированная память \\
        (метки времени, фронты)
  \vfill
  \item Отложенные операции
  \vfill
  \hrule
  \vfill
  \item Поддержаны основные конструкции C/C++11 MM\\
    (relaxed, release, acquire, SC, CAS, consume)
    %% \textcolor{gray!50!white}{(relaxed, release, acquire, SC, fences, CAS)}
  \vfill
  \item Интерпретатор
  \begin{itemize}
    \large
    \item Реализован на Racket с помощью PLT/Redex
    \item \url{github.com/anlun/OperationalSemanticsC11}
  \end{itemize}
  \vfill
  \item Апробирована на 41 тесте из литературы
  \begin{itemize}
    \large
    \item Совпадает с C/C++11 MM на 36 тестах
    \item \tick: 2 теста --- ``значения из воздуха''
    \item \fail: 3 теста --- синтаксическое ограничение
  \end{itemize}
}

\againframe<10>{resultsFrame}

%% \fr{\Huge Корректность компиляции}{
%%   \LARGE

%%   $\onslide<3->{compile :} \tikzmark{proglang}S \onslide<3->{\rightarrow} \tikzmark{hardlang}\onslide<2->{T}$\\
%%   \onslide<4->{
%%   $\onslide<6->{\forall Prog \in S.} \\$
%%   $\onslide<5->{\quad \semState{\onslide<6->{compile(\tikzmark{hardsem}Prog)}}{T}}$
%%   $\onslide<6->{\subseteq}$
%%   $\semState{\onslide<6->{Prog}\tikzmark{progsem}}{S}$.
%%   }

%%   \mycallout<1>{green}{(proglang)}{(0.0cm, 1.0cm)}{Исходный язык}
%%   \mycallout<2>{green}{(hardlang)}{(0.0cm, 1.0cm)}{Целевой язык}

%%   \mycallout<4>{green}{(progsem)}{(0.0cm, 1.0cm)}{Исходная MM}
%%   \mycallout<5>{green}{(hardsem)}{(0.0cm, 1.0cm)}{Целевая MM}
%% }


\fr{\large Структура д-ва корректности компиляции из обещающей модели $\Promise$ в модель \ARMpop}{
  %% \Large
  \iteN{
    \item Вводится инструментированная ограниченная версия модели $\ARMpop$, т.н. $\ARMt$.
    \vfill
    \item Доказывается эквивалентность $\ARMt$ и $\ARMpop$.
    \[\begin{array}{l}
      \forall P. \; \semState{P}{\ARMt} = \semState{P}{\ARMpop}.
    \end{array}\]
    \vfill
    \item Доказывается симуляция $\ARMt$ обещающей моделью. \\
    \vspace{.3cm}
    { \footnotesize
    \textbf{Теорема 1.} $S({\sf init}_{\ARMt}, {\sf init}_{\Promise}) $. \\
    \textbf{Теорема 2.} $\forall arm, arm \to arm', promise, S(arm, promise).$ \\
    $\quad \exists promise', promise \to promise' \land S(arm', promise').$
    }
  }
}

\againframe<11>{resultsFrame}

\fr{\large Структура д-ва корректности компиляции из обещающей модели в аксиоматическую модель \ARMax}{
  \iteN{
    \item Вводится операционная семантика обхода \ARMax-исполнения $G$. \\
    \vspace{.5cm}
    { \footnotesize
    \begin{minipage}[t]{0.5\textwidth}
    \begin{prooftree}
      \Hypo{a \in \nextset(G, C) \cap \coverable(G, C, I)}
      \Infer1{G \vdash \tup{C, I} \travConfigStep \tup{C \cup \{a\}, I}}
    \end{prooftree}
    \end{minipage}
    \begin{minipage}[t]{0.4\textwidth}
    \begin{prooftree}
      \Hypo{w \in \issuable(\tikzmark{issuableMk}G, C, I) \setminus I}
      \Infer1{G \vdash \tup{C, \IssuedSet} \travConfigStep \tup{C, \IssuedSet \cup \{w\}}}
    \end{prooftree}
    \end{minipage}
    }
    \vspace{.3cm}
    \item Доказывается полнота обхода.
    { \footnotesize
    \[\forall P, G. \; G \in \semState{P}{\ARMax} \Rightarrow G \vdash \tup{G.W_{init}, G.W_{init}} \to^{*} \tup{G.E, G.W}.\]
    }
    \item Показывается, что обещающая модель симулирует обход \ARMax-исполнения. \\
    \vspace{.3cm}
    { \footnotesize
    \textbf{Теорема 1.} $S_{G}(\tup{G.W_{init}, G.W_{init}}, {\sf init}_{\Promise}) $. \\
    \textbf{Теорема 2.} $\forall G \vdash \tup{C, I} \to \tup{C', I'}, promise, S_{G}(\tup{C, I}, promise).$ \\
    $\quad \exists promise', promise \to promise' \land S_{G}(\tup{C', I'}, promise').$
    }
  }
}

%% \section{Итоги}

\fri{\Large Новизна результатов}{
\large
  \item Предложенная модель памяти для C/C++11 является запускаемой, что отличает её от обещающей модели.
  \vfill
  \item Доказательство ККОМ в модель $\ARMax$ не опирается на специфические св-ва целевой модели, что
        отличает его от существующих доказательств для моделей x86 и Power.
  \vfill
  \item Доказательства ККОМ в модели $\ARMpop$ и $\ARMax$ являются первыми результатами о компиляции для данных моделей.
  \vfill
  \item Доказательство корректности эффективной компиляции для архитектуры ARM является
  необходимым аргументом в пользу обещающей модели памяти как новой модели памяти для C/C++ и Java.
}

%% \fri{\Large Теоретическая и практическая значимость работы}{
%%   \large
%%   \item Предложен операционный способ представления реалистичной семантики многопоточности с помощью меток времени и фронтов.
%%   \vfill
%%   \item Приводится метод доказательства корректности компиляции из обещающей в аксиоматические модели памяти,
%%   который может быть использован для последующих доказательств.
%%   \vfill
%%   \item Доказательство корректности эффективной компиляции для архитектуры ARM является
%%   необходимым аргументом в пользу обещающей модели памяти как новой модели памяти для C/C++ и Java.
%% }

\fr{\LARGE Публикации}{
  \scriptsize
  
  \begin{block}{\scriptsize ВАК}
    \begin{itemize}
      \item Подкопаев, А. В.
      О корректности компиляции подмножества обещающей модели памяти в аксиоматическую модель ARMv8.3 /
      А.В. Подкопаев, О. Лахав, В. Вафеядис. // НТВ СПбГПУ ИТУ.---2017.---Т.10,№4.---С. 51-69.
      \item Подкопаев, А. В. Обещающая компиляция в ARMv8.3 /
      А. Подкопаев, О. Лахав, В. Вафеядис // Труды ИСП РАН.---2017.---Т.29,№5.---С. 149-164.
    \end{itemize}
  \end{block}

  \begin{block}{\scriptsize SCOPUS и Web of Science}
    \begin{itemize}
      \item Podkopaev, A. Promising compilation to ARMv8 POP / \\
      A. Podkopaev, O. Lahav, V. Vafeiadis //
      ECOOP 17, LIPIcs.---2017.---P. 22:1--22:28.
    \end{itemize}
  \end{block}

  \begin{block}{\scriptsize РИНЦ}
    \begin{itemize}
      \item Подкопаев, А. В. Обещающая компиляция в ARMv8 / \\
      А.В. Подкопаев, О. Лахав, В. Вафеядис //
      Языки программирования и компиляторы. Труды конференции.---2017.---C. 223--226. \\
      \item Podkopaev, A.
      Operational Aspects of C/C++ Concurrency / \\
      A. Podkopaev, I. Sergey, A. Nanevski [Электронный ресурс].---URL:
      \url{http://arxiv.org/abs/1606.01400}.
    \end{itemize}
  \end{block}
}

\againframe<13->{resultsFrame}

\begin{frame}[allowframebreaks]{Ссылки}
\bibliographystyle{apalike}
\scriptsize
\bibliography{main}
\end{frame}

\phrase{Дополнительные слайды}
\input{appendix}

\end{document}

