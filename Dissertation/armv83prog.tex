\chapter{Представление программ}

\section{Помеченная система переходов}
\label{app:comptolts}
%% \begin{figure}[h]
%% \begin{minipage}{0.6\textwidth}
%% $\begin{array}{l @{~} r @{~} l}
%% \Carm    & : & \ListOf{\StmtARM} \\  
%% \StmtARM & ::= & \readInst{\reg}{\expr} \\
%%          & |   & \writeInst{\expr_0}{\expr_1} \\
%%          & |   & \fenceInst{\FtypeProm} \\
%%          & |   & \ifGotoInst{\expr}{\z} \\
%%          & |   & \assignInst{\reg}{\expr} \mid \nop \\
%% \FtypeProm & ::= & \rel \mid \acq\\
%% \expr    & ::= & \val \mid \reg \mid \loc \mid uop \; \expr \\
%%          & |   & bop \; \expr_0 \; \expr_1 \\
%%          %% & :   & \Expr \\
%% \reg : \Reg & - & a, b, c, ...  \quad \; \text{(локальные переменные)} \\
%% \loc : \Loc & - & x, y, z, ... \quad \text{(локации)} \\
%% uop, bop & - & \text{арифметические операции} \\
%% \val, \z       & \in & \mathbb{Z}
%% \end{array}$
%% \captionof{figure}{Синтаксис программ}
%% \label{fig:syn-prog}
%% \end{minipage}
%% %
%% \begin{minipage}{0.4\textwidth}
%% \begin{figure}[h]
%% $\begin{array}{l @{~} r @{~} l}
%%     \Path  & ::= & \ListOf{Label} \\
%%     \Label & ::= & \rlab{}{\loc}{\val} \mid \wlab{}{\loc}{\val} \\ 
%%            & \mid & \flab{\FtypeProm} \mid \epsilon \\
%% \end{array}$
%% \caption{Метки переходов}
%% \captionof{figure}{Метки переходов}
%% \label{fig:lts}
%% \end{figure}
%% \end{minipage}
%% \end{figure}

%% В этом разделе мы (i) опишем синтаксис исходного языка, который используется в нашей работе,
%% приведем алгоритм построения по программе (ii) помеченной системы переходов для обещающей машины
%% и (iii) \ARM-согласованных исполнений, а также предъявим теорему, которая их свяжет.

%% %% \section{Исходный язык}
%% Синтаксис исходного языка представлен на рисунке \ref{fig:syn-prog}.
%% В нашем синтаксисе многопоточная программа является параллельной композицией потоков на верхнем уровне, где
%% код каждого потока есть список инструкций ($\ListOf{\StmtARM}$).
%% Инструкция может быть чтением ($\readInst{\reg}{\expr}$),
%% записью ($\writeInst{\expr_0}{\expr_1}$),
%% барьером памяти ($\fenceInst{\FtypeProm}$), 
%% условным переходом на $\z$ позиций в списке инструкций ($\ifGotoInst{\expr}{\z}$),
%% присваиванием в локальную переменную ($\assignInst{\reg}{\expr}$),
%% пустой операцией ($\nop$).

Первым шагом для построения по программе помеченной системы переходов является
генерация всех возможных \emph{путей} ($\Path$) исполнения, каждый из которых является списком меток:
%% (см. рис. \ref{fig:lts})
\[\begin{array}{l @{~} r @{~} l}
    \Path  & ::= & \ListOf{Label} \\
    \Label & ::= & \rlab{}{\loc}{\val} \mid \wlab{}{\loc}{\val}
           \mid \flab{\FtypeProm} \mid \epsilon \\
\end{array}\]
Далее по множеству путей строится конечный автомат, принимающий упомянутые пути.

Функция построения путей $\cmdsToLbls$ использует вспомогательную функцию $\instToLbl$,
которая принимает список инструкций потока $ilist$, указатель на текущую инструкцию $pos$ и
состояние локальных переменных $st$:
\[
\inarr{
  \cmdsToLbls : \Carm \rightarrow \Pset(\Path) \\
  \cmdsToLbls \; ilist = \instToLbl \; ilist \; 0 \; (\lambda \reg. 0) \\
  \\
  \instToLbl : \Carm \rightarrow \mathbb{N} \rightarrow (\Reg \rightarrow \mathbb{N}) \rightarrow \Pset(\Path) \\
  \instToLbl \; ilist \; pos \; \PromState \defeq \\
  \quad \textIf   pos < 0 \; || \; pos > length(ilist) \; \textThen \{ [] \} \\
  \quad \textElse \\
  \qquad \kw{match} \; ilist[pos] \; \kw{with} \\
  \qquad
    \begin{array}{@{}l}
    | ``\nop" \rightarrow \instToLbl \; ilist \; (pos + 1) \; \PromState \\
    | ``\readInst{\reg}{\expr}" \rightarrow \\
      \quad \{ \rlab{}{\semState{\expr}{\PromState}}{\val} : l \mid
      \forall \val \in \Val, l \in \instToLbl \; ilist \; (pos + 1) \; \PromState[\reg \mapsto \val] \} \\
    | ``\assignInst{\reg}{\expr}" \rightarrow
                 \instToLbl \; (pos + 1) \; \PromState[\reg \mapsto \semState{\expr}{\PromState}] \\
    | ``\writeInst{\expr_0}{\expr_1}" \rightarrow \\
      \quad \{ \wlab{}{\semState{\expr_0}{\PromState}}{\semState{\expr_1}{\PromState}} : l \mid
      \forall l \in \instToLbl \; ilist \; (pos + 1) \; \PromState \} \\
    | ``\fenceInst{\FtypeProm}" \rightarrow
      \{ \flab{\FtypeProm} : l \mid \forall l \in \instToLbl \; ilist \; (pos + 1) \; \PromState \} \\
    | ``\ifGotoInst{\expr}{k}" \rightarrow
      \letdef{step}{\textIf \semState{\expr}{\PromState} \; \textThen k \; \textElse 1} \\
      \quad \instToLbl \; (pos + step) \; \PromState \\
  \end{array} \\
}
\]

Важно отметить, что каждый поток (в обещающей машине) имеет свою систему переходов, которая
представляет программу этого потока и, соответственно, строится с помощью функции $\cmdsToLbls$.

\section{Предзапуски}
\label{app:comptopreexec}

Для построения по программе \ARM-согласованных исполнений стандартно
используется следующая схема \cite{Vafeiadis-Narayan:OOPSLA13}.
В начале по программе строятся \emph{предзапуски} --- графы исполнений, в которых определена
только часть нужных отношений между событиями, а именно отношения порядка $\lPO$ и зависимостей
по данным $\lDATA$, управлению $\lCTRL$ и адресу $\lADDR$.
\[
\inarr{
  \PreExecutions \defeq \Pset(\langle set : \Pset(E), \lab : set \rightharpoonup \Label, \\
   \quad \lPO : \Pset(set \times set), \lCTRL : \Pset(set \times set),
         \lADDR : \Pset(set \times set), \lDATA : \Pset(set \times set) \rangle) \\
     %% , \state : \Reg \rightarrow \Val, \dep : \Pset(\Reg \times E)}) \\
}\]
При этом для каждой инструкции чтения
генерируется столько вариантов соответствующего события, сколько существует возможных значений
соответствующего типа данных.
Далее для каждого предзапуска недетерменированно выбираются отношения $\lCO$ и $\lRF$
таким образом, чтобы получалось \ARM-согласованное исполнение. Важно отменить, что не для всех предзапусков
существуют подходящие $\lCO$ и $\lRF$.

Функция построения предзапусков по списку команд потока $\cmdsToVrtxs$ использует вспомогательную функцию $\instToVrtx$,
которая принимает список инструкций потока $ilist$, указатель на текущую инструкцию $pos$,
состояние локальных переменных $st$ и отношение зависимости локальной переменной от сгенерированного события $\dep$.
Последний параметр нужен для отношений зависимости.

\[
\inarr{
  \cmdsToVrtxs : \Carm \rightarrow \PreExecutions \\
  \cmdsToVrtxs \; ilist \defeq \instToVrtx \; ilist \; 0 \; (\lambda \reg. 0) \; \emptyset \\
}\]

%% \[\inarr{
%%   \sembr{-} : \Carm \rightarrow
%%     \{\tup{\emptyset, \bot, \emptyset, \emptyset, \emptyset, \emptyset, \emptyset, \lambda \reg. \; 0, \emptyset} \} \\
%%   \sembr{[]} = \{\tup{\emptyset, \bot, \emptyset, \emptyset, \emptyset, \emptyset, \emptyset, \lambda \reg. \; 0, \emptyset} \} \\
%% }\]
{\small
\[
\inarr{
  \instToVrtx : \Carm \rightarrow \mathbb{N} \rightarrow (\Reg \rightarrow \mathbb{N}) \rightarrow \Pset(\Reg \times E)
    \rightarrow \PreExecutions \\
    %% \ListOf{(\Label \times \mathbb{N} \times (\Reg \rightarrow \mathbb{N}))} \\
  \instToVrtx \; ilist \; pos \; \PromState \; \dep \defeq \\
  \quad \textIf   pos < 0 \; || \; pos > length(ilist) \; \textThen
    \{\tup{\emptyset, \bot, \emptyset, \emptyset, \emptyset, \emptyset}\} \\
  \quad \textElse \\
  \qquad
    \letdef{a}{{\rm fresh\text{-}vertex} } \\
  \qquad \kw{match} \; ilist[pos] \; \kw{with} \\
  \qquad
    \begin{array}{@{}l}
    | ``\nop" \rightarrow \instToVrtx \; ilist \; (pos + 1) \; \PromState \; \dep \\
    | ``\readInst{\reg}{\expr}" \rightarrow \\
      \quad \inarr{
        \letdef{\dep'}{(\dep \setminus \{\reg\} \times E) \cup \{\tup{\reg, a}\}} \\
        \letdef{\loc}{\semState{\expr}{\PromState}} \\
        \letdef{\lADDR'}{ \codom{[\regs(\expr)]; \dep} \times \{a\} } \\
        \{\tup{set \cup\{a\}, \lab[a \mapsto \rlab{}{\loc}{\val}], \lPO \cup \{a\} \times set, \lCTRL, \lADDR \cup \lADDR', \lDATA}
        \mid \forall \val \in \Val, \\
        \quad \tup{set, \lab, \lPO, \lCTRL, \lADDR, \lDATA} \in
          \instToVrtx \; ilist \; (pos + 1) \; \PromState[\reg \mapsto \val] \; \dep'\} \\
      } \\
    | ``\assignInst{\reg}{\expr}" \rightarrow \\
      \quad \inarr{
        \letdef{\dep'}{(\dep \setminus \{\reg\} \times E) \cup \{\reg\} \times \regs(\expr) \}} \\
        \instToVrtx \; ilist \; (pos + 1) \; \PromState[\reg \mapsto \semState{\expr}{\PromState}] \; \dep' \\
      } \\
    | ``\writeInst{\expr_0}{\expr_1}" \rightarrow \\
      \quad \inarr{
        \letdef{\loc}{\semState{\expr_0}{\PromState}} \\
        \letdef{\val}{\semState{\expr_1}{\PromState}} \\
        \letdef{\lADDR'}{ \codom{[\regs(\expr_0)]; \dep} \times \{a\} } \\
        \letdef{\lDATA'}{ \codom{[\regs(\expr_1)]; \dep} \times \{a\} } \\
        \{\tup{set \cup\{a\}, \lab[a \mapsto \wlab{}{\loc}{\val}], \lPO \cup \{a\} \times set,
          \lCTRL, \lADDR \cup \lADDR', \lDATA \cup \lDATA'}
        \mid  \\
        \quad \tup{set, \lab, \lPO, \lCTRL, \lADDR, \lDATA} \in
          \instToVrtx \; ilist \; (pos + 1) \; \PromState \; \dep\} \\
      } \\
    | ``\fenceInst{\FtypeProm}" \rightarrow \\
      \quad \inarr{
        \{\tup{set \cup\{a\}, \lab[a \mapsto \flab{\FtypeProm}], \lPO \cup \{a\} \times set,
          \lCTRL, \lADDR, \lDATA}
        \mid  \\
        \quad \tup{set, \lab, \lPO, \lCTRL, \lADDR, \lDATA} \in
          \instToVrtx \; ilist \; (pos + 1) \; \PromState \; \dep\} \\
      } \\
    | ``\ifGotoInst{\expr}{k}" \rightarrow \\
      \quad \inarr{
        \letdef{step}{\textIf \semState{\expr}{\PromState} \; \textThen k \; \textElse 1} \\
        \letdef{dver}{\codom{[\regs(\expr)]; \dep}} \\
        \{\tup{set, \lab, \lPO, \lCTRL \cup dver \times set, \lADDR, \lDATA}
        \mid  \\
        \quad \tup{set, \lab, \lPO, \lCTRL, \lADDR, \lDATA} \in
          \instToVrtx \; ilist \; (pos + step) \; \PromState \; \dep \} \\
      } \\
  \end{array} \\
  %% \\
  %% \cmdsToVrtxsAux : \Carm \rightarrow \mathbb{N} \times (\Reg \rightarrow \mathbb{N}) \rightarrow \ListOf{\Path}\\
  %% \cmdsToVrtxsAux \; ilist \; (pos, \; \PromState) = \letdef{l}{\instToLbl \; ilist \; (pos, \; \PromState)} \\
  %% \quad %\textup{\sf flatten} \;
  %%       [lbl':lbls \mid (lbl', pos', \PromState') \in l, lbls \in \cmdsToLblsAux \; ilist \; (pos', \; \PromState') ] \\
  %% \\
}
\]
}

В определении функции $\instToVrtx$ используется вспомогательная функция $\regs$, которая по выражению
вычисляет множество регистров, от которых это выражение зависит.

\[
\inarr{
  \regs : \Expr \rightarrow \Pset(\Reg) \\
  \regs \; e \defeq \\
  \quad \kw{match} \; e \; \kw{with} \\
  \quad | \; \loc \; | \; \val \rightarrow \emptyset \\
  \quad | \; \reg \rightarrow \{\reg\} \\
  \quad | \; uop \; \expr \rightarrow \regs \; \expr \\
  \quad | \; bop \; \expr_o \; \expr_1 \rightarrow (\regs \; \expr_0) \cup (\regs \; \expr_1) \\
}\]

Как было отмечено выше, функция $\cmdsToVrtxs$ строит предзапуски только одного потока.
Для того, чтобы получить предзапуск всей программы, предзапуски потоков программы должны быть покомпонентно
объединены, а также в каждый получившийся предзапуск должны быть добавлены события инициализирующей записи:
\[
\inarr{
{\textup{\sf prog-to-vertex}} : {\sf Prog} \rightarrow \PreExecutions \\
{\textup{\sf prog-to-vertex}} \; \Cfarm \defeq \\
\quad \letdef{E(\tId)}{\cmdsToVrtxs \; \Cfarm(\tId)} \\
\quad \kw{let} \; P \defeq
  \{\langle \bigcup_{\tId \in \dom{\Cfarm}} pe_{\tId}.set, \bigsqcup_{\tId \in \dom{\Cfarm}} pe_{\tId}.\lLAB,
    \bigcup_{\tId \in \dom{\Cfarm}} pe_{\tId}.\lPO, \\
\qquad 
    \bigcup_{\tId \in \dom{\Cfarm}} pe_{\tId}.\lCTRL, \bigcup_{\tId \in \dom{\Cfarm}} pe_{\tId}.\lADDR,
    \bigcup_{\tId \in \dom{\Cfarm}} pe_{\tId}.\lDATA \rangle \\
\qquad \mid \tId \in \dom{\Cfarm}, pe_{\tId} \in E(\tId) \} \;
\kw{in} \\
\quad \letdef{\lE_{init}, lab_{init}}{\{e_{\loc}, [e_{\loc} \mapsto \evlab{\lW}{\pln}{\loc}{0}] \mid \loc \in \Loc \}} \\
\quad \letdef{\lLAB'}{\bigsqcup lab_{init}} \\
\quad \{\tup{set \cup \lE_{init}, \lLAB \sqcup \lLAB', \lPO \cup (\lE_{init} \times set), \lCTRL, \lADDR, \lDATA} \\
\qquad \mid \tup{set, \lLAB, \lPO, \lCTRL, \lADDR, \lDATA} \in P\}
}\]


\section{Связь между системой переходов и предзапусками}
\label{sec:lts-rel}
Для того, чтобы определить связь между системой переходов, на которой строится исполнение
потока обещающей модели, и предзапуска потока в модели ARMv8.3, мы вводим отношение $\approx$:
\[\inarr{
  \approx : \Label_{\Promise} \rightarrow \Label_{\ARM} \rightarrow {\rm Boolean} \\
  lbl_{\Promise} \approx lbl_{\ARM} \defeq \\
  \qquad \kw{match} \; lbl_{\Promise}, \; lbl_{\ARM} \; \kw{with} \\
  \qquad
    \begin{array}{@{}l}
      \mid \rlab{}{\loc}{\val}, \rlab{}{\loc}{\val}
      \mid \wlab{}{\loc}{\val}, \wlab{}{\loc}{\val} \\
      \mid \flab{\rel}, \flab{\SY}
      \mid \flab{\acq}, \flab{\LD} \rightarrow {\rm true} \\
      \mid \_, \_ \rightarrow {\rm false}
    \end{array}
}\]
Это отношение, по сути, является отношением компиляции. Так, оно связывает метки переходов
чтения и записи с событиями чтения и записи, только если они имеют одинаковые параметры: целевую локацию
и значение. Кроме того, отношение $\approx$ связывает метку высвобождающего барьера $\flab{\rel}$
с событием полного барьера $\flab{\SY}$, а приобретающего барьера $\flab{\acq}$ --- с событием $\LD$-барьера.

\begin{theorem}
  \label{thm:compl-state-preexec}
  Для любого события из предзапуска, построенного по списку инструкций $\Carm$, существует путь
  в системе переходов, построенной по $\Carm$, который имеет эквивалентный событию переход.
  Кроме того, верно и обратное: для любого перехода некоторого пути в системе переходов, построенной по $\Carm$,
  существует предзапуск $\Carm$ и событие в нём, эквивалентное этому переходу.
\[\inarr{
\forall \Carm. \\
\quad (\forall \tup{set, lbl, \lPO, \_, \_, \_} \in \cmdsToVrtxs \; \Carm. \\
\qquad \exists path \in \cmdsToLbls \; \Carm[\tId]. \; \forall n \in \mathbb{N}, a \in \nthf \; \lPO \; n. \\
\qquad \quad \exists k \in \mathbb{N}. \; path[n + k] \approx lbl \; a) \land {} \\
\quad (\forall path \in \cmdsToLbls \; \Carm. \\
\qquad \exists \tup{set, lbl, \lPO, \_, \_, \_} \in \cmdsToVrtxs \; \Carm. \;
  \forall n \in \mathbb{N}. \\
\qquad \quad path[n] \neq \epsilon \Rightarrow \exists k \in \mathbb{N}, a \in \nthf \; \lPO \; (n - k). \; path[n] \approx lbl \; a).
}\]
\end{theorem}
Теорема тривиальным образом обобщается на случай программ, т.е. функций, которые по идентификатору потока возвращают
его список инструкций.

В формулировке теоремы \ref{thm:compl-state-preexec}
присутствует функция $\nthf$, которая по бинарному отношению $rel$ и натуральному числу $n$ возвращает множество элементов
из области определения $rel$, до которых в $rel$ существует путь длины $n$, но не $n+1$:
\[\inarr{
  \nthf : \{A : Set\} \rightarrow \Pset(A \times A) \rightarrow \mathbb{N} \rightarrow \Pset(A) \\
  \nthf \; rel \; n \defeq \codom{rel^{n}} \setminus \codom{rel^{n + 1}}.
}\]

\begin{proof}[Доказательство теоремы \ref{thm:compl-state-preexec}]
  Верно по определению функций $\cmdsToLbls$ и $\cmdsToVrtxs$.
\end{proof}
