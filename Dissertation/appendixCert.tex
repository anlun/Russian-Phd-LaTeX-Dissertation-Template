\chapter{Сертификация в симуляции \ARMt~машины}
\label{sec:app:cert}

При доказательстве того, что обещающая машина может симулировать исполнение \ARMt~машины,
мы используем леммы \ref{lem-snd} и \ref{lem-fst}, в которых конструируется шаг обещающей машины.
Согласно определению после каждого шага обещающая машина должна показывать, что находится в \emph{сертифицируемом состоянии}
(предикат $\certifiable$), т.е. что для каждого потока существует последовательность
локальных шагов, при исполнении которых поток
выполняет все данные обещания (предикат $\certifiableTid$):
\[\begin{array}{r l l}
\certifiable(\p) & \triangleq & \forall \tId. \; \certifiableTid(\tIdState(\tId,\p)); \\
\certifiableTid(\tT) & \triangleq & \exists \tT'. \; \tT \promTStep^{*} \tT' \land \tT'.\PromSet = \emptyset; \\
\tIdState(\tId, \p) & \triangleq & \angled{\p.\Mprom, \p.\TSfprom(\tId)}. \\
\end{array}\]

Теорема \ref{cert-thm}, которая является ключевой в данном приложении и используется в доказательстве
лемм \ref{lem-snd} и \ref{lem-fst}, утверждает,
что если состояния обещающей и \ARMt~машин связаны отношением $\simrelBase$, и при этом состояние \ARMt~машины
достижимо из начального, то состояние обещающей машины сертифицируемо.
%% \begin{restatable}{thm}{certThm}
\begin{theorem}
\label{cert-thm}
$\forall (\aT, \p) \in \simrelBase. \; \ainit \armStepP^{*} \aT \Rightarrow \certifiable(\p)$.
%, \lnot \invTidWriteComCERT(\tId, \aT, \p)$.
%% \end{restatable}
\end{theorem}

\section{Структура доказательства теоремы о сертификации}

Какие невыполненные обещания есть у потока $\tId$ обещающей машины в состоянии $\p$,
если оно связано с некоторым состоянием $\aT$ машины \ARMt~отношением $\simrelBase$?
Согласно отношению $\invMemTwo \suq \simrelBase$ для каждого сообщения
(в том числе обещанного, но не выполненного) в памяти обещающей машины
в плёнке машины \ARMt~существует завершённый экземпляр инструкции записи, ему
соответствующий. Из отношения $\invMemOne \suq \simrelBase$ следует, что
обещанное, но не выполненное сообщение соответствует экземпляру, чей путь не меньше,
чем текущий указатель потока обещающей машины.
Таким образом, для сертификации поток обещающей машины может совершить серию переходов,
которые покроют плёнку машины \ARMt~вплоть до последнего завершённого экземпляра чтения.
При этом обещающая машина будет выполнять переходы, которые будут определены предшествующими
экземплярами инструкций в состоянии машины \ARMt.
Именно наличие такой серии переходов мы будем доказывать.

%% \app{Неформально описать то, как по плёнке строится исполнение обещающей машины.}
%% \app{Привести формальное доказательство.}

Для реализации описанной выше идеи мы используем отношение
$\invCert(n, \delta, k, \tId, \aT, \tT)$, которое имеет шесть параметров:
\begin{itemize}
  \item $\tId$ --- это идентификатор потока, в контексте сертификации которого используется данный элемент отношения;
  \item $n$ --- это количество экземпляров на пути от указателя потока до последнего завершённого экземпляра записи в
    соответствующей плёнке;
  \item $k$ --- это номер инструкции, следующей за последним завершённым экземпляром записи;
  \item $\delta$ --- это частичная функция, имеющая тип $\Path \rightharpoonup (\Timestamp \times \View)$,
    которая экземпляру не завершённой инструкции записи в плёнке потока $\tId$ ставит в соответствие
    пару из метки времени и фронта сообщения, которое
    было добавлено в память обещающей машиной;
  \item $\aT$ --- это состояние машины \ARMt, которое используется для сертификации потока обещающей машины;
  \item $\tT$ --- это состояние потока $\tId$ обещающей машины.
\end{itemize}
Перед тем, как предъявить формальное определение данного отношения, мы приведём утверждения лемм, которые
его используют.

Лемма \ref{cert-lem-three} утверждает, что из $(n, \delta, k, \tId, \aT, \tT) \in \invCert$ следует,
что поток $\tId$ обещающей машины сертифицируем.
\begin{lemma}
\label{cert-lem-three}
$\forall n, \delta, k, \tId, \aT, \tT. \; \invCert(n, \delta, k, \tId, \aT, \tT) \Rightarrow \certifiableTid(\tT)$.
%% \end{restatable}
\end{lemma}
Доказательство данной леммы проводится индукцией по $n$.
Базу индукции мы выделили в лемму \ref{cert-lem-two}, а индукционный переход --- в лемму \ref{cert-lem-one}.

\begin{lemma}
%% \begin{restatable}{lem}{certLemTwo}
\label{cert-lem-two}
$\forall k, \delta, \tId, \aT, \tT, \invCert(0, \delta, k, \tId, \aT, \tT), \tT.\PromSet = \emptyset$.
%% \end{restatable}
\end{lemma}

\begin{lemma}
\label{cert-lem-one}
$\forall n \not = 0, \delta, k, \tId, \aT, \tT, \invCert(n, \delta, k, \tId, \aT, \tT).$ \\
${} \quad \exists \delta', \tT'. \Cfprom(\tId) \vdash \tT \promTStep^{*} \tT' \land \invCert(n - 1, \delta', k, \tId, \aT, \tT')$.
\end{lemma}

\section{Описание отношения $\invCert$}

Отношение $\invCert$ определяется следующим образом.
\[\begin{array}{l}
\invCert \subset \mathbb{N} \times (\Path \rightharpoonup (\Timestamp \times \View))
                            \times \mathbb{N} \times \Tid \times \StateARMtau \times \TStateProm \\
\invCert(n, \delta, k, \tId, \aT, \tT) \triangleq \\
\quad \textLet \tape \triangleq \aT.\tapef(\tId) \; \textIn \\
\quad \textLet \cpath_{\textup{\sf last-wcom}} \triangleq \lastCommittedWrite(\tape) \; \textIn \\
\quad \textLet \cpath_{\textup{\sf next-last}} \triangleq \cpath_{\textup{\sf last-wcom}}:k \; \textIn \\
\quad \ainit \armStepP^{*} \aT \land {} \\
\quad \tT.\cpath \le \cpath_{\textup{\sf next-last}} \land (n = \length(\cpath_{\textup{\sf next-last}}) - \length(\tT.\cpath)) \land {} \\
\quad (\forall \cpath' \ge \tT.\cpath, \delta(\cpath') = \bot) \land {} \\
\qquad \cpath'' \ge \cpath' \ge \tT.\cpath \land \tape(\cpath') = \tapeRead{\Rstate} \land
       \Rstate \not = \tapeSatisfied{\Committed}{\_} \Rightarrow \\
\qquad \quad \tape(\cpath'') \not = \tapeFence{\_}{\_}) \land {} \\
\quad (\forall \cpath'. \; \tT.\cpath \le \cpath' < \cpath_{\textup{\sf next-last}} \Rightarrow \\
\qquad (\Cfprom(\tId)[\lastInstr{\cpath'}] \in \{``\ifGotoInst{\_}{\_}"{}, ``\fenceInst{\_}"{}\} \Rightarrow
             \tape(\cpath') \text{ завершён}) \land {} \\
\qquad \tape(\cpath') \text{ имеет полностью определённый адрес} \land {} \\
\qquad \lnot \Cfprom(\tId)[\lastInstr{\cpath'}] = ``\fenceInst{\SY}") \land {} \\
\quad (\forall \cpath'', \cpath', \Rstate. \\
\quad (\tId, \aT, \tT) \in \invMemOneCERT \cap \invMemTwoCERT \cap \invStateCERT \cap \invViewRelCERT \cap \invViewWriteCERT \land {} \\
\quad (\delta, \tId, \aT, \tT) \in \invMemZeroCERT \cap \invDeltaDefOne \cap \invDeltaDefTwo \cap
               %% \invViewDeltaCERT \cap
               %% \invWriteTimestampCERT \cap
               \invViewReadCERT \land {} \\
\quad (\delta, \tId, \aT) \in \invDeltaDefThree \cap \invDeltaDefFour. \\
\end{array}\]

%% Так, для кортежа $(n, \delta, k, \tId, \aT, \tT)$, входящего в отношение $\invCert$,
%% верны следующие утверждения.
%% \begin{itemize}
%% \end{itemize}

В определении используются следующие отношения, определённые ниже.
\[\begin{array}{l}
\invTidWriteComCERT(\tId, \aT, \p) \triangleq \\
\quad \textLet \tape, \cpath \triangleq \aT.\tapef(\tId), \p.\TSfprom(\tId).\cpath \; \textIn \\
\quad \exists \cpath' \ge \cpath. \tape(\cpath') \; \text{является завершённой записью}. \\
\\

\invViewRelCERT(\tId, \aT, \tT) \triangleq \forall \cpath \ge \tT.\cpath. \\
  \quad \textLet \tape \triangleq \aT.\tapef(\tId) \; \textIn \\
  \quad \textLet \cpath^{\LD} \triangleq \lastLD(\tape, \cpath) \; \textIn \\
  \quad \tT.\Rrel \le
  \bigsqcup \readsCommittedR(\cpath^{\LD}, \tape, \aT.\hmap) \sqcup \\
  \qquad \bigsqcup \opstau(\tId, \cpath, \tape, \aT.\hmap).\\
\end{array}\]

\[\begin{array}{l}
\invViewWriteCERT(\tId, \aT, \tT) \triangleq
  \forall \cpath' \ge \tT.\cpath, \loc. \;
    \aT.\tapef(\tId, \cpath') = \tapeWrite{(\tapeWriteCommitted{\_}{\loc}{\_})} \Rightarrow \\
\qquad \tT.\Rcur(\loc) < \aT.\tmap(\tId, \cpath') \land {} \\
\qquad ((\exists \cpath''. \; \tT.\cpath \le \cpath'' < \cpath' \land 
             \aT.\tapef(\tId, \cpath'') = \tapeFence{\Committed}{\LD}) \Rightarrow \\
\qquad \quad \tT.\Racq(\loc) < \aT.\tmap(\tId, \cpath')).\\
%% \\
%% \invWriteTimestampCERT(\delta, \tId, \aT, \tT) \triangleq \\
%% \quad \forall \cpath' < \tT.\cpath, \w, \aT.\tapef(\tId, \cpath') = \tapeRead{(\tapeSatisfied{\Committed}{\w})}. \\
%% \quad (\aT.\tapef(\w.\tId, \w.\cpath) \text{ is committed}) \lor \\
%% \quad (\w.\tId = \tId \land \delta(\cpath) \not = \bot). \\
\end{array}\]

\[\begin{array}{l}
\deltaHmap(\delta, \tId_{\tT}, \aT) \triangleq \lambda \tId, \cpath. \\
  \quad \textIf \tId = \tId_{\tT} \land \aT.\hmap(\tId, \cpath) = \bot \; \textThen \delta(\cpath) \\
  \quad \textElif \exists \tau, \R, \angled{\tau, \_, \R} = \aT.\tmap(\tId, \cpath) \; \textThen \angled{\tau, \R} \\
  \quad \textElse \bot. \\
\\
\invViewReadCERT(\delta, \tId, \aT, \tT) \triangleq
  \forall \cpath' \ge \tT.\cpath, \w, \tau. \\
\quad \aT.\tapef(\tId, \cpath') = \tapeRead{(\tapeSatisfied{\Committed}{\w})} \land
   \angled{\tau, \_} = \deltaHmap(\delta, \tId, \aT, \w.\tId, \w.\cpath) \Rightarrow \\
\qquad \tT.\Rcur(\w.\loc) \le \tau \land {} \\
\qquad ((\exists \cpath''. \; \tT.\cpath \le \cpath'' < \cpath' \land 
             \aT.\tapef(\tId, \cpath'') = \tapeFence{\Committed}{\LD}) \Rightarrow \\
             \qquad \quad \tT.\Racq(\w.\loc) \le \tau). \\
%% \\
%% \invViewCERT(\tId, \aT, \tT) \triangleq \exists \delta : \Loc \rightarrow [0, 1). \\
%% \quad \invViewDeltaCERT(\delta, \tId, \aT, \tT),
%%       \invViewWriteCERT(\delta, \tId, \aT, \tT), \invViewReadCERT(\delta, \tId, \aT, \tT). \\
\\
\invStateCERT(\tId, \aT, \tT) \triangleq \\
\quad \textLet \regstcom \triangleq \regstcom(\Cfarm(\tId), \aT.\tapef(\tId), \tT.\cpath) \; \textIn \\
\quad \forall \reg. \; \regstcom(\reg) = \bot \lor \tT.\PromState(\reg) = \regstcom(\reg).\\
\end{array}\]

\[\begin{array}{l}
\invMemZeroCERT(\delta, \tId_{\tT}, \aT, \tT) \triangleq
      \forall \cpath, \tau, \R, \loc, \expr_0, \expr_1. \\
\quad \angled{\tau, \R} = \delta(\cpath) \land
      ``\writeInst{\expr_0}{\expr_1}" = \Cfarm(\tId_{\tT}, \lastInstr{\cpath}) \land \loc = \semfcom{\expr_0}{\cpath} \Rightarrow \\
\quad \exists \stval. \semfcom{\expr_1}{\cpath} \in \{\bot, \stval\} \land
      \writeEvt{\loc}{\stval}{\tau}{\R} \in \tT.\Mprom \setminus \tT.\PromSet. \\
\\
\invMemOneCERT(\tId_{\tT}, \aT, \tT) \triangleq \forall \tId, \loc, \stval, \tau, \R', \cpath. \\
  \quad \tapeWrite{(\tapeWriteCommitted{\_}{\loc}{\stval})} = \aT.\tapef(\tId, \cpath) \land
        \angled{\tau, \_, \R'} = \aT.\hmap(\tId, \cpath) \Rightarrow \\
  \quad \exists \R \le \R'. \; \writeEvt{\loc}{\stval}{\tau}{\R} \in \tT.\Mprom \land {} \\
  \qquad (\tId \not = \tId_{\tT} \lor \cpath <   \tT.\cpath \Rightarrow
               \writeEvt{\loc}{\stval}{\tau}{\R} \not \in \tT.\PromSet) \land {} \\
  \qquad (\tId = \tId_{\tT} \land \cpath \ge \tT.\cpath \Rightarrow
               \writeEvt{\loc}{\stval}{\tau}{\R} \in \tT.\PromSet).\\
\\
\invMemTwoCERT(\tId, \aT, \tT) \triangleq \forall \writeEvt{\loc}{\stval}{\tau}{\R} \in \tT.\PromSet. \;
     \tau \not = \tstamp{0} \Rightarrow \\
  \quad \exists \R' \ge \R, \cpath \ge \tT.\cpath . \\
  \qquad \tapeWrite{(\tapeWriteCommitted{\_}{\loc}{\stval})} = \aT.\tapef(\tId, \cpath) \land
              \angled{\tau, \_, \R'} = \aT.\hmap(\tId, \cpath). \\
\end{array}\]

\[\begin{array}{l}
\invDeltaDefOne(\delta, \tId_{\tT}, \aT, \tT) \triangleq \forall \cpath < \tT.\cpath. \; \delta(\cpath) \not = \bot \Leftrightarrow \\
\quad (\exists \expr_0, \expr_1. \; ``\writeInst{\expr_0}{\expr_1}" = \Cfarm(\tId_{\tT}, \lastInstr{\cpath}) \land {} \\
\qquad \aT.\tapef(\tId_{\tT}, \cpath) \text{ isn't committed}). \\
\\
\invDeltaDefTwo(\delta, \tId_{\tT}, \aT, \tT) \triangleq \forall \cpath, \angled{\tau, \R} = \delta(\cpath), \\
\quad ``\writeInst{\expr_0}{\expr_1}" = \Cfarm(\tId_{\tT}, \lastInstr{\cpath}), \loc = \semfcom{\expr_0}{\cpath}. \\
\qquad \R = [\loc @ \tau] \sqcup \tT.\Rrel \land \tT.\Rcur(\loc) \ge \tau. \\
\\
\invDeltaDefThree(\delta, \tId_{\tT}, \aT) \triangleq
  \forall \cpath, \cpath' \not = \cpath, \\
\quad \angled{\tau, \_} = \deltaHmap(\delta, \tId_{\tT}, \aT, \tId_{\tT}, \cpath),
  \angled{\tau', \_} = \deltaHmap(\delta, \tId_{\tT}, \aT, \tId_{\tT}, \cpath'), \\
\quad ``\writeInst{\expr_0}{\expr_1}"   = \Cfarm(\tId_{\tT}, \lastInstr{\cpath}), \\
\quad ``\writeInst{\expr'_0}{\expr'_1}" = \Cfarm(\tId_{\tT}, \lastInstr{\cpath'}). \\
\quad \semfcom{\expr_0}{\cpath} = \semfcom{\expr'_0}{\cpath'} \Rightarrow \tau \not = \tau'. \\
\\
\invDeltaDefFour(\delta, \tId_{\tT}, \aT) \triangleq
      \forall \cpath_{\delta} < \cpath_{read} < \cpath_{\LD} < \cpath_{\delta-read}, \\
\quad \angled{\tau, \_} = \delta(\cpath_{\delta}), \w, \loc, \R. \\
\quad \tape(\cpath_{read}) = \tapeRead{(\tapeSatisfied{\Committed}{\w})} \land \tape(\cpath_{\LD}) = \tapeFence{\Committed}{\LD} \land {} \\
\quad \tape(\cpath_{\delta-read}) = \tapeRead{(\tapeSatisfied{\Committed}{\stRequestWrite{\tId_{\tT}}{\cpath_{\delta}}{\loc}{\_}})} \land {} \\
\quad \R = \aT.\rmap(\w.\tId, \w.\cpath) \not = \bot
      \Rightarrow \\
\qquad \R(\loc) \le \tau. \\
\end{array}\]

\section{Доказательство вспомогательных лемм и теоремы}

\noindent
{\bf Лемма \ref{cert-lem-two}.}
$\forall k, \delta, \tId, \aT, \tT, \invCert(0, \delta, k, \tId, \aT, \tT), \tT.\PromSet = \emptyset$.
%% \end{restatable}
\begin{proof}%[Доказательство леммы \ref{cert-lem-two}]
  Зафиксируем $k, \delta, \tId, \aT, \tT$.
  Поскольку $\invCert(0, \delta, k, \tId, \aT, \tT)$ выполняется и верно, что 
  $\length(\tT.\cpath) = \length(\lastCommittedWrite(\aT.\tapef(\tId))) + 1$, то
  $\tT.\cpath = \lastCommittedWrite(\aT.\tapef(\tId)):k$.
  
  Предположим, что существует ещё не выполненное обещание,
  т.е. $\exists \writeEvt{\loc}{\stval}{\tau}{\R} \in \tT.\PromSet$.
  Тогда, из $\invMemTwoCERT(\tId, \aT, \tT)$ следует, что
  существует фронт $\R' \ge \R$ и путь $\cpath \ge \tT.\cpath$ такие, что
  $\tapeWrite{(\tapeWriteCommitted{\_}{\loc}{\stval})} = \aT.\tapef(\tId, \cpath)$.
  А значит 
  $\cpath \ge \tT.\cpath > \lastCommittedWrite(\aT.\tapef(\tId))$.
  Т.о. мы получили противоречие с определением $\lastCommittedWrite$.
\end{proof}


\noindent \textbf{Лемма \ref{cert-lem-one}.}
$\forall n \not = 0, \delta, k, \tId, \aT, \tT, \invCert(n, \delta, k, \tId, \aT, \tT).$ \\
${} \quad \exists \delta', \tT'. \Cfprom(\tId) \vdash \tT \promTStep^{*} \tT' \land \invCert(n - 1, \delta', k, \tId, \aT, \tT')$.
\begin{proof}
  Зафиксируем $n, \tId, \aT, \tT$. Введём обозначения:
  \[\begin{array}{l c l}
  \tape & \triangleq & \aT.\tapef(\tId); \\
  \angled{\Mprom, \angled{\cpath, \PromState, \V, \PromSet}} & \triangleq & \tT; \\
  \Cprom & \triangleq & \Cfprom(\tId). \\
  \end{array}\]
  Далее в доказательстве нам нужно рассмотреть варианты $\tape(\cpath)$.
  Варианты, при которых $\tape(\cpath) \in \{\tapeNop, \tapeAssign, \tapeIfGoto{\_}{\_}, \tape(\cpath) = \tapeFence{\_}{\_}\}$,
  проверяются тривиальным образом (в этих случаях $\delta' = \delta$).
  Рассмотрим оставшиеся варианты.
  \begin{itemize}
    \item $\tape(\cpath) = \tapeRead{(\tapeSatisfied{\Committed}{\w})}$.
      Поскольку $\ainit \armStepP^{*} \aT$ и $\tape(\cpath) = \tapeRead{(\tapeSatisfied{\Committed}{\w})}$,
      то $\Cprom(\lastInstr{\cpath}) = ``\readInst{\reg}{\expr}"$.
      Введём обозначения:
      \[\begin{array}{l l l}
        \cpath'    & \triangleq & \nextPath{\cpath}{1}; \\
        %% \regstcom  & \triangleq & \regstcom(\aT.\Cfarm(\tId), \tape, \cpath); \\
        \loc       & \triangleq & \semfcom{\expr}{\cpath} = \w.\loc = \semf{\expr}{\PromState}; \\
        \stval  & \triangleq & \w.\stval; \\
        %% \regstcom' & \triangleq & \regstcom(\aT.\Cfarm(\tId), \tape, \cpath') \\
        %%            & =          & \regstcom(\aT.\Cfarm(\tId), \tape, \cpath)[\reg \mapsto \w.\stval] \text{ (by definition)}; \\
        \PromState' & \triangleq & \PromState[\reg \mapsto \stval]. \\
      \end{array}\]
      
      Поскольку верно $\invViewReadCERT(\delta, \tId, \aT, \tT)$, то существуют $\tau$ и $\R$ такие, что 
      $(\tau, \R) = \deltaHmap(\delta, \aT, \w.\tId, \w.\cpath)$ и
      $\Rcur(\loc) \le \tau$. \\
      То, что $\writeEvt{\loc}{\stval}{\tau}{\R} \in \tT.\Mprom \setminus \tT.\PromSet$,
      следует из $(\delta, \tId, \aT, \tT) \in \invMemOneCERT \cap \invMemOneCERT$.
      Введём обозначение:
      \[\V' = \angled{\Rcur', \Racq', \Rrel'} \triangleq \angled{\Rcur \sqcup [\loc@\tau], \Racq \sqcup \R, \Rrel}.\]
      Тогда $\tT \promTStepReadLoc \tT' \triangleq \angled{\Mprom, \angled{\cpath', \V', \PromSet}}$.
      
      То, что выполняется $\invCert(n - 1, \delta, k, \aT, \tT')$, проверяется тривиальным образом.

    \item $\tape(\cpath) = \tapeRead{\Rstate}$, где состояние $\Rstate$ указывает, что экземпляр не завершён.
      Аналогично предыдущему пункту, $\Cprom(\lastInstr{\cpath}) = ``\readInst{\reg}{\expr}"$.
      Введём обозначения:
      \[\begin{array}{l l l}
        \cpath'    & \triangleq & \nextPath{\cpath}{1}; \\
        \regstcom  & \triangleq & \regstcom(\Cprom, \tape, \cpath); \\
        \regstcom' & \triangleq & \regstcom(\Cprom, \tape, \cpath') \\
                   & =          & \regstcom(\Cprom, \tape, \cpath)[\reg \mapsto \bot] \text{ (by definition)}; \\
        \loc       & \triangleq & \semfcom{\expr}{\cpath} \\
                   & =          & \semf{\expr}{\PromState} \text{ (by $\invStateCERT(\tId, \aT, \tT)$)}; \\
        \tau       & \triangleq & \Rcur(\loc). \\
      \end{array}\]
      Из свойств обещающей машины следует, что существуют $\stval$ и $\R$ такие, что
      $\writeEvt{\loc}{\stval}{\tau}{\R} \in \Mprom$.
      Введём обозначения:
      \[\begin{array}{l l l}
      \V' = \angled{\Rcur', \Racq', \Rrel'} & \triangleq & \angled{\Rcur \sqcup [\loc @ \tau], \Racq \sqcup \R, \Rrel} \\
                                            & =          & \angled{\Rcur, \Racq \sqcup \R, \Rrel}; \\
      \PromState' & \triangleq & \PromState[\reg \mapsto \stval].
      \end{array}\]
      
      По определению, выполняется
      $\tT \promTStepReadLoc \tT' \triangleq \angled{\Mprom, \angled{\cpath', \PromState', \V', \PromSet}}$.
      Проверка $\invCert(n - 1, \delta, k, \aT, \tT')$ также тривиальна.

    \item $\tape(\cpath) = \tapeWrite{(\tapeWriteCommitted{\InMemory}{\loc}{\stval})}$.
      Аналогично предыдущим пунктам, $\Cprom(\lastInstr{\cpath}) = ``\writeInst{\expr_0}{\expr_1}"$.
      Введём обозначения:
      \[\begin{array}{l l l}
        \cpath'    & \triangleq & \nextPath{\cpath}{1}; \\
        \regstcom  & \triangleq & \regstcom(\Cprom, \tape, \cpath); \\
        \angled{\tau, \_, \R'} & \triangleq & \aT.\hmap(\tId, \cpath). \\
      \end{array}\]
      Из $\invStateCERT(\tId, \aT, \tT)$ следует, что
      $\loc = \semfcom{\expr_0}{\cpath} = \semf{\expr_0}{\PromState}$ и
      $\stval = \semfcom{\expr_1}{\cpath} = \semf{\expr_1}{\PromState}$.
      Из $\invMemOneCERT(\tId, \aT, \tT)$ следует, что существует 
      $\R \le \R'$ такой, что $\writeEvt{\loc}{\stval}{\tau}{\R} \in \tT.\PromSet \cap \tT.\Mprom$.
      То, что $\Rcur(\loc) < \tau$, следует из $\invViewWriteCERT(\tId, \aT, \tT)$.
      \[\begin{array}{l l l}
        \V' & \triangleq & \angled{\Rcur \sqcup [\loc @ \tau], \Racq \sqcup [\loc @ \tau], \Rrel}; \\
        \PromSet' & \triangleq & \PromSet \setminus \{\writeEvt{\loc}{\stval}{\tau}{\R}\}. \\
      \end{array}\]
      Так, выполняется $\tT \promTStepFulfillLoc \tT' \triangleq \angled{\Mprom, \angled{\cpath', \PromState, \V', \PromSet'}}$.
      Проверка $\invCert(n - 1, \delta, k, \aT, \tT')$ тривиальна.

    \item $\tape(\cpath) = \tapeWrite{\Wstate}$, где состояние $\Wstate$ указывает, что экземпляр не завершён.
      В этом случае поток обещающей машины с идентификатором $\tId$ совершит два перехода:
      сначала пообещает некоторое сообщение, а потом выполнит это обещание.
      Аналогично предыдущим пунктам,
      $\Cprom(\lastInstr{\cpath}) = ``\writeInst{\expr_0}{\expr_1}"$.
      Введём обозначения:
      \[\begin{array}{l l l}
        \cpath'    & \triangleq & \nextPath{\cpath}{1}; \\
        \regstcom  & \triangleq & \regstcom(\Cprom, \tape, \cpath); \\
        \loc       & \triangleq & \semfcom{\expr_0}{\cpath} = \semf{\expr_0}{\PromState}; \\
        \stval       & \triangleq & \semf{\expr_1}{\PromState}. \\
        %% \angled{\tau, \_, \R'} & \triangleq & \aT.\hmap(\tId, \cpath)
        %%   \text{ (it's defined according to properties of the $\ARMt$ machine)}. \\
      \end{array}\]
      Поскольку соответствующий экземпляр записи не завершён, то в памяти \ARMt~машины
      нет связанного с ним запроса, а значит и нужной метки времени для добавляемого обещающей машиной сообщения.
      Поэтому нам нужно выбрать эту метку времени, которую мы будем обозначать $\tau$.
      Метка $\tau$ должна удовлетворять следующим ограничениям.
      \[\begin{array}{l l}
        1. & \Rcur(\loc) < \tau. \\
        2. & \tau \not \in \{\tau' | \stRequestWrite{\loc}{\_}{\tau'}{\_} \in \Mprom \}. \\
        3. & \forall \cpath_{write} \ge \cpath. \; \tape(\cpath_{write}) = \tapeWrite{(\tapeWriteCommitted{\_}{\loc}{\_})} \Rightarrow \\
           &  \quad \tau < \aT.\tmap(\tId, \cpath_{write}). \\
        4. & \forall \cpath_{read} \ge \cpath. \; \tape(\cpath_{read}) = \tapeRead{(\tapeSatisfied{\Committed}{\w})} \land {} \\
           & \quad \aT.\tmap(\w.\tId, \w.\cpath) \not = \bot \Rightarrow \\
           & \qquad \tau \le \aT.\tmap(\w.\tId, \w.\cpath). \\
        5. & \forall \cpath_{read} < \cpath_{\LD} < \cpath_{\delta-read}, \w, \R. \cpath < \cpath_{read} \land {} \\
           & \quad \tape(\cpath_{read}) = \tapeRead{(\tapeSatisfied{\Committed}{\w})} \land
             \tape(\cpath_{\LD}) = \tapeFence{\Committed}{\LD} \land {} \\
           & \quad \tape(\cpath_{\delta-read}) = \tapeRead{(\tapeSatisfied{\Committed}{\stRequestWrite{\tId}{\cpath}\loc}{\_})} \land {} \\
           & \quad \R = \aT.\rmap(\w.\tId, \w.\cpath) \not = \bot \Rightarrow \\
           & \qquad \R(\loc) \le \tau. \\
      \end{array}\]
      Поскольку метки времени являются элементами плотного множества $\mathbb{Q}$, то, как следствие
      $\invViewWriteCERT(\tId, \aT, \tT)$, $\invViewReadCERT(\delta, \tId, \aT, \tT)$ и теоремы \ref{thm:invAview},
      нужная метка $\tau$ существует.

      Введём обозначения:
      \[\begin{array}{l l l}
        \R  & \triangleq & \Rrel \sqcup [\loc @ \tau]; \\
        msg & \triangleq & \writeEvt{\loc}{\stval}{\tau}{\R}; \\
        \Mprom' & \triangleq & \Mprom \cup \{msg\};\\
        \V' = \angled{\Rcur', \Racq', \Rrel'} & \triangleq & \angled{\Rcur \sqcup [\loc @ \tau], \Racq \sqcup [\loc @ \tau], \Rrel}; \\
        \delta' & \triangleq & \delta[\cpath \mapsto \angled{\tau, \R}].\\ 
      \end{array}\]
      Тогда, верно следующее:
      \[\begin{array}{l l l}
        \tT & \promTStepPromiseLoc & \angled{\Mprom', \angled{\cpath , \PromState, \V, \PromSet \cup \{msg\}}} \\
            & \promTStepFulfillLoc & \tT' \triangleq \angled{\Mprom', \angled{\cpath', \PromState, \V', \PromSet}}. \\
      \end{array}\]
      Проверка $\invCert(n - 1, \delta', k, \tId, \aT, \tT')$ тривиальна.
          \qedhere
  \end{itemize}
\end{proof}

\noindent
{\bf Теорема \ref{cert-thm}.}
$\forall (\aT, \p) \in \simrelBase. \ainit \armStepP^{*} \aT \Rightarrow \certifiable(\p)$.
\begin{proof}%[Доказательство теоремы \ref{cert-thm}]
  Зафиксируем $\tId, \tape \triangleq \aT.\tapef(\tId)$. Введём обозначения:
  \[\begin{array}{l l l}
    k & \triangleq & \lastInstr{\lastCommittedWrite(\tape)} + 1; \\
    n & \triangleq & \length(\lastCommittedWrite(\tape):k) - \length(\tT.\cpath); \\
    \cpath_{\textup{\sf last-wcom}} & \triangleq & \lastCommittedWrite(\tape); \\
    \cpath_{\textup{\sf next-last}} & \triangleq & \cpath_{\textup{\sf last-wcom}}:k; \\
    \delta & \triangleq & \lambda \cpath. \; \bot. \\
  \end{array}\]
  Если мы сможем показать, что $\invCert(n, \delta, k, \tId, \aT, \tT)$
  выполняется, то утверждение теоремы верно по лемме \ref{cert-lem-three}.
  %% Проверим, что $\invCert(n, \delta, k, \tId, \aT, \tT)$ выполняется.
  Так, нам нужно проверить следующее утверждение:
  \[\begin{array}{l}
 \ainit \armStepP^{*} \aT \land {} \\
 \tT.\cpath \le \cpath_{\textup{\sf next-last}} \land (n = \length(\cpath_{\textup{\sf next-last}}) - \length(\tT.\cpath)) \land {} \\
 (\forall \cpath' \ge \tT.\cpath, \delta(\cpath') = \bot) \land {} \\
 (\forall \cpath'', \cpath', \Rstate. \\
\quad \cpath'' \ge \cpath' \ge \tT.\cpath \land \tape(\cpath') = \tapeRead{\Rstate} \land
       \Rstate \not = \tapeSatisfied{\Committed}{\_} \Rightarrow \\
\qquad  \tape(\cpath'') \not = \tapeFence{\_}{\_}) \land {} \\
 (\forall \cpath'. \; \tT.\cpath \le \cpath' < \cpath_{\textup{\sf next-last}} \Rightarrow \\
\quad (\Cfprom(\tId)[\lastInstr{\cpath'}] \in \{``\ifGotoInst{\_}{\_}"{}, ``\fenceInst{\_}"{}\} \Rightarrow
             \tape(\cpath') \text{ завершён}) \land {} \\
\quad \tape(\cpath') \text{ имеет полностью определённый адрес} \land {} \\
\quad \lnot \Cfprom(\tId)[\lastInstr{\cpath'}] = ``\fenceInst{\SY}") \land {} \\
 (\tId, \aT, \tT) \in \invMemOneCERT \cap \invMemTwoCERT \cap \invStateCERT \cap \invViewRelCERT \cap \invViewWriteCERT \land {} \\
 (\delta, \tId, \aT, \tT) \in \invMemZeroCERT \cap \invDeltaDefOne \cap \invDeltaDefTwo \cap
               %% \invViewDeltaCERT \cap
               %% \invWriteTimestampCERT \cap
               \invViewReadCERT \land {} \\
 (\delta, \tId, \aT) \in \invDeltaDefThree \cap \invDeltaDefFour. \\
  \end{array}\]
  Первые три конъюнкта очевидно выполняются.
  Четвертый конъюнкт выполняется по ограничениям перехода \transenv{Завершение барьера} машины ARMv8 POP.
  Пятый конъюнкт выполняется по ограничениям перехода \transenv{Завершение записи} машины ARMv8 POP и
  верности утверждения $\invComWrite(\aT, \p)$.

  Утверждения $(\delta, \tId, \aT) \in \invDeltaDefThree \cap \invDeltaDefFour$ и
  $(\delta, \tId, \aT, \tT) \in \invDeltaDefOne \cap \invDeltaDefTwo \cap \invMemZeroCERT$
  верны, поскольку $\delta = \lambda \cpath. \; \bot$ является нигде не определённой функцией.
  Утверждение $(\delta, \tId, \aT, \tT) \in \invViewReadCERT$ верно, поскольку
  $\delta = \lambda \cpath. \; \bot$ и выполняется теорема \ref{thm:invAview}.

  Утверждение $(\tId, \aT, \tT) \in \invMemOneCERT \cap \invMemTwoCERT \cap \invStateCERT$
  непосредственно следует из $(\aT, \p) \in \invMemOne \cap \invMemTwo \cap \invState$.
  Утверждение $(\tId, \aT, \tT) \in \invViewRelCERT \cap \invViewWriteCERT$ следует из $(\aT, \p) \in \invView$
  и того, что все экземпляры чтения, предшествующие завершённому экземпляру барьера, также являются завершёнными
  по свойствам модели ARMv8 POP.
\end{proof}
