\chapter{Сертификация в симуляции \ARMt~машины}
\label{sec:app:cert}

При доказательстве того, что обещающая машина может симулировать исполнение \ARMt~машины,
мы используем леммы \ref{lem-snd} и \ref{lem-fst}, в которых конструируется шаг обещающей машины.
Согласно определению после каждого шага обещающая машина должна показывать, что находится в \emph{сертифицируемом состоянии}
(предикат $\certifiable$), т.е. что для каждого потока существует последовательность
локальных шагов, при исполнении которых поток
выполняет все данные обещания (предикат $\certifiableTid$):
\[\begin{array}{r l l}
\certifiable(\p) & \triangleq & \forall \tId. \; \certifiableTid(\tIdState(\tId,\p)); \\
\certifiableTid(\tT) & \triangleq & \exists \tT'. \; \tT \promTStep^{*} \tT' \land \tT'.\PromSet = \emptyset; \\
\tIdState(\tId, \p) & \triangleq & \angled{\p.\Mprom, \p.\TSfprom(\tId)}. \\
\end{array}\]

Теорема \ref{cert-thm}, которая является ключевой в данном приложении и используется в доказательстве
лемм \ref{lem-snd} и \ref{lem-fst}, утверждает,
что если состояния обещающей и \ARMt~машин связаны отношением $\simrelBase$, и при этом состояние \ARMt~машины
достижимо из начального, то состояние обещающей машины сертифицируемо.
%% \begin{restatable}{thm}{certThm}
\begin{theorem}
\label{cert-thm}
$\forall (\aT, \p) \in \simrelBase. \; \ainit \armStepP^{*} \aT \Rightarrow \certifiable(\p)$.
%, \lnot \invTidWriteComCERT(\tId, \aT, \p)$.
%% \end{restatable}
\end{theorem}

\section{Структура доказательства теоремы \ref{cert-thm}}

Какие невыполненные обещания есть у потока $\tId$ обещающей машины в состоянии $\p$,
если оно связано с некоторым состоянием $\aT$ машины \ARMt~отношением $\simrelBase$?
Согласно отношению $\invMemTwo \suq \simrelBase$ для каждого сообщения
(в том числе обещанного, но не выполненного) в памяти обещающей машины
в плёнке машины \ARMt~существует завершённый экземпляр инструкции записи, ему
соответствующий. Из отношения $\invMemOne \suq \simrelBase$ следует, что
обещанное, но не выполненное сообщение соответствует экземпляру, чей путь не меньше,
чем текущий указатель потока обещающей машины.
Таким образом, для сертификации поток обещающей машины может совершить серию переходов,
которые покроют плёнку машины \ARMt~вплоть до последнего завершённого экземпляра чтения.
При этом обещающая машина будет выполнять переходы, которые будут определены предшествующими
экземплярами инструкций в состоянии машины \ARMt.
Именно наличие такой серии переходов мы будем доказывать.

%% \app{Неформально описать то, как по плёнке строится исполнение обещающей машины.}
%% \app{Привести формальное доказательство.}

Для реализации описанной выше идеи мы используем отношение
$\invCert(n, \delta, k, \tId, \aT, \tT)$, которое имеет шесть параметров:
\begin{itemize}
  \item $\tId$ --- это идентификатор потока, в контексте сертификации которого используется данный элемент отношения;
  \item $n$ --- это количество экземпляров на пути от указателя потока до последнего завершённого экземпляра записи в
    соответствующей плёнке;
  \item $k$ --- это номер инструкции, следующей за последним завершённым экземпляром записи;
  \item $\delta$ --- это частичная функция, имеющая тип $\Path \rightharpoonup (\Timestamp \times \View)$,
    которая экземпляру не завершённой инструкции записи в плёнке потока $\tId$ ставит в соответствие
    пару из метки времени и фронта сообщения, которое
    было добавлено в память обещающей машиной;
  \item $\aT$ --- это состояние машины \ARMt, которое используется для сертификации потока обещающей машины;
  \item $\tT$ --- это состояние потока $\tId$ обещающей машины.
\end{itemize}
Перед тем, как предъявить формальное определение данного отношения, мы приведём утверждения лемм, которые
его используют.

Лемма \ref{cert-lem-three} утверждает, что из $(n, \delta, k, \tId, \aT, \tT) \in \invCert$ следует,
что поток $\tId$ обещающей машины сертифицируем.
\begin{lemma}
\label{cert-lem-three}
$\forall n, \delta, k, \tId, \aT, \tT. \; \invCert(n, \delta, k, \tId, \aT, \tT) \Rightarrow \certifiableTid(\tT)$.
%% \end{restatable}
\end{lemma}
Доказательство данной леммы проводится индукцией по $n$.
Базу индукции мы выделили в лемму \ref{cert-lem-two}, а индукционный переход --- в лемму \ref{cert-lem-one}.

\begin{lemma}
%% \begin{restatable}{lem}{certLemTwo}
\label{cert-lem-two}
$\forall k, \delta, \tId, \aT, \tT, \invCert(0, \delta, k, \tId, \aT, \tT), \tT.\PromSet = \emptyset$.
%% \end{restatable}
\end{lemma}

\begin{lemma}
\label{cert-lem-one}
$\forall n \not = 0, \delta, k, \tId, \aT, \tT, \invCert(n, \delta, k, \tId, \aT, \tT).$ \\
${} \quad \exists \delta', \tT'. \Cfprom(\tId) \vdash \tT \promTStep^{*} \tT' \land \invCert(n - 1, \delta', k, \tId, \aT, \tT')$.
\end{lemma}

\section{Описание отношения $\invCert$}

Отношение $\invCert$ определяется следующим образом.
\[\begin{array}{l}
\invCert \subset \mathbb{N} \times (\Path \rightharpoonup (\Timestamp \times \View))
                            \times \mathbb{N} \times \Tid \times \StateARMtau \times \TStateProm \\
\invCert(n, \delta, k, \tId, \aT, \tT) \triangleq \\
\quad \textLet \tape \triangleq \aT.\tapef(\tId) \; \textIn \\
\quad \textLet \cpath_{\textup{\sf last-wcom}} \triangleq \lastCommittedWrite(\tape) \; \textIn \\
\quad \textLet \cpath_{\textup{\sf next-last}} \triangleq \cpath_{\textup{\sf last-wcom}}:k \; \textIn \\
\quad \ainit \armStepP^{*} \aT \land {} \\
\quad \tT.\cpath \le \cpath_{\textup{\sf next-last}} \land (n = \length(\cpath_{\textup{\sf next-last}}) - \length(\tT.\cpath)) \land {} \\
\quad (\forall \cpath'. \; \tT.\cpath \le \cpath' < \cpath_{\textup{\sf next-last}} \Rightarrow \\
\qquad (\Cfprom(\tId)[\lastInstr{\cpath'}] \in \{``\ifGotoInst{\_}{\_}"{}, ``\fenceInst{\_}"{}\} \Rightarrow
             \tape(\cpath') \text{ завершён}) \land {} \\
\qquad \tape(\cpath') \text{ имеет полностью определённый адрес} \land {} \\
\qquad \lnot \Cfprom(\tId)[\lastInstr{\cpath'}] = ``\fenceInst{\SY}") \land {} \\
\quad (\forall \cpath'', \cpath', \Rstate. \\
\qquad \cpath'' \ge \cpath' \ge \tT.\cpath \land \tape(\cpath') = \tapeRead{\Rstate} \land
       \Rstate \not = \tapeSatisfied{\Committed}{\_} \Rightarrow \\
\qquad \quad \tape(\cpath'') \not = \tapeFence{\_}{\_}) \land {} \\
\quad (\forall \cpath' \ge \tT.\cpath, \delta(\cpath') = \bot) \land {} \\
\quad (\tId, \aT, \tT) \in \invMemOneCERT \cap \invMemTwoCERT \cap \invStateCERT \cap \invViewRelCERT \cap \invViewWriteCERT \land {} \\
\quad (\delta, \tId, \aT, \tT) \in \invMemZeroCERT \cap \invDeltaDefOne \cap \invDeltaDefTwo \cap
               %% \invViewDeltaCERT \cap
               %% \invWriteTimestampCERT \cap
               \invViewReadCERT \land {} \\
\quad (\delta, \tId, \aT) \in \invDeltaDefThree \cap \invDeltaDefFour. \\
\end{array}\]

%% Так, для кортежа $(n, \delta, k, \tId, \aT, \tT)$, входящего в отношение $\invCert$,
%% верны следующие утверждения.
%% \begin{itemize}
%% \end{itemize}

В определении используются следующие отношения, определённые ниже.
\[\begin{array}{l}
\invTidWriteComCERT(\tId, \aT, \p) \triangleq \\
\quad \textLet \tape, \cpath \triangleq \aT.\tapef(\tId), \p.\TSfprom(\tId).\cpath \; \textIn \\
\quad \exists \cpath' \ge \cpath. \tape(\cpath') \; \text{является завершённой записью}. \\
\\

\invViewRelCERT(\tId, \aT, \tT) \triangleq \forall \cpath \ge \tT.\cpath. \\
  \quad \textLet \tape \triangleq \aT.\tapef(\tId) \; \textIn \\
  \quad \textLet \cpath^{\LD} \triangleq \lastLD(\tape, \cpath) \; \textIn \\
  \quad \tT.\Rrel \le
  \bigsqcup \readsCommittedR(\cpath^{\LD}, \tape, \aT.\hmap) \sqcup \\
  \qquad \bigsqcup \opstau(\tId, \cpath, \tape, \aT.\hmap).\\
\end{array}\]

\[\begin{array}{l}
\invViewWriteCERT(\tId, \aT, \tT) \triangleq
  \forall \cpath' \ge \tT.\cpath, \loc. \;
    \aT.\tapef(\tId, \cpath') = \tapeWrite{(\tapeWriteCommitted{\_}{\loc}{\_})} \Rightarrow \\
\qquad \tT.\Rcur(\loc) < \aT.\tmap(\tId, \cpath') \land {} \\
\qquad ((\exists \cpath''. \; \tT.\cpath \le \cpath'' < \cpath' \land 
             \aT.\tapef(\tId, \cpath'') = \tapeFence{\Committed}{\LD}) \Rightarrow \\
\qquad \quad \tT.\Racq(\loc) < \aT.\tmap(\tId, \cpath')).\\
%% \\
%% \invWriteTimestampCERT(\delta, \tId, \aT, \tT) \triangleq \\
%% \quad \forall \cpath' < \tT.\cpath, \w, \aT.\tapef(\tId, \cpath') = \tapeRead{(\tapeSatisfied{\Committed}{\w})}. \\
%% \quad (\aT.\tapef(\w.\tId, \w.\cpath) \text{ is committed}) \lor \\
%% \quad (\w.\tId = \tId \land \delta(\cpath) \not = \bot). \\
\end{array}\]

\[\begin{array}{l}
\deltaHmap(\delta, \tId_{\tT}, \aT) \triangleq \lambda \tId, \cpath. \\
  \quad \textIf \tId = \tId_{\tT} \land \aT.\hmap(\tId, \cpath) = \bot \; \textThen \delta(\cpath) \\
  \quad \textElif \exists \tau, \R, \angled{\tau, \_, \R} = \aT.\tmap(\tId, \cpath) \; \textThen \angled{\tau, \R} \\
  \quad \textElse \bot. \\
\\
\invViewReadCERT(\delta, \tId, \aT, \tT) \triangleq
  \forall \cpath' \ge \tT.\cpath, \w, \tau. \\
\quad \aT.\tapef(\tId, \cpath') = \tapeRead{(\tapeSatisfied{\Committed}{\w})} \land
   \angled{\tau, \_} = \deltaHmap(\delta, \tId, \aT, \w.\tId, \w.\cpath) \Rightarrow \\
\qquad \tT.\Rcur(\w.\loc) \le \tau \land {} \\
\qquad ((\exists \cpath''. \; \tT.\cpath \le \cpath'' < \cpath' \land 
             \aT.\tapef(\tId, \cpath'') = \tapeFence{\Committed}{\LD}) \Rightarrow \\
             \qquad \quad \tT.\Racq(\w.\loc) \le \tau). \\
%% \\
%% \invViewCERT(\tId, \aT, \tT) \triangleq \exists \delta : \Loc \rightarrow [0, 1). \\
%% \quad \invViewDeltaCERT(\delta, \tId, \aT, \tT),
%%       \invViewWriteCERT(\delta, \tId, \aT, \tT), \invViewReadCERT(\delta, \tId, \aT, \tT). \\
\\
\invStateCERT(\tId, \aT, \tT) \triangleq \\
\quad \textLet \regstcom \triangleq \regstcom(\Cfarm(\tId), \aT.\tapef(\tId), \tT.\cpath) \; \textIn \\
\quad \forall \reg. \; \regstcom(\reg) = \bot \lor \tT.\PromState(\reg) = \regstcom(\reg).\\
\end{array}\]

\[\begin{array}{l}
\invMemZeroCERT(\delta, \tId_{\tT}, \aT, \tT) \triangleq
      \forall \cpath, \tau, \R, \loc, \expr_0, \expr_1. \\
\quad \angled{\tau, \R} = \delta(\cpath) \land
      ``\writeInst{\expr_0}{\expr_1}" = \Cfarm(\tId_{\tT}, \lastInstr{\cpath}) \land \loc = \semfcom{\expr_0}{\cpath} \Rightarrow \\
\quad \exists \stval. \semfcom{\expr_1}{\cpath} \in \{\bot, \stval\} \land
      \writeEvt{\loc}{\stval}{\tau}{\R} \in \tT.\Mprom \setminus \tT.\PromSet. \\
\\
\invMemOneCERT(\tId_{\tT}, \aT, \tT) \triangleq \forall \tId, \loc, \stval, \tau, \R', \cpath. \\
  \quad \tapeWrite{(\tapeWriteCommitted{\_}{\loc}{\stval})} = \aT.\tapef(\tId, \cpath) \land
        \angled{\tau, \_, \R'} = \aT.\hmap(\tId, \cpath) \Rightarrow \\
  \quad \exists \R \le \R'. \; \writeEvt{\loc}{\stval}{\tau}{\R} \in \tT.\Mprom \land {} \\
  \qquad (\tId \not = \tId_{\tT} \lor \cpath <   \tT.\cpath \Rightarrow
               \writeEvt{\loc}{\stval}{\tau}{\R} \not \in \tT.\PromSet) \land {} \\
  \qquad (\tId = \tId_{\tT} \land \cpath \ge \tT.\cpath \Rightarrow
               \writeEvt{\loc}{\stval}{\tau}{\R} \in \tT.\PromSet).\\
\\
\invMemTwoCERT(\tId, \aT, \tT) \triangleq \forall \writeEvt{\loc}{\stval}{\tau}{\R} \in \tT.\PromSet. \;
     \tau \not = \tstamp{0} \Rightarrow \\
  \quad \exists \R' \ge \R, \cpath \ge \tT.\cpath . \\
  \qquad \tapeWrite{(\tapeWriteCommitted{\_}{\loc}{\stval})} = \aT.\tapef(\tId, \cpath) \land
              \angled{\tau, \_, \R'} = \aT.\hmap(\tId, \cpath). \\
\end{array}\]

\[\begin{array}{l}
\invDeltaDefOne(\delta, \tId_{\tT}, \aT, \tT) \triangleq \forall \cpath < \tT.\cpath. \; \delta(\cpath) \not = \bot \Leftrightarrow \\
\quad (\exists \expr_0, \expr_1. \; ``\writeInst{\expr_0}{\expr_1}" = \Cfarm(\tId_{\tT}, \lastInstr{\cpath}) \land {} \\
\qquad \aT.\tapef(\tId_{\tT}, \cpath) \text{ isn't committed}). \\
\\
\invDeltaDefTwo(\delta, \tId_{\tT}, \aT, \tT) \triangleq \forall \cpath, \angled{\tau, \R} = \delta(\cpath), \\
\quad ``\writeInst{\expr_0}{\expr_1}" = \Cfarm(\tId_{\tT}, \lastInstr{\cpath}), \loc = \semfcom{\expr_0}{\cpath}. \\
\qquad \R = [\loc @ \tau] \sqcup \tT.\Rrel \land \tT.\Rcur(\loc) \ge \tau. \\
\\
\invDeltaDefThree(\delta, \tId_{\tT}, \aT) \triangleq
  \forall \cpath, \cpath' \not = \cpath, \\
\quad \angled{\tau, \_} = \deltaHmap(\delta, \tId_{\tT}, \aT, \tId_{\tT}, \cpath),
  \angled{\tau', \_} = \deltaHmap(\delta, \tId_{\tT}, \aT, \tId_{\tT}, \cpath'), \\
\quad ``\writeInst{\expr_0}{\expr_1}"   = \Cfarm(\tId_{\tT}, \lastInstr{\cpath}), \\
\quad ``\writeInst{\expr'_0}{\expr'_1}" = \Cfarm(\tId_{\tT}, \lastInstr{\cpath'}). \\
\quad \semfcom{\expr_0}{\cpath} = \semfcom{\expr'_0}{\cpath'} \Rightarrow \tau \not = \tau'. \\
\\
\invDeltaDefFour(\delta, \tId_{\tT}, \aT) \triangleq
      \forall \cpath_{\delta} < \cpath_{read} < \cpath_{\LD} < \cpath_{\delta-read}, \\
\quad \angled{\tau, \_} = \delta(\cpath_{\delta}), \w, \loc, \R. \\
\quad \tape(\cpath_{read}) = \tapeRead{(\tapeSatisfied{\Committed}{\w})} \land \tape(\cpath_{\LD}) = \tapeFence{\Committed}{\LD} \land {} \\
\quad \tape(\cpath_{\delta-read}) = \tapeRead{(\tapeSatisfied{\Committed}{\stRequestWrite{\tId_{\tT}}{\cpath_{\delta}}{\loc}{\_}})} \land {} \\
\quad \R = \aT.\rmap(\w.\tId, \w.\cpath) \not = \bot
      \Rightarrow \\
\qquad \R(\loc) \le \tau. \\
\end{array}\]

\section{Доказательство вспомогательных лемм и теоремы}

\noindent
{\bf Лемма \ref{cert-lem-two}.}
$\forall k, \delta, \tId, \aT, \tT, \invCert(0, \delta, k, \tId, \aT, \tT), \tT.\PromSet = \emptyset$.
%% \end{restatable}
\begin{proof}%[Доказательство леммы \ref{cert-lem-two}]
  Зафиксируем $k, \delta, \tId, \aT, \tT$.
  Поскольку $\invCert(0, \delta, k, \tId, \aT, \tT)$ выполняется и верно, что 
  $\length(\tT.\cpath) = \length(\lastCommittedWrite(\aT.\tapef(\tId))) + 1$, то
  $\tT.\cpath = \lastCommittedWrite(\aT.\tapef(\tId)):k$.
  
  Предположим, что существует ещё не выполненное обещание,
  т.е. $\exists \writeEvt{\loc}{\stval}{\tau}{\R} \in \tT.\PromSet$.
  Тогда, из $\invMemTwoCERT(\tId, \aT, \tT)$ следует, что
  существует фронт $\R' \ge \R$ и путь $\cpath \ge \tT.\cpath$ такие, что
  $\tapeWrite{(\tapeWriteCommitted{\_}{\loc}{\stval})} = \aT.\tapef(\tId, \cpath)$.
  А значит 
  $\cpath \ge \tT.\cpath > \lastCommittedWrite(\aT.\tapef(\tId))$.
  Т.о. мы получили противоречие с определением $\lastCommittedWrite$.
\end{proof}

\noindent
{\bf Теорема \ref{cert-thm}.}
$\forall (\aT, \p) \in \simrelBase. \ainit \armStepP^{*} \aT \Rightarrow \certifiable(\p)$.
\begin{proof}%[Доказательство теоремы \ref{cert-thm}]
  Зафиксируем $\tId, \tape \triangleq \aT.\tapef(\tId)$. Введём обозначения:
  \[\begin{array}{l l l}
    k & \triangleq & \lastInstr{\lastCommittedWrite(\tape)} + 1; \\
    n & \triangleq & \length(\lastCommittedWrite(\tape):k) - \length(\tT.\cpath); \\
    \cpath_{\textup{\sf last-wcom}} & \triangleq & \lastCommittedWrite(\tape); \\
    \cpath_{\textup{\sf next-last}} & \triangleq & \cpath_{\textup{\sf last-wcom}}:k; \\
    \delta & \triangleq & \lambda \cpath. \; \bot. \\
  \end{array}\]
  Если мы сможем показать, что $\invCert(n, \delta, k, \tId, \aT, \tT)$
  выполняется, то утверждение теоремы верно по лемме \ref{cert-lem-three}.

  Проверим, что $\invCert(n, \delta, k, \tId, \aT, \tT)$ выполняется.
  We have to show:
  \[\begin{array}{l}
    \ainit \armStepP^{*} \aT \land {} \\
    \tT.\cpath \le \cpath_{\textup{\sf next-last}} \land (n = \length(\cpath_{\textup{\sf next-last}}) - \length(\tT.\cpath)) \land {} \\
    (\forall \cpath'. \; \tT.\cpath \le \cpath' < \cpath_{\textup{\sf next-last}} \Rightarrow \\
    \quad (\Cprom[\lastInstr{\cpath'}] \in \{``\ifGotoInst{\_}{\_}", ``\fenceInst{\_}"\} \Rightarrow
             \tape(\cpath') \text{ is committed}) \land {} \\
    \quad \tape(\cpath') \text{ has a fully determined address} \land {} \\
    \quad \lnot \Cprom[\lastInstr{\cpath'}] = ``\fenceInst{\SY}") \land {} \\
    (\forall \cpath'', \cpath', \Rstate. \\
    \quad \cpath'' \ge \cpath' \ge \tT.\cpath \land \tape(\cpath') = \tapeRead{\Rstate} \land
       \Rstate \not = \tapeSatisfied{\Committed}{\_} \Rightarrow \\
    \qquad \tape(\cpath'') \not = \tapeFence{\_}{\_}) \land {} \\
    (\forall \cpath' \ge \tT.\cpath, \delta(\cpath') = \bot) \land {} \\
    (\tId, \aT, \tT) \in \invMemOneCERT \cap \invMemTwoCERT \cap \invStateCERT \cap \invViewRelCERT \cap \invViewWriteCERT \land {} \\
    (\delta, \tId, \aT, \tT) \in \invMemZeroCERT \cap \invDeltaDefOne \cap \invDeltaDefTwo \cap
               %% \invViewDeltaCERT \cap
               %% \invWriteTimestampCERT \cap
               \invViewReadCERT \land {} \\
    (\delta, \tId, \aT) \in \invDeltaDefThree \cap \invDeltaDefFour. \\
  \end{array}\]

  The following obviously holds:
  \[\begin{array}{l}
    \ainit \armStepP^{*} \aT \land {} \\
    \tT.\cpath \le \cpath_{\textup{\sf next-last}} \land (n = \length(\cpath_{\textup{\sf next-last}}) - \length(\tT.\cpath)) \land {} \\
    (\forall \cpath' \ge \tT.\cpath, \delta(\cpath') = \bot). \\
  \end{array}\]

  The following holds as committed memory instructions can't be restarted by the ARM machine and requirements of
  the {\sf \bf Fence commit} transition:
  \[\begin{array}{l}
    \forall \cpath'', \cpath', \Rstate. \\
    \quad \cpath'' \ge \cpath' \ge \tT.\cpath \land \tape(\cpath') = \tapeRead{\Rstate} \land
       \Rstate \not = \tapeSatisfied{\Committed}{\_} \Rightarrow \\
    \qquad \tape(\cpath'') \not = \tapeFence{\_}{\_}. \\
  \end{array}\]

  The following holds as committed memory instructions can't be restarted by the ARM machine, requirements of
  the {\sf \bf Write commit} transition, and $\invComWrite(\aT, \p)$:
  \[\begin{array}{l}
    \forall \cpath'. \; \tT.\cpath \le \cpath' < \cpath_{\textup{\sf next-last}} \Rightarrow \\
    \quad (\Cprom[\lastInstr{\cpath'}] \in \{``\ifGotoInst{\_}{\_}", ``\fenceInst{\_}"\} \Rightarrow
             \tape(\cpath') \text{ is committed}) \land {} \\
    \quad \tape(\cpath') \text{ has a fully determined address} \land
    \quad \lnot \Cprom[\lastInstr{\cpath'}] = ``\fenceInst{\SY}". \\
  \end{array}\]

  $(\delta, \tId, \aT) \in \invDeltaDefThree \cap \invDeltaDefFour$ and
  $(\delta, \tId, \aT, \tT) \in \invDeltaDefOne \cap \invDeltaDefTwo \cap \invMemZeroCERT$
  hold as $\delta = \lambda \cpath. \; \bot$.
  $\invViewReadCERT(\delta, \tId, \aT, \tT)$ follows from $\delta = \lambda \cpath. \; \bot$ and \app{\ref{thm:invAview}}.

  
  $\invMemOneCERT(\tId, \aT, \tT)$, $\invMemTwoCERT(\tId, \aT, \tT)$, and $\invStateCERT(\tId, \aT, \tT)$
  directly follow from $\invMemOne(\aT, \p)$, $\invMemTwo(\aT, \p)$, and $\invState(\aT, \p)$ respectively.
  $\invViewRelCERT(\tId, \aT, \tT)$ follows from $\invView(\aT, \p)$ and a fact that all reads before a committed fence are committed
  in the ARM machine. $\invViewWriteCERT(\tId, \aT, \tT)$ follows $\invView(\aT, \p)$ and \app{\ref{thm:invAview}}.
\end{proof}




%% \begin{restatable}{lem}{certLemOne}
\begin{proof}[Доказательство леммы \ref{cert-lem-one}]
  Fix $n, \tId, \aT, \tT$.
  Some notations:
  \[\begin{array}{l c l}
  \tape & \triangleq & \aT.\tapef(\tId); \\
  \angled{\Mprom, \angled{\cpath, \PromState, \V, \PromSet}} & \triangleq & \tT; \\
  \Cprom & \triangleq & \Cfprom(\tId). \\
  \end{array}\]

  Case analysis on $\tape(\cpath)$:
  \begin{itemize}
    \item $\tape(\cpath) = \tapeNop$.
      Some notations:
      \[\begin{array}{l l l}
        \cpath' & \triangleq & \nextPathProm(\cpath, 1); \\
        \tT'    & \triangleq & \angled{\Mprom, \angled{\cpath', \PromState, \V, \PromSet}}.
      \end{array}\]
      As $\ainit \armStepP^{*} \aT$ and $\tape(\cpath) = \tapeNop$, $\Cprom(\lastInstr{\cpath}) = \nop$.
      Thus, $\tT \promStepNop \tT'$.
      $\invCert(n - 1, \delta, k, \tId, \aT, \tT')$ obviously holds.

    \item $\tape(\cpath) = \tapeAssign$.
      As $\ainit \armStepP^{*} \aT$ and $\tape(\cpath) = \tapeAssign$, \\
      $\exists \reg, \expr. \; \Cprom(\lastInstr{\cpath}) = ``\assignInst{\reg}{\expr}"$.
      \[\begin{array}{l l l}
        \cpath'     & \triangleq & \nextPathProm(\cpath, 1); \\
        \PromState' & \triangleq & \PromState[\reg \mapsto \semState{\expr}{\PromState}] \\
        \tT'        & \triangleq & \angled{\Mprom, \angled{\cpath', \PromState', \V, \PromSet}}.
      \end{array}\]
      Thus, $\tT \promStepNop \tT'$. Let's check $\invCert(n - 1, \delta, k, \tId, \aT, \tT')$.
      The only component of $\invCert$ worth checking is $\invStateCERT(\tId, \aT, \tT')$.
      As $\invStateCERT(\tId, \aT, \tT')$, we know that:
      \[\begin{array}{l}
        \stval \triangleq |[\expr|]^{\Committed}_{\cpath} \in \{\bot, |[\expr|]^{\PromState}\}; \\
        \regstcom(\Cprom(\tId), \tape, \cpath') = \regstcom(\Cprom(\tId), \tape, \cpath)[\reg \mapsto \stval]. \\
      \end{array}\]
      Thus, $\invStateCERT(\tId, \aT, \tT')$ holds.

    \item $\tape(\cpath) = \tapeIfGoto{\IfState}{\z}$. From $\invCert(n, \delta, k, \tId, \aT, \tT')$ we know that
      $\tape(\cpath)$ is committed, so $\IfState \in \{\Taken, \Ignored\}$.
      As $\ainit \armStepP^{*} \aT$ and $\tape(\cpath) = \tapeIfGoto{\IfState}{\z}$, \\
      $\exists \expr. \; \Cprom[\lastInstr{\cpath}] = ``\ifGotoInst{\expr}{\z}"$.
      From \app{\ref{inv:invATapeCfState}} we know that 
      \[\begin{array}{l}
        \exists \stval = \semfcom{\expr}{\cpath} \not = \bot.
          (\IfState = \Taken \land \stval \not = 0) \lor (\IfState = \Ignored \land \stval = 0)).
      \end{array}\]
      Fix $\stval$. As $\stval = \semfcom{\expr}{\cpath} \not = \bot$, $|[\expr|]^{\PromState} = \stval$
      by $\invCert(n, \delta, k, \tId, \aT, \tT)$.
      So $\cpath' \triangleq \nextPathProm(\cpath, \textIf \stval \not = 0 \; \textThen \z \; \textElse 1)$
      $\le \lastCommittedWrite(\tape)$, as the Promise machine chooses the same branch.
      
      By definition, $\tT \promTStepBranch \angled{\Mprom, \angled{\cpath', \PromState, \V, \PromSet}}$.
      $\invCert(n - 1, \delta, k, \tId, \aT, \tT')$ obviously holds.

    \item $\tape(\cpath) = \tapeFence{\Fstate}{\Ftype}$.
      From $\invCert(n, \delta, k, \tId, \aT, \tT)$ we know that $\Fstate = \Committed, \Ftype = \LD$.
      As $\ainit \armStepP^{*} \aT$ and $\tape(\cpath) = \tapeFence{\Committed}{\LD}$,
      $\Cprom(\lastInstr{\cpath}) = \fenceInst{\LD}$.

      Some notations:
      \[\begin{array}{l l l}
        \cpath' & \triangleq & \nextPathProm(\cpath, 1); \\
        \V'     & \triangleq & \angled{\V.\Racq, \V.\Racq, \V.\Rrel} \\
        \tT'    & \triangleq & \angled{\Mprom, \angled{\cpath', \PromState, \V', \PromSet}}.
      \end{array}\]
      $\tT \promTStepAcquire \tT'$ by definition. Thus, we need to check $\invCert(n - 1, \delta, k, \aT, \tT')$.
      %% Obviously, it's enough to check $(\delta, \tId, \aT, \tT') \in \invViewDeltaCERT \cap \invViewWriteCERT \cap \invViewReadCERT$.
      Obviously, it's enough to check $\invViewWriteCERT(\tId, \aT, \tT')$ and $\invViewReadCERT(\delta, \tId, \aT, \tT')$.

      Let's first check $\invViewWriteCERT(\tId, \aT, \tT')$.
      \[\begin{array}{l}
  \forall \cpath'' \ge \tT'.\cpath, \loc. \; \aT.\tapef(\tId, \cpath'') = \tapeWrite{(\tapeWriteCommitted{\_}{\loc}{\_})} \Rightarrow \\
  \quad \tT'.\Rcur(\loc) < \aT.\tmap(\tId, \cpath'') \land {} \\
  \quad ((\exists \cpath'''. \; \tT'.\cpath \le \cpath''' < \cpath'' \land 
             \aT.\tapef(\tId, \cpath''') = \tapeFence{\Committed}{\LD}) \Rightarrow \\
  \qquad \tT'.\Racq(\loc) < \aT.\tmap(\tId, \cpath'')).\\
      \end{array}\]
      Simplified:
      \[\begin{array}{l}
  \forall \cpath'' \ge \cpath', \loc. \; \tape(\cpath'') = \tapeWrite{(\tapeWriteCommitted{\_}{\loc}{\_})} \Rightarrow \\
  \quad \Racq(\loc) < \aT.\tmap(\tId, \cpath'') \land {} \\
  \quad ((\exists \cpath'''. \; \cpath' \le \cpath''' < \cpath'' \land 
             \tape(\cpath''') = \tapeFence{\Committed}{\LD}) \Rightarrow \\
  \qquad \Racq(\loc) < \aT.\tmap(\tId, \cpath'')).\\
      \end{array}\]
      Obviously, it's enough to show that
      \[\begin{array}{l}
  \forall \cpath'' \ge \cpath', \loc. \; \tape(\cpath'') = \tapeWrite{(\tapeWriteCommitted{\_}{\loc}{\_})} \Rightarrow \\
  \quad \Racq(\loc) < \aT.\tmap(\tId, \cpath'').
      \end{array}\]
      It directly follows from $\invViewWriteCERT(\tId, \aT, \tT)$ (as $\aT.\tapef(\tId, \cpath) = \tapeFence{\Committed}{\LD}$).

      Let's check $\invViewReadCERT(\delta, \tId, \aT, \tT')$.
      \[\begin{array}{l}
  \forall \cpath'' \ge \tT'.\cpath, \w, \tau. \\
\quad \aT.\tapef(\tId, \cpath'') = \tapeRead{(\tapeSatisfied{\Committed}{\w})} \land
   \angled{\tau, \_} = \deltaHmap(\delta, \tId, \aT, \w.\tId, \w.\cpath) \Rightarrow \\
\qquad \tT'.\Rcur(\w.\loc) \le \tau \land {} \\
\qquad ((\exists \cpath'''. \; \tT'.\cpath \le \cpath''' < \cpath'' \land 
             \aT.\tapef(\tId, \cpath''') = \tapeFence{\Committed}{\LD}) \Rightarrow \tT'.\Racq(\w.\loc) \le \tau). \\
      \end{array}\]
      Simplified:
      \[\begin{array}{l}
  \forall \cpath'' \ge \cpath', \w, \tau. \\
\quad \tape(\cpath'') = \tapeRead{(\tapeSatisfied{\Committed}{\w})} \land
   \angled{\tau, \_} = \deltaHmap(\delta, \tId, \aT, \w.\tId, \w.\cpath) \Rightarrow \\
\qquad \Racq(\w.\loc) \le \tau \land {} \\
\qquad ((\exists \cpath'''. \; \cpath' \le \cpath''' < \cpath'' \land 
             \tape(\cpath''') = \tapeFence{\Committed}{\LD}) \Rightarrow \Racq(\w.\loc) \le \tau). \\
      \end{array}\]
      Obviously, it's enough to show that
      \[\begin{array}{l}
  \forall \cpath'' \ge \cpath', \w, \tau. \\
\quad \tape(\cpath'') = \tapeRead{(\tapeSatisfied{\Committed}{\w})} \land
   \angled{\tau, \_} = \deltaHmap(\delta, \tId, \aT, \w.\tId, \w.\cpath) \Rightarrow \\
\qquad \Racq(\w.\loc) \le \tau.\\
      \end{array}\]
      It directly follows from $\invViewReadCERT(\tId, \aT, \tT)$ (as $\aT.\tapef(\tId, \cpath) = \tapeFence{\Committed}{\LD}$).

  %%     Let's check $\invViewDeltaCERT(\delta, \tId, \aT, \tT')$:
  %%     \[\begin{array}{l}
  %% \textLet \cpath^{\LD}, \cpath^{\SY}, \cpath^{\LD\SY} \triangleq
  %%    \lastLD(\tape, \cpath'), \lastSY(\tape, \cpath'), \lastLDSY(\tape, \cpath') \; \textIn \\
  %% (\Racq \le \bigsqcup \readsCommittedR(\cpath', \tape, \aT.\hmap) \sqcup
  %%                      \bigsqcup \opstau(\tId, \cpath', \tape, \aT.\hmap) \sqcup \\
  %% \quad \deltaToView(\cpath', \delta)) \land {} \\
  %% (\Racq \le \bigsqcup \readsCommittedR(\cpath^{\LD}, \tape, \aT.\hmap) \sqcup
  %%                      \bigsqcup \opstau(\tId, \cpath', \tape, \aT.\hmap) \sqcup \\
  %% \quad \deltaToView(\cpath', \delta)) \land {} \\
  %% (\Rrel \le \bigsqcup \readsCommittedR(\cpath^{\LD\SY}, \tape, \aT.\hmap) \sqcup \bigsqcup \opstau(\tId, \cpath^{\SY}, \tape, \aT.\hmap)).\\
  %%     \end{array}\]
  %%     We know that $\cpath^{\LD} = \cpath$, $\lastSY(\tape, \cpath') = \lastSY(\tape, \cpath)$,
  %%     $\lastLDSY(\tape, \cpath') = \lastLDSY(\tape, \cpath)$, and as $\tape(\cpath)$ isn't a read or a write:
  %%     \[\begin{array}{l}
  %% \textLet \cpath^{\SY}, \cpath^{\LD\SY} \triangleq
  %%    \lastSY(\tape, \cpath), \lastLDSY(\tape, \cpath) \; \textIn \\
  %% (\Racq \le \bigsqcup \readsCommittedR(\cpath, \tape, \aT.\hmap) \sqcup
  %%                      \bigsqcup \opstau(\tId, \cpath, \tape, \aT.\hmap) \sqcup \\
  %% \quad \deltaToView(\cpath, \delta)) \land {} \\
  %% (\Racq \le \bigsqcup \readsCommittedR(\cpath^{\LD}, \tape, \aT.\hmap) \sqcup
  %%                      \bigsqcup \opstau(\tId, \cpath', \tape, \aT.\hmap) \sqcup \\
  %% \quad \deltaToView(\cpath, \delta)) \land {} \\
  %% (\Rrel \le \bigsqcup \readsCommittedR(\cpath^{\LD\SY}, \tape, \aT.\hmap) \sqcup \bigsqcup \opstau(\tId, \cpath^{\SY}, \tape, \aT.\hmap)).\\
  %%     \end{array}\]
  %%     It directly follows from $\invViewDeltaCERT(\delta, \tId, \aT, \tT)$.

    \item $\tape(\cpath) = \tapeRead{(\tapeSatisfied{\Committed}{\w})}$.
      As $\ainit \armStepP^{*} \aT$ and $\tape(\cpath) = \tapeRead{(\tapeSatisfied{\Committed}{\w})}$,
      $\Cprom(\lastInstr{\cpath}) = ``\readInst{\reg}{\expr}"$.
      Some notations:
      \[\begin{array}{l l l}
        \cpath'    & \triangleq & \nextPath{\cpath}{1}; \\
        %% \regstcom  & \triangleq & \regstcom(\aT.\Cfarm(\tId), \tape, \cpath); \\
        \loc       & \triangleq & \semfcom{\expr}{\cpath} \\
                   & =          & \w.\loc \text{ (by \app{\ref{inv:invATapeCfState}})} \\
                   & =          & \semf{\expr}{\PromState} \text{ (by $\invStateCERT(\tId, \aT, \tT)$)}; \\
        \stval  & \triangleq & \w.\stval; \\
        %% \regstcom' & \triangleq & \regstcom(\aT.\Cfarm(\tId), \tape, \cpath') \\
        %%            & =          & \regstcom(\aT.\Cfarm(\tId), \tape, \cpath)[\reg \mapsto \w.\stval] \text{ (by definition)}; \\
        \PromState' & \triangleq & \PromState[\reg \mapsto \stval]. \\
      \end{array}\]
      
      By $\invViewReadCERT(\delta, \tId, \aT, \tT)$, $\exists \tau, \R.$
      $(\tau, \R) \triangleq \deltaHmap(\delta, \aT, \w.\tId, \w.\cpath)$ and \\
      $\Rcur(\loc) \le \tau$.
      $\writeEvt{\loc}{\stval}{\tau}{\R} \in \tT.\Mprom \setminus \tT.\PromSet$
      follows from $\invMemOneCERT(\delta, \tId, \aT, \tT)$ and $\invMemOneCERT(\delta, \tId, \aT, \tT)$.
      
      Denote $\V' = \angled{\Rcur', \Racq', \Rrel'} \triangleq \angled{\Rcur \sqcup [\loc@\tau], \Racq \sqcup \R, \Rrel}.$\\
      Thus, $\tT \promTStepReadLoc \tT' \triangleq \angled{\Mprom, \angled{\cpath', \V', \PromSet}}$.
      
      We need to check $\invCert(n - 1, \delta, k, \aT, \tT')$.
      $(\tId, \aT, \tT') \in \invMemOneCERT \cap \invMemTwoCERT$ follows from 
      $(\tId, \aT, \tT) \in \invMemOneCERT \cap \invMemTwoCERT$.
      $\invStateCERT(\tId, \aT, \tT')$ follows from $\invStateCERT(\tId, \aT, \tT)$ and the definition of $\PromState'$
      as in the $\tapeAssign$ case.
      
      $(\delta, \tId, \aT, \tT') \in \invMemZeroCERT \cap \invDeltaDefOne \cap \invDeltaDefTwo$ follows from
      $(\delta, \tId, \aT, \tT) \in \invMemZeroCERT \cap \invDeltaDefOne \cap \invDeltaDefTwo$.
      
      Let's check $\invViewReadCERT(\delta, \tId, \aT, \tT')$:
      \[\begin{array}{l}
  \forall \cpath'' \ge \tT'.\cpath, \w', \tau'. \\
\quad \aT.\tapef(\tId, \cpath'') = \tapeRead{(\tapeSatisfied{\Committed}{\w'})} \land
   \angled{\tau', \_} = \deltaHmap(\delta, \tId, \aT, \w'.\tId, \w'.\cpath) \Rightarrow \\
\qquad \tT'.\Rcur(\w'.\loc) \le \tau' \land {} \\
\qquad ((\exists \cpath'''. \; \tT'.\cpath \le \cpath''' < \cpath'' \land 
             \aT.\tapef(\tId, \cpath''') = \tapeFence{\Committed}{\LD}) \Rightarrow \tT'.\Racq(\w'.\loc) \le \tau'). \\
      \end{array}\]
      Simplified:
      \[\begin{array}{l}
  \forall \cpath'' \ge \cpath', \w', \tau'. \\
\quad \tape(\cpath'') = \tapeRead{(\tapeSatisfied{\Committed}{\w'})} \land
   \angled{\tau', \_} = \deltaHmap(\delta, \tId, \aT, \w'.\tId, \w'.\cpath) \Rightarrow \\
\qquad (\Rcur \sqcup [\loc @ \tau])(\w'.\loc) \le \tau' \land {} \\
\qquad ((\exists \cpath'''. \; \cpath' \le \cpath''' < \cpath'' \land 
             \tape(\cpath''') = \tapeFence{\Committed}{\LD}) \Rightarrow (\Racq \sqcup \R)(\w'.\loc) \le \tau'). \\
      \end{array}\]
      
      From $\invDeltaDefOne(\delta, \tId, \aT, \tT)$ follows that there are two options:
      either $\aT.\tapef(\w.\tId, \w.\cpath)$ is a committed write, or $\w.\tId = \tId$ and $\delta(\w.\cpath) = (\tau, \R)$.
      \begin{itemize}
        \item $\aT.\tapef(\w.\tId, \w.\cpath)$ is a committed write: \\
      Obviously, it's enough to show the statement for the new parts of views, as for the old parts the statement directly
      follows from $\invViewReadCERT(\delta, \tId, \aT, \tT)$:
      \[\begin{array}{l}
  \forall \cpath'' \ge \cpath', \w', \tau'. \\
\quad \tape(\cpath'') = \tapeRead{(\tapeSatisfied{\Committed}{\w'})} \land
   \angled{\tau', \_} = \deltaHmap(\delta, \tId, \aT, \w'.\tId, \w'.\cpath) \Rightarrow \\
\qquad [\loc @ \tau](\w'.\loc) \le \tau' \land {} \\
\qquad ((\exists \cpath'''. \; \cpath' \le \cpath''' < \cpath'' \land 
             \tape(\cpath''') = \tapeFence{\Committed}{\LD}) \Rightarrow \aT.\rmap(\w.\tId, \w.\cpath)(\w'.\loc) \le \tau'). \\
      \end{array}\]

      Fix $\cpath'', \w', \tau'$. We need to show:
      \[\begin{array}{l}
        [\loc @ \tau](\w'.\loc) \le \tau' \land {} \\
        ((\exists \cpath'''. \; \cpath' \le \cpath''' < \cpath'' \land 
             \tape(\cpath''') = \tapeFence{\Committed}{\LD}) \Rightarrow \aT.\rmap(\w.\tId, \w.\cpath)(\w'.\loc) \le \tau'). \\
      \end{array}\]
      From $\invDeltaDefOne(\delta, \tId, \aT, \tT)$ follows that there are two options:
      either $\aT.\tapef(\w'.\tId, \w'.\cpath)$ is a committed write, or $\w'.\tId = \tId$ and $\delta(\w'.\cpath) = (\tau', \_)$.
      In the first case, the statement holds by \app{\ref{thm:invAview}}. Consider the second option.
      
      Let's check the first conjunct. If $\w'.\loc \not = \loc$, it might be simplified to $0 \le \tau'$, which holds.
      Suppose, $\w'.\loc = \loc$.
      We know that $\w'.\cpath < \cpath$ from $\delta(\w'.\cpath) \not = \bot$ and $\invCert(n, \delta, k, \aT, \tT)$.
      We also know that $\cpath < \cpath''$. By \app{\ref{inv:invAReadRead}}, $\w = \w'$, so $\tau = \tau'$.
      
      Now let's check the second conjunct:
      \[\begin{array}{l}
        (\exists \cpath'''. \; \cpath' \le \cpath''' < \cpath'' \land 
             \tape(\cpath''') = \tapeFence{\Committed}{\LD}) \Rightarrow \aT.\rmap(\w.\tId, \w.\cpath)(\w'.\loc) \le \tau'. \\
      \end{array}\]
      
      Fix $\cpath'''$ and rename it to $\cpath_{LD}$.
      Then we know that
      \[\begin{array}{l}
      \cpath_{\delta} \triangleq \w'.\cpath < \cpath < \cpath' \le \cpath_{LD} < \cpath_{\delta-read} \triangleq \cpath''.
      \end{array}\]
      %% By $\invDeltaDefFour(\delta, \tId, \aT)$, the statement holds.

      $\aT.\rmap(\w.\tId, \w.\cpath)(\w'.\loc) \le \tau'$ holds by $\invDeltaDefFour(\delta, \tId, \aT)$.

        \item $\w.\tId = \tId$ and $\delta(\cpath) = (\tau, \R)$: \\
          $\R = [\loc @ \tau] \sqcup \Rrel$ by $\invDeltaDefTwo(\delta, \tId, \aT, \tT)$.
          We know that $[\loc @ \tau] \le \Rcur$ (from $\invDeltaDefTwo(\delta, \tId, \aT, \tT)$) and $\Rrel \le \Rcur \le \Racq$
          (by an invariant of the Promise machine), so $\Racq \sqcup [\loc @ \tau] \sqcup \Rrel = \Racq$ and
          $\Rcur \sqcup [\loc @ \tau] = \Rcur$.
          Thus, we can simplify the statement we want to prove:
      \[\begin{array}{l}
  \forall \cpath'' \ge \cpath', \w', \tau'. \\
\quad \tape(\cpath'') = \tapeRead{(\tapeSatisfied{\Committed}{\w'})} \land
   \angled{\tau', \_} = \deltaHmap(\delta, \tId, \aT, \w'.\tId, \w'.\cpath) \Rightarrow \\
\qquad \Rcur(\w'.\loc) \le \tau' \land {} \\
\qquad ((\exists \cpath'''. \; \cpath' \le \cpath''' < \cpath'' \land 
             \tape(\cpath''') = \tapeFence{\Committed}{\LD}) \Rightarrow \Racq(\w'.\loc) \le \tau'). \\
      \end{array}\]
      It directly follows from $\invViewReadCERT(\delta, \tId, \aT, \tT)$.
      \end{itemize}

      Let's check $\invViewWriteCERT(\tId, \aT, \tT')$:
      \[\begin{array}{l}
        \forall \cpath'' \ge \tT'.\cpath, \loc'. \aT.\tapef(\tId, \cpath'') = \tapeWrite{(\tapeWriteCommitted{\_}{\loc}{\_})} \Rightarrow \\
        \quad \tT'.\Rcur(\loc') < \aT.\tmap(\tId, \cpath'') \land {} \\
        \quad ((\exists \cpath'''. \; \tT'.\cpath \le \cpath''' < \cpath'' \land 
             \aT.\tapef(\tId, \cpath''') = \tapeFence{\Committed}{\LD}) \Rightarrow \\
        \qquad \tT'.\Racq(\loc') < \aT.\tmap(\tId, \cpath'')).\\
      \end{array}\]
      Simplified:
      \[\begin{array}{l}
        \forall \cpath'' \ge \cpath', \loc'. \tape(\cpath'') = \tapeWrite{(\tapeWriteCommitted{\_}{\loc}{\_})} \Rightarrow \\
        \quad (\Rcur \sqcup [\loc @ \tau])(\loc') < \aT.\tmap(\tId, \cpath'') \land {} \\
        \quad ((\exists \cpath'''. \; \cpath' \le \cpath''' < \cpath'' \land 
             \tape(\cpath''') = \tapeFence{\Committed}{\LD}) \Rightarrow \\
        \qquad (\Racq \sqcup \R)(\loc') < \aT.\tmap(\tId, \cpath'')).\\
      \end{array}\]
      
      From $\invDeltaDefOne(\delta, \tId, \aT, \tT)$ follows that there are two options:
      either $\aT.\tapef(\w.\tId, \w.\cpath)$ is a committed write, or $\w.\tId = \tId$ and $\delta(\w.\cpath) = (\tau, \R)$.
      
      \begin{itemize}
        \item $\aT.\tapef(\w.\tId, \w.\cpath)$ is a committed write: \\
      Obviously, it's enough to show the statement for the new parts of views, as for the old parts the statement directly
      follows from $\invViewWriteCERT(\delta, \tId, \aT, \tT)$:
      \[\begin{array}{l}
        \forall \cpath'' \ge \cpath', \loc'. \tape(\cpath'') = \tapeWrite{(\tapeWriteCommitted{\_}{\loc}{\_})} \Rightarrow \\
        \quad [\loc @ \tau](\loc') < \aT.\tmap(\tId, \cpath'') \land {} \\
        \quad ((\exists \cpath'''. \; \cpath' \le \cpath''' < \cpath'' \land 
             \tape(\cpath''') = \tapeFence{\Committed}{\LD}) \Rightarrow \\
        \qquad \R(\loc') < \aT.\tmap(\tId, \cpath'')).\\
      \end{array}\]
      It directly follows from \app{\ref{thm:invAview}}.

        \item $\w.\tId = \tId$ and $\delta(\cpath) = (\tau, \R)$: \\
          $\R = [\loc @ \tau] \sqcup \Rrel$ by $\invDeltaDefTwo(\delta, \tId, \aT, \tT)$.
          We know that $[\loc @ \tau] \le \Rcur$ (from $\invDeltaDefTwo(\delta, \tId, \aT, \tT)$) and $\Rrel \le \Rcur \le \Racq$
          (by an invariant of the Promise machine), so $\Racq \sqcup [\loc @ \tau] \sqcup \Rrel = \Racq$ and
          $\Rcur \sqcup [\loc @ \tau] = \Rcur$.
          Thus, we can simplify the statement we want to prove:
      \[\begin{array}{l}
        \forall \cpath'' \ge \cpath', \loc'. \tape(\cpath'') = \tapeWrite{(\tapeWriteCommitted{\_}{\loc}{\_})} \Rightarrow \\
        \quad \Rcur(\loc') < \aT.\tmap(\tId, \cpath'') \land {} \\
        \quad ((\exists \cpath'''. \; \cpath' \le \cpath''' < \cpath'' \land 
             \tape(\cpath''') = \tapeFence{\Committed}{\LD}) \Rightarrow \\
        \qquad \Racq(\loc') < \aT.\tmap(\tId, \cpath'')).\\
      \end{array}\]
      It directly follows from $\invViewWriteCERT(\delta, \tId, \aT, \tT)$.

      \end{itemize}
      
    \item $\tape(\cpath) = \tapeRead{\Rstate}$, where $\Rstate$ isn't a committed one. \\
      As $\ainit \armStepP^{*} \aT$ and $\tape(\cpath) = \tapeRead{\Rstate}$,
      $\Cprom(\lastInstr{\cpath}) = ``\readInst{\reg}{\expr}"$.
      Some notations:
      \[\begin{array}{l l l}
        \cpath'    & \triangleq & \nextPath{\cpath}{1}; \\
        \regstcom  & \triangleq & \regstcom(\Cprom, \tape, \cpath); \\
        \regstcom' & \triangleq & \regstcom(\Cprom, \tape, \cpath') \\
                   & =          & \regstcom(\Cprom, \tape, \cpath)[\reg \mapsto \bot] \text{ (by definition)}; \\
        \loc       & \triangleq & \semfcom{\expr}{\cpath} \\
                   & =          & \semf{\expr}{\PromState} \text{ (by $\invStateCERT(\tId, \aT, \tT)$)}; \\
        \tau       & \triangleq & \Rcur(\loc). \\
      \end{array}\]

      From properties of the Promise machine, $\exists \stval, \R. \; \writeEvt{\loc}{\stval}{\tau}{\R} \in \Mprom$. \\
      \[\begin{array}{l l l}
      \V' = \angled{\Rcur', \Racq', \Rrel'} & \triangleq & \angled{\Rcur \sqcup [\loc @ \tau], \Racq \sqcup \R, \Rrel} \\
                                            & =          & \angled{\Rcur, \Racq \sqcup \R, \Rrel}; \\
      \PromState' & \triangleq & \PromState[\reg \mapsto \stval].
      \end{array}\]
      
      By definition, $\tT \promTStepReadLoc \tT' \triangleq \angled{\Mprom, \angled{\cpath', \PromState', \V', \PromSet}}$.
      We need to check $\invCert(n - 1, \delta, k, \aT, \tT')$.

      $(\tId, \aT, \tT') \in \invMemOneCERT \cap \invMemTwoCERT \cap \invViewRelCERT$ follows from 
      $(\tId, \aT, \tT) \in \invMemOneCERT \cap \invMemTwoCERT \cap \invViewRelCERT$.
      $\invStateCERT(\tId, \aT, \tT')$ follows from $\invStateCERT(\tId, \aT, \tT)$ and definitions of
      $\PromState' \triangleq \PromState[\reg \mapsto \stval]$ and $\regstcom'$.

      $(\delta, \tId, \aT, \tT') \in \invMemZeroCERT \cap \invDeltaDefOne \cap \invDeltaDefTwo$ follows from
      $(\delta, \tId, \aT, \tT) \in \invMemZeroCERT \cap \invDeltaDefOne \cap \invDeltaDefTwo$ and
      $\Rcur' = \Rcur, \Rrel' = \Rrel$.

      We know that there is no $\cpath'' > \cpath$, such that $\tape(\cpath'') = \tapeFence{\Committed}{\LD}$, so
      we'll be able to drop parts of the invariants, which are related to committed fences.
      So, $(\delta, \tId, \aT, \tT') \in \invViewReadCERT \cap \invViewWriteCERT(\tId, \aT, \tT')$ follow from
      $(\delta, \tId, \aT, \tT') \in \invViewReadCERT(\delta, \tId, \aT, \tT) \cap \invViewWriteCERT(\tId, \aT, \tT)$,
      and $\Rcur' = \Rcur$.
      
    \item $\tape(\cpath) = \tapeWrite{(\tapeWriteCommitted{\InMemory}{\loc}{\stval})}$. \\
      As $\ainit \armStepP^{*} \aT$ and $\tape(\cpath) = \tapeWrite{(\tapeWriteCommitted{\InMemory}{\loc}{\stval})}$,
      $\Cprom(\lastInstr{\cpath}) = ``\writeInst{\expr_0}{\expr_1}"$.
      Some notations:
      \[\begin{array}{l l l}
        \cpath'    & \triangleq & \nextPath{\cpath}{1}; \\
        \regstcom  & \triangleq & \regstcom(\Cprom, \tape, \cpath); \\
        \angled{\tau, \_, \R'} & \triangleq & \aT.\hmap(\tId, \cpath)
          \text{ (it's defined according to properties of the $\ARMt$ machine)}. \\

      \end{array}\]
      
      By \app{\ref{inv:invATapeCfState}} and $\invStateCERT(\tId, \aT, \tT)$ we know that
      $\loc = \semfcom{\expr_0}{\cpath} = \semf{\expr_0}{\PromState}$ and
      $\stval = \semfcom{\expr_1}{\cpath} = \semf{\expr_1}{\PromState}$. \\
      
      From $\invMemOneCERT(\tId, \aT, \tT)$ we know that \\
      $\exists \R \le \R'. \; \writeEvt{\loc}{\stval}{\tau}{\R} \in \tT.\PromSet \cap \tT.\Mprom$.
      $\Rcur(\loc) < \tau$ follows from $\invViewWriteCERT(\tId, \aT, \tT)$.
      \[\begin{array}{l l l}
        \V' & \triangleq & \angled{\Rcur \sqcup [\loc @ \tau], \Racq \sqcup [\loc @ \tau], \Rrel}; \\
        \PromSet' & \triangleq & \PromSet \setminus \{\writeEvt{\loc}{\stval}{\tau}{\R}\}. \\
      \end{array}\]
      Thus, $\tT \promTStepFulfillLoc \tT' \triangleq \angled{\Mprom, \angled{\cpath', \PromState, \V', \PromSet'}}$.
      We need to check $\invCert(n - 1, \delta, k, \aT, \tT')$.
      \begin{itemize}
        \item $(\tId, \aT, \tT') \in \invMemOneCERT \cap \invMemTwoCERT(\tId, \aT, \tT')$: \\
          It's trivially holds for the fulfilled write and for the other writes.
        \item $(\tId, \aT, \tT') \in \invStateCERT \cap \invViewRelCERT$: \\
          It holds as $\tT'.\PromState = \tT.\PromState$,
          $\regstcom(\Cprom, \tape, \cpath) = \regstcom(\Cprom, \tape, \cpath')$,
          and $\tT'.\Rrel = \tT.\Rrel$.
        \item $\invMemZeroCERT(\delta, \tId, \aT, \tT')$: \\
          We need to show that
          \[\begin{array}{l}
      \forall \cpath'', \tau', \R', \loc', \expr'_0, \expr'_1. \\
\quad \angled{\tau', \R'} = \delta(\cpath'') \land ``\writeInst{\expr'_0}{\expr'_1}" = \Cprom(\lastInstr{\cpath''}) \land
      \loc' = \semfcom{\expr'_0}{\cpath''} \Rightarrow \\
\quad \exists \stval'. \semfcom{\expr'_1}{\cpath''} \in \{\bot, \stval'\} \land
      \writeEvt{\loc'}{\stval'}{\tau'}{\R'} \in \tT'.\Mprom \setminus \tT'.\PromSet. \\
          \end{array}\]
          Fix $\cpath''$ and do minor simplifications:
      %% \forall \cpath'', \angled{\tau', \R'} = \delta(\cpath''), \\
      %% \quad ``\writeInst{\expr'_0}{\expr'_1}" = \aT.\Cfarm(\tId, \lastInstr{\cpath''}), \loc' = \semfcom{\expr'_0}{\cpath''}. \\
          \[\begin{array}{l}
      \exists \stval'. \semfcom{\expr'_1}{\cpath''} \in \{\bot, \stval'\} \land
      \writeEvt{\loc'}{\stval'}{\tau'}{\R'} \in \Mprom \setminus (\PromSet \cup \{\writeEvt{\loc}{\stval}{\tau}{\R}\}). \\
          \end{array}\]
      Suppose, $\cpath'' = \cpath$. By $\invDeltaDefOne(\delta, \tId, \aT, \tT)$, $\tape(\cpath)$ isn't committed. Contradiction.
      So, $\cpath'' \not = \cpath$.
      From $\invDeltaDefThree(\delta, \tId, \aT)$ we know that $(\loc, \tau) \not = (\loc', \tau')$, so we may simplify the
      statement:
          \[\begin{array}{l}
      \exists \stval'. \semfcom{\expr'_1}{\cpath''} \in \{\bot, \stval'\} \land
      \writeEvt{\loc'}{\stval'}{\tau'}{\R'} \in \Mprom \setminus \PromSet. \\
          \end{array}\]
      which directly follows from $\invMemZeroCERT(\delta, \tId, \aT, \tT)$.

        \item $\invDeltaDefOne(\delta, \tId, \aT, \tT')$: \\
          $\delta(\cpath) = \bot$, $\tape(\cpath)$ is committed, so the statement holds.
        \item $\invDeltaDefTwo(\delta, \tId, \aT, \tT')$: \\
          We need to show that
          \[\begin{array}{l}
\forall \cpath', \angled{\tau', \R'} = \delta(\cpath'), \\
\quad ``\writeInst{\expr'_0}{\expr'_1}" = \Cprom(\lastInstr{\cpath'}), \loc' = \semfcom{\expr'_0}{\cpath'}. \\
\qquad \R' = [\loc' @ \tau'] \sqcup \tT'.\Rrel \land \tT'.\Rcur(\loc') \ge \tau'. \\
          \end{array}\]
          Simplified:
          \[\begin{array}{l}
\forall \cpath', \angled{\tau', \R'} = \delta(\cpath'), \\
\quad ``\writeInst{\expr'_0}{\expr'_1}" = \Cfarm(\lastInstr{\cpath'}), \loc' = \semfcom{\expr'_0}{\cpath'}. \\
\qquad \R' = [\loc' @ \tau'] \sqcup \tT.\Rrel \land [\loc @ \tau] \sqcup \tT.\Rcur(\loc') \ge \tau'. \\
          \end{array}\]
          It directly follows from $\invDeltaDefTwo(\delta, \tId, \aT, \tT')$.
          
          \item $\invViewWriteCERT(\tId, \aT, \tT')$: \\
            We need to show:
            \[\begin{array}{l}
      \forall \cpath'' \ge \tT'.\cpath, \loc'. \; \aT.\tapef(\tId, \cpath'') = \tapeWrite{(\tapeWriteCommitted{\_}{\loc'}{\_})} \Rightarrow \\
      \quad \tT'.\Rcur(\loc') < \aT.\tmap(\tId, \cpath'') \land {} \\
      \quad ((\exists \cpath'''. \; \tT'.\cpath \le \cpath''' < \cpath'' \land 
             \aT.\tapef(\tId, \cpath''') = \tapeFence{\Committed}{\LD}) \Rightarrow \\
      \qquad \tT'.\Racq(\loc') < \aT.\tmap(\tId, \cpath'')).\\
            \end{array}\]
            Simplified:
            \[\begin{array}{l}
      \forall \cpath'' \ge \cpath', \loc'. \; \tape(\cpath'') = \tapeWrite{(\tapeWriteCommitted{\_}{\loc'}{\_})} \Rightarrow \\
      \quad (\Rcur \sqcup [\loc @ \tau])(\loc') < \aT.\tmap(\tId, \cpath'') \land {} \\
      \quad ((\exists \cpath'''. \; \cpath' \le \cpath''' < \cpath'' \land 
             \tape(\cpath''') = \tapeFence{\Committed}{\LD}) \Rightarrow \\
      \qquad (\Racq \sqcup [\loc @ \tau])(\loc') < \aT.\tmap(\tId, \cpath'')).\\
            \end{array}\]
            As $\invViewWriteCERT(\tId, \aT, \tT)$ holds, it's enough to show that:
            \[\begin{array}{l}
      \forall \cpath'' \ge \cpath', \loc'. \; \tape(\cpath'') = \tapeWrite{(\tapeWriteCommitted{\_}{\loc'}{\_})} \Rightarrow \\
      \quad [\loc @ \tau](\loc') < \aT.\tmap(\tId, \cpath'').
            \end{array}\]
            It follows from \app{\ref{thm:invAview}}.
          \item $\invViewReadCERT(\tId, \aT, \tT')$: \\
            The same proof as for $\invViewWriteCERT(\tId, \aT, \tT')$.
      \end{itemize}

    \item $\tape(\cpath) = \tapeWrite{\Wstate}$, where $\Wstate$ isn't a committed one. \\
      In this case we are going to make two steps via the Promise thread $\tId$: to promise a write
      and to fulfill it.
      As $\ainit \armStepP^{*} \aT$ and $\tape(\cpath) = \tapeWrite{\Wstate}$,
      $\Cprom(\lastInstr{\cpath}) = ``\writeInst{\expr_0}{\expr_1}"$.
      Some notations:
      \[\begin{array}{l l l}
        \cpath'    & \triangleq & \nextPath{\cpath}{1}; \\
        \regstcom  & \triangleq & \regstcom(\Cprom, \tape, \cpath); \\
        \loc       & \triangleq &
          \semfcom{\expr_0}{\cpath} \text{ (addresses are defined according to $\invCert(n, \delta, k, \tId, \aT, \tT)$)} \\
                   & =          & \semf{\expr_0}{\PromState} \text{ (by $\invStateCERT(\tId, \aT, \tT)$)}; \\
        \stval       & \triangleq & \semf{\expr_1}{\PromState}. \\
        %% \angled{\tau, \_, \R'} & \triangleq & \aT.\hmap(\tId, \cpath)
        %%   \text{ (it's defined according to properties of the $\ARMt$ machine)}. \\
      \end{array}\]
      The most sophisticated part of this case is to choose a timestamp for the write properly.
      Let's denote it $\tau$. The following statements have to hold:
      \[\begin{array}{l l}
        1. & \Rcur(\loc) < \tau. \\
        2. & \tau \not \in \{\tau' | \stRequestWrite{\loc}{\_}{\tau'}{\_} \in \Mprom \}. \\
        3. & \forall \cpath_{write} \ge \cpath. \; \tape(\cpath_{write}) = \tapeWrite{(\tapeWriteCommitted{\_}{\loc}{\_})} \Rightarrow \\
           &  \quad \tau < \aT.\tmap(\tId, \cpath_{write}). \\
        4. & \forall \cpath_{read} \ge \cpath. \; \tape(\cpath_{read}) = \tapeRead{(\tapeSatisfied{\Committed}{\w})} \land
                 \aT.\tmap(\w.\tId, \w.\cpath) \not = \bot \Rightarrow \\
           & \quad \tau \le \aT.\tmap(\w.\tId, \w.\cpath). \\
        5. & \forall \cpath_{read} < \cpath_{\LD} < \cpath_{\delta-read}, \w, \R. \cpath < \cpath_{read} \land {} \\
           & \quad \tape(\cpath_{read}) = \tapeRead{(\tapeSatisfied{\Committed}{\w})} \land
             \tape(\cpath_{\LD}) = \tapeFence{\Committed}{\LD} \land {} \\
           & \quad \tape(\cpath_{\delta-read}) = \tapeRead{(\tapeSatisfied{\Committed}{\stRequestWrite{\tId}{\cpath}\loc}{\_})} \land {} \\
           & \quad \R = \aT.\rmap(\w.\tId, \w.\cpath) \not = \bot \Rightarrow \\
           & \qquad \R(\loc) \le \tau. \\
      \end{array}\]
      Because timestamps are elements of $\mathbb{Q}^{+}$ (a dense order), by $\invViewWriteCERT(\tId, \aT, \tT)$,
      $\invViewReadCERT(\delta, \tId, \aT, \tT)$, and \app{\ref{thm:invAview}}, there is $\tau$, which satisfies the requirements.

      Some notations:
      \[\begin{array}{l l l}
        \R  & \triangleq & \Rrel \sqcup [\loc @ \tau]; \\
        msg & \triangleq & \writeEvt{\loc}{\stval}{\tau}{\R}; \\
        \Mprom' & \triangleq & \Mprom \cup \{msg\};\\
        \V' = \angled{\Rcur', \Racq', \Rrel'} & \triangleq & \angled{\Rcur \sqcup [\loc @ \tau], \Racq \sqcup [\loc @ \tau], \Rrel}; \\
        \delta' & \triangleq & \delta[\cpath \mapsto \angled{\tau, \R}].\\ 
      \end{array}\]
      Then the following holds:
      \[\begin{array}{l l l}
        \tT & \promTStepPromiseLoc & \angled{\Mprom', \angled{\cpath , \PromState, \V, \PromSet \cup \{msg\}}} \\
            & \promTStepFulfillLoc & \tT' \triangleq \angled{\Mprom', \angled{\cpath', \PromState, \V', \PromSet}}. \\
      \end{array}\]
      We have to show $\invCert(n - 1, \delta', k, \tId, \aT, \tT')$ holds.
      
      \begin{itemize}
        \item $\invMemOneCERT(\tId, \aT, \tT')$: \\
          The statement obviously holds as $\invMemOneCERT(\tId, \aT, \tT)$ holds and $\aT.\hmap(\tId, \cpath) = \bot$.
        \item $\invMemTwoCERT(\tId, \aT, \tT')$: \\
          $\tT'.\PromSet = \tT.\PromSet$, $\tape(\cpath) \not = \tapeWrite{(\tapeWriteCommitted{\_}{\_}{\_})}$,
          so the statement holds.
        \item $\invStateCERT(\tId, \aT, \tT')$: \\
          $\tT'.\PromState = \tT.\PromState$, $\regstcom(\dots, \cpath) = \regstcom(\dots, \cpath')$, so the statement holds.

        \item $\invViewRelCERT(\tId, \aT, \tT')$: \\
          $\tT'.\Rrel = \tT.\Rrel$, so the statement holds.

        \item $\invViewWriteCERT(\tId, \aT, \tT')$: \\
          We need to show that
          \[\begin{array}{l}
            \forall \cpath'' \ge \tT'.\cpath, \loc'. \;
              \aT.\tapef(\tId, \cpath'') = \tapeWrite{(\tapeWriteCommitted{\_}{\loc'}{\_})} \Rightarrow \\
          \qquad \tT'.\Rcur(\loc') < \aT.\tmap(\tId, \cpath'') \land {} \\
          \qquad ((\exists \cpath'''. \; \tT'.\cpath \le \cpath''' < \cpath'' \land 
                       \aT.\tapef(\tId, \cpath''') = \tapeFence{\Committed}{\LD}) \Rightarrow \\
          \qquad \quad \tT'.\Racq(\loc') < \aT.\tmap(\tId, \cpath'')).\\
          \end{array}\]
          Simplified:
          \[\begin{array}{l}
            \forall \cpath'' \ge \cpath', \loc'. \;
              \aT.\tapef(\tId, \cpath'') = \tapeWrite{(\tapeWriteCommitted{\_}{\loc'}{\_})} \Rightarrow \\
          \qquad ([\loc @ \tau] \sqcup \Rcur)(\loc') < \aT.\tmap(\tId, \cpath'') \land {} \\
          \qquad ((\exists \cpath'''. \; \cpath' \le \cpath''' < \cpath'' \land 
                       \tape(\cpath''') = \tapeFence{\Committed}{\LD}) \Rightarrow \\
          \qquad \quad ([\loc @ \tau] \sqcup \Racq)(\loc') < \aT.\tmap(\tId, \cpath'')).\\
          \end{array}\]
          Obviously, it's enough to check only the following:
          \[\begin{array}{l}
            \forall \cpath'' \ge \cpath', \loc'. \;
              \aT.\tapef(\tId, \cpath'') = \tapeWrite{(\tapeWriteCommitted{\_}{\loc'}{\_})} \Rightarrow \\
          \qquad [\loc @ \tau](\loc') < \aT.\tmap(\tId, \cpath'') \land {} \\
          \qquad ((\exists \cpath'''. \; \cpath' \le \cpath''' < \cpath'' \land 
                       \tape(\cpath''') = \tapeFence{\Committed}{\LD}) \Rightarrow \\
          \qquad \quad [\loc @ \tau](\loc') < \aT.\tmap(\tId, \cpath'')).\\
          \end{array}\]
          If $\loc' \not = \loc$, then the statement holds as $[\loc @ \tau](\loc') = 0$.
          If $\loc' = \loc$, the statement is guaranteed by the way we have chosen $\tau$.

        \item $\invMemZeroCERT(\delta', \tId, \aT, \tT')$: \\
          We need to show that
          \[\begin{array}{l}
      \forall \cpath'', \tau', \R', \loc', \expr'_0, \expr'_1. \\
\quad \angled{\tau', \R'} = \delta'(\cpath'') \land ``\writeInst{\expr'_0}{\expr'_1}" = \Cprom(\lastInstr{\cpath''}) \land
      \loc' = \semfcom{\expr'_0}{\cpath''} \Rightarrow \\
\quad \exists \stval'. \semfcom{\expr'_1}{\cpath''} \in \{\bot, \stval'\} \land
      \writeEvt{\loc'}{\stval'}{\tau'}{\R'} \in \tT'.\Mprom \setminus \tT'.\PromSet. \\
          \end{array}\]
          Fix $\cpath''$ and do minor simplifications:
      %% \forall \cpath'', \angled{\tau', \R'} = \delta(\cpath''), \\
      %% \quad ``\writeInst{\expr'_0}{\expr'_1}" = \aT.\Cfarm(\tId, \lastInstr{\cpath''}), \loc' = \semfcom{\expr'_0}{\cpath''}. \\
          \[\begin{array}{l}
      \exists \stval'. \semfcom{\expr'_1}{\cpath''} \in \{\bot, \stval'\} \land
      \writeEvt{\loc'}{\stval'}{\tau'}{\R'} \in (\Mprom \setminus \PromSet) \cup \{\writeEvt{\loc}{\stval}{\tau}{\R}\}. \\
          \end{array}\]
          If $\cpath'' \not = \cpath$, then $\delta'(\cpath'') = \delta(\cpath'')$ and the statement holds by
          $\invMemZeroCERT(\delta, \tId, \aT, \tT)$.
          If $\cpath'' = \cpath$, then the statement obviously holds.

        \item $\invDeltaDefOne(\delta', \tId, \aT, \tT')$: \\
          We need to show that
          \[\begin{array}{l}
            \forall \cpath'' < \tT'.\cpath. \; \delta'(\cpath'') \not = \bot \Leftrightarrow \\
            \quad (\exists \expr'_0, \expr'_1. \; ``\writeInst{\expr'_0}{\expr'_1}" = \Cprom(\lastInstr{\cpath''})
              \land {} \\
            \qquad \aT.\tapef(\tId, \cpath'') \text{ isn't committed}). \\
          \end{array}\]
          Simplified:
          \[\begin{array}{l}
            \forall \cpath'' < \cpath'. \; \delta'(\cpath'') \not = \bot \Leftrightarrow \\
            \quad (\exists \expr'_0, \expr'_1. \; ``\writeInst{\expr'_0}{\expr'_1}" = \Cprom(\lastInstr{\cpath''})
              \land {} \\
            \qquad \tape(\cpath'') \text{ isn't committed}). \\
          \end{array}\]
          If $\cpath'' \not = \cpath$, then $\delta'(\cpath'') = \delta(\cpath'')$, and the statement holds as
          $\invDeltaDefOne(\delta, \tId, \aT, \tT)$ holds.
          If $\cpath'' \not = \cpath$, then the statement holds by definition of $\delta'$.

        \item $\invDeltaDefTwo(\delta', \tId, \aT, \tT')$: \\
          We need to show that
          \[\begin{array}{l}
            \forall \cpath'', \angled{\tau', \R'} = \delta'(\cpath''), \\
            \quad ``\writeInst{\expr'_0}{\expr'_1}" = \Cprom(\lastInstr{\cpath''}), \loc' = \semfcom{\expr'_0}{\cpath''}. \\
            \qquad \R' = [\loc' @ \tau'] \sqcup \tT'.\Rrel \land \tT'.\Rcur(\loc') \ge \tau'. \\
          \end{array}\]
          Simplified:
          \[\begin{array}{l}
            \forall \cpath'', \angled{\tau', \R'} = \delta'(\cpath''), \\
            \quad ``\writeInst{\expr'_0}{\expr'_1}" = \Cprom(\lastInstr{\cpath''}), \loc' = \semfcom{\expr'_0}{\cpath''}. \\
            \qquad \R' = [\loc' @ \tau'] \sqcup \Rrel \land ([\loc @ \tau] \sqcup \Rcur)(\loc') \ge \tau'. \\
          \end{array}\]
          Fix $\cpath''$. If $\cpath'' \not = \cpath$, then $\delta'(\cpath'') = \delta(\cpath'')$, and the statement holds as
          $\invDeltaDefTwo(\delta, \tId, \aT, \tT)$ holds.
          If $\cpath'' = \cpath$, then the statement obviously holds by construction of $\delta'$.

        \item $\invViewReadCERT(\delta', \tId, \aT, \tT')$: \\
          \[\begin{array}{l}
            \forall \cpath'' \ge \tT'.\cpath, \w', \tau'. \\
            \quad \aT.\tapef(\tId, \cpath'') = \tapeRead{(\tapeSatisfied{\Committed}{\w'})} \land
               \angled{\tau', \_} = \deltaHmap(\delta', \tId, \aT, \w'.\tId, \w'.\cpath) \Rightarrow \\
            \qquad \tT'.\Rcur(\w'.\loc) \le \tau' \land {} \\
            \qquad ((\exists \cpath'''. \; \tT'.\cpath \le \cpath''' < \cpath'' \land 
                         \aT.\tapef(\tId, \cpath''') = \tapeFence{\Committed}{\LD}) \Rightarrow \tT'.\Racq(\w'.\loc) \le \tau'). \\
          \end{array}\]
          Simplified:
          \[\begin{array}{l}
            \forall \cpath'' \ge \cpath', \w', \tau'. \\
            \quad \tape(\cpath'') = \tapeRead{(\tapeSatisfied{\Committed}{\w'})} \land
               \angled{\tau', \_} = \deltaHmap(\delta', \tId, \aT, \w'.\tId, \w'.\cpath) \Rightarrow \\
            \qquad ([\loc @ \tau] \sqcup \Rcur)(\w'.\loc) \le \tau' \land {} \\
            \qquad ((\exists \cpath'''. \; \tT'.\cpath \le \cpath''' < \cpath'' \land 
                         \tape(\cpath''') = \tapeFence{\Committed}{\LD}) \Rightarrow
                         ([\loc @ \tau] \sqcup \Racq)(\w'.\loc) \le \tau'). \\
          \end{array}\]
          Fix $\cpath'', \w', \tau'$.
          As $\deltaHmap(\delta', \tId, \aT, \w'.\tId, \w'.\cpath) \not = \bot$,
          either $\aT.\tapef(\w'.\tId, \w'.\cpath)$ is a committed write, or $\w'.\tId = \tId$ and
          $\delta'(\w'.\cpath) \not = \bot$.
          \begin{itemize}
            \item $\aT.\tapef(\w'.\tId, \w'.\cpath)$ is a committed write: \\
              We may simplify the statement:
          \[\begin{array}{l}
            \tape(\cpath'') = \tapeRead{(\tapeSatisfied{\Committed}{\w'})} \land
               \tau' = \aT.\tmap(\w'.\tId, \w'.\cpath) \Rightarrow \\
            \quad ([\loc @ \tau] \sqcup \Rcur)(\w'.\loc) \le \tau' \land {} \\
            \quad ((\exists \cpath'''. \; \tT'.\cpath \le \cpath''' < \cpath'' \land 
                         \tape(\cpath''') = \tapeFence{\Committed}{\LD}) \Rightarrow
                         ([\loc @ \tau] \sqcup \Racq)(\w'.\loc) \le \tau'). \\
          \end{array}\]
          As $\invViewReadCERT(\delta, \tId, \aT, \tT)$ holds, it's enough to check that:
          \[\begin{array}{l}
            \tape(\cpath'') = \tapeRead{(\tapeSatisfied{\Committed}{\w'})} \land
               \tau' = \aT.\tmap(\w'.\tId, \w'.\cpath) \Rightarrow \\
            \quad [\loc @ \tau](\w'.\loc) \le \tau' \land {} \\
            \quad ((\exists \cpath'''. \; \tT'.\cpath \le \cpath''' < \cpath'' \land 
                         \tape(\cpath''') = \tapeFence{\Committed}{\LD}) \Rightarrow
                         [\loc @ \tau](\w'.\loc) \le \tau'). \\
          \end{array}\]
          Or even simplier:
          \[\begin{array}{l}
            \tape(\cpath'') = \tapeRead{(\tapeSatisfied{\Committed}{\w'})} \land
               \tau' = \aT.\tmap(\w'.\tId, \w'.\cpath) \Rightarrow \\
            \quad [\loc @ \tau](\w'.\loc) \le \tau'. \\
          \end{array}\]
          This is guaranteed by the way we have chosen $\tau$.
          
            \item $\w'.\tId = \tId$ and $\delta'(\w'.\cpath) \not = \bot$: \\
              We may simplify the statement:
          \[\begin{array}{l}
            \tape(\cpath'') = \tapeRead{(\tapeSatisfied{\Committed}{\w'})} \land
               \tau' = \delta'(\w'.\cpath) \Rightarrow \\
            \quad ([\loc @ \tau] \sqcup \Rcur)(\w'.\loc) \le \tau' \land {} \\
            \quad ((\exists \cpath'''. \; \tT'.\cpath \le \cpath''' < \cpath'' \land 
                         \tape(\cpath''') = \tapeFence{\Committed}{\LD}) \Rightarrow
                         ([\loc @ \tau] \sqcup \Racq)(\w'.\loc) \le \tau'). \\
          \end{array}\]
              There are two options --- either $\w'.\cpath = \cpath$, or $\w'.\cpath < \cpath$.
              In the first case $\tau' = \tau$ and $\w'.\loc = \loc$, and the statement obviously holds as $\Rcur(\loc) < \tau$
              by the way we have chosen $\tau$.
              
              Suppose, $\w'.\cpath < \cpath$. In this case $\delta'(\w'.\cpath) = \delta(\w'.\cpath)$.
              As $\invViewReadCERT(\delta, \tId, \aT, \tT)$ holds, we may simplify the statement even further:
          \[\begin{array}{l}
            \tape(\cpath'') = \tapeRead{(\tapeSatisfied{\Committed}{\w'})} \land
               \tau' = \delta(\w'.\cpath) \Rightarrow \\
            \quad [\loc @ \tau](\w'.\loc) \le \tau'. \\
          \end{array}\]
              If $\w'.\loc \not = \loc$, then the statement holds, as $[\loc @ \tau](\w'.\loc) = 0$.
              Suppose $\w'.\loc = \loc$. As $\w'.\cpath < \cpath < \cpath''$, it would have meant that
              a committed read $\tape(\cpath'')$ is satisfied from a write $\tape(\w'.\cpath)$, even though
              there is a newer write to the same location ($\tape(\cpath)$) observable to the read. It contradicts
              \app{\ref{inv:invAWriteWriteRead}}.
          \end{itemize}

          %% Obviously, it's enough to check the following as $\invViewReadCERT(\delta, )$:
          %% \[\begin{array}{l}
          %%   \forall \cpath'' \ge \cpath', \w', \tau'. \\
          %%   \quad \tape(\cpath'') = \tapeRead{(\tapeSatisfied{\Committed}{\w'})} \land
          %%      \angled{\tau', \_} = \deltaHmap(\delta', \tId, \aT, \w'.\tId, \w'.\cpath) \Rightarrow \\
          %%   \qquad [\loc @ \tau](\w.\loc) \le \tau'. \\
          %% \end{array}\]
          %% Or even simlified:
          
        \item $\invDeltaDefThree(\delta', \tId, \aT)$: \\
          We have to show that
          \[\begin{array}{l}
            \forall \cpath'', \cpath''' \not = \cpath'', \\
            \quad \angled{\tau'', \_} = \deltaHmap(\delta', \tId, \aT, \tId, \cpath''),
                  \angled{\tau''', \_} = \deltaHmap(\delta', \tId, \aT, \tId, \cpath'''), \\
            \quad ``\writeInst{\expr''_0}{\expr''_1}"   = \Cprom(\tId, \lastInstr{\cpath''}),
                  ``\writeInst{\expr'''_0}{\expr'''_1}" = \Cprom(\tId, \lastInstr{\cpath'''}). \\
            \quad \semfcom{\expr''_0}{\cpath''} = \semfcom{\expr'''_0}{\cpath'''} \Rightarrow \tau'' \not = \tau'''.
          \end{array}\]
          As $\invDeltaDefThree(\delta, \tId, \aT)$ holds, it's enough to check only cases $\cpath'' = \cpath$ or $\cpath''' = \cpath$.
          In both cases it's obvious that the statement holds by the way we have choosen $\tau$.

        \item $\invDeltaDefFour(\delta', \tId, \aT)$: \\
          We have to show that
          \[\begin{array}{l}
      \forall \cpath_{\delta} < \cpath_{read} < \cpath_{\LD} < \cpath_{\delta-read}, \\
\quad \angled{\tau', \_} = \delta'(\cpath_{\delta}), \w', \loc', \R'. \\
\quad \tape(\cpath_{read}) = \tapeRead{(\tapeSatisfied{\Committed}{\w'})} \land \tape(\cpath_{\LD}) = \tapeFence{\Committed}{\LD} \land {} \\
\quad \tape(\cpath_{\delta-read}) = \tapeRead{(\tapeSatisfied{\Committed}{\stRequestWrite{\tId}{\cpath_{\delta}}{\loc'}{\_}})} \land {} \\
\quad \R' = \aT.\rmap(\w'.\tId, \w'.\cpath) \not = \bot \Rightarrow \\
\qquad \R'(\loc) \le \tau'. \\
          \end{array}\]
          If $\cpath_{\delta} \not = \cpath$, the statement directly follows from $\invDeltaDefFour(\delta, \tId, \aT)$.
          Suppose $\cpath_{\delta} = \cpath$. The simplified statement:
          \[\begin{array}{l}
      \forall \cpath_{read}, \cpath_{\LD}, \cpath_{\delta-read}, \w', \loc', \R'. \\
\quad \cpath < \cpath_{read} < \cpath_{\LD} < \cpath_{\delta-read} \land {} \\
\quad \tape(\cpath_{read}) = \tapeRead{(\tapeSatisfied{\Committed}{\w'})} \land \tape(\cpath_{\LD}) = \tapeFence{\Committed}{\LD} \land {} \\
\quad \tape(\cpath_{\delta-read}) = \tapeRead{(\tapeSatisfied{\Committed}{\stRequestWrite{\tId}{\cpath}{\loc'}{\_}})} \land {} \\
\quad \R' = \aT.\rmap(\w'.\tId, \w'.\cpath) \not = \bot \Rightarrow \\
\qquad \R'(\loc) \le \tau. \\
          \end{array}\]
          The statement is one of the requirements we used to choose $\tau$, so it holds.
      \end{itemize}
  \end{itemize}
\end{proof}


