\chapter{Доказательство  вспомогательных лемм о симуляции модели \ARMt}
\label{sec:appendix-pop-proofs}

\section{Базовые леммы}

\noindent
\textbf{Лемма \ref{lem-snd}.}
$\forall (\aT, \p) \in \simrelPre. \;
\exists \p'. \Cfprom \vdash \p \promStep \p' \land (\aT, \p') \in \simrelPre \cup \simrel$.
\begin{proof}
Зафиксируем $\aT, \p$.
Поскольку $(\aT, \p) \in \simrelPre$, то $\invPromUptoARMnot(\aT, \p)$ выполняется.
Как следствие, существует единственный поток с идентификатором $\tId$, плёнка $\tape = \aT.\tapef(\tId)$ и
путь $\cpath = \p.\TSfprom(\tId).\cpath$ такие, что экземпляр $\tape(\cpath)$ завершён.
Далее в доказательстве мы конструируем состояние обещающей машины $\p'$ такое, что 
оно удовлетворяет утверждению теоремы.

Введём следующие обозначения:
\[\begin{array}{l l l}
  \Carm & \triangleq & \Cfarm(\tId); \\
  \angled{\Rcur, \Racq, \Rrel} & \triangleq & \p.\TSfprom(\tId).\V; \\
  \Rcur', \Racq', \Rrel' & \triangleq & \p'.\TSfprom(\tId).\V;\\
  \cpath' & \triangleq & \p'.\TSfprom(\tId).\cpath;\\
  \PromState & \triangleq & \p.\TSfprom(\tId).\PromState;\\
  \PromState' & \triangleq & \p'.\TSfprom(\tId).\PromState;\\
  \PromSet' & \triangleq & \p'.\TSfprom(\tId).\PromSet;\\
  \PromSet & \triangleq & \p.\TSfprom(\tId).\PromSet;\\
  \hmap   & \triangleq & \aT.\hmap.
\end{array}\]

Мы покажем, что обещающая машина в состоянии $\p$ может сделать переход, связанный с $\tape(\cpath)$, в состояние $\p'$,
и при этом будет выполняться $(\aT, \p') \in \simrelPre \cup \simrel$.
Далее мы проведём разбор вариантов состояния экземпляра $\tape(\cpath)$.

Очевидно, что для любого нового состояния $\p'$, такого что $\p \promStep \p'$, выполняется 
$(\aT, \p') \in \invReach \cap \invMemThree$.
Выполнение $\invPrefix(\aT, \p')$ следует из того, что
  $\cpath' \in \nextPathCom{\cpath}{\Carm}{\tape}$, $\invAnextCommitted(\aT)$, и исполнение экземпляра $\tape(\cpath)$ завершено.
Поскольку переход $\p \promStep \p'$ будет использован для того, чтобы ``нагнать'' исполнение машины \ARMt,
то он не является переходом \transenv{Завершения записи}. Как следствие, $\p'.\Mprom = \p.\Mprom$, и 
утверждение $\invMemTwo(\aT, \p')$ следует из $\invMemTwo(\aT, \p)$.
Кроме того, очевидно, что будет выполняться
либо $\invPromUptoARM(\aT, \p')$, либо $\invPromUptoARMnot(\aT, \p')$ в зависимости от
завершённости экземпляра $\tape(\cpath')$.

%% \textbf{Note}:
%% %% ($CorrectType$): \\
%% $\aT.\Cfarm = \p.\Cfprom$ and the type of the 
%%  the type of the step $\p \promStep \p'$ corresponds to $\tape(\cpath)$.
%% $\invATapeCf(\aT)$,

Рассмотрим варианты состояния (завершённого) экземпляра $\tape(\cpath)$.
\begin{itemize}
  \item $\tape(\cpath) = \tapeNop$, $\tape(\cpath) = \tapeAssign$ или $\tape(\cpath) = \tapeIfGoto{\IfState}{\z}$. \\
    Во всех трёх случаях переход обещающей машины $\p \promStep \p'$ будет внутренним, т.е. $\epsilon$-переходом.
    %% By the transition definition, $\cpath' = \nextPathProm(\cpath, 1) = \cpath ++ [\lastInstr{\cpath} + 1]$.
    Поскольку $\epsilon$-переход не меняет состояние памяти, то утверждение $\invMemOne(\aT, \p')$ непосредственно
    следует из $\invMemOne(\aT, \p)$.
    Аналогично выполняются $\invView (\aT, \p')$ (поскольку $\p'.\TSfprom(\tId).\V = \p.\TSfprom(\tId).\V$),
    $\invState(\aT, \p')$ (поскольку $\p'.\TSfprom(\tId).\PromState = \p.\TSfprom(\tId).\PromState$ и
    $\regstcom(\Carm(\tId), \tape, \cpath') = \regstcom(\Carm(\tId), \tape, \cpath')$) и 
    $\invComWrite(\aT, \p')$ (поскольку экземпляр $\tape(\cpath)$ не является ни записью, ни барьером).

  \item $\tape(\cpath) = \tapeFence{\Committed}{\LD}$. \\
    Обещающая машина делает переход, соответствующий приобретающему барьеру памяти.
    Как следствие, новый базовый фронт $\Rcur'$ равен старому приобретающему фронту $\Racq$.
    Утверждения $\invMemOne(\aT, \p')$ и $\invState(\aT, \p')$ выполняются, поскольку
    переход не меняет состояния локальных переменных и памяти.

    Проверим, что выполняется $\invView (\aT, \p')$. Для этого нам нужно показать, что следующее утверждение верно:
      \[\begin{array}{l}
        \forall \tId', \tape' = \aT.\tapef(\tId'), \cpath'' = \p.\TSfprom(\tId').\cpath, \\
        \quad (\p'.\TSfprom(\tId').\Racq \le \bigsqcup \readsSatisfiedR(\cpath'', \tape', \hmap) \\
        \quad \quad \sqcup \bigsqcup \opstau(\tId', \cpath'', \tape', \hmap)) \land \\
        \quad (\p'.\TSfprom(\tId').\Rcur \le \bigsqcup \readsSatisfiedR(\lastLD(\tape', \cpath''), \tape', \hmap) \\
        \quad \quad \sqcup \bigsqcup \opstau(\tId', \cpath'', \tape', \hmap)) \land \\
        \quad (\p'.\TSfprom(\tId').\Rrel \le \bigsqcup \readsSatisfiedR(\lastLDSY(\tape', \cpath''), \tape', \hmap) \\
        \quad \quad \sqcup \bigsqcup \opstau(\tId', \lastSY(\tape', \cpath''), \tape', \hmap))).
      \end{array}\]
    Зафиксируем $\tId', \tape', \cpath''$. Если $\tId' \not = \tId$, то утверждение следует из $\invView(\aT, \p)$ и 
    $\p'.\TSfprom(\tId').\V = \p.\TSfprom(\tId').\V$.
    Пусть $\tId' = \tId$. Как следствие, $\tape' = \tape$ и $\cpath'' = \cpath'$.
    Также верно, что
    \begin{itemize}
      \item $\p'.\TSfprom(\tId).\Racq = \p.\TSfprom(\tId).\Racq = \Racq$,
      \item $\p'.\TSfprom(\tId).\Rcur = \p.\TSfprom(\tId).\Racq = \Racq$,
      \item $\p'.\TSfprom(\tId).\Rrel = \p.\TSfprom(\tId).\Rrel = \Rrel$.
    \end{itemize}
    Тогда утверждение в упрощённой форме выглядит так:
     \[\begin{array}{l}
       \quad (\Racq \le \bigsqcup \readsSatisfiedR(\cpath', \tape, \hmap) \\
       \quad \quad \sqcup \bigsqcup \opstau(\tId, \cpath', \tape, \hmap)) \land \\
       \quad (\Racq \le \bigsqcup \readsSatisfiedR(\lastLD(\tape, \cpath'), \tape, \hmap) \\
       \quad \quad \sqcup \bigsqcup \opstau(\tId, \cpath', \tape, \hmap)) \land \\
       \quad (\Rrel \le \bigsqcup \readsSatisfiedR(\lastLDSY(\tape, \cpath'), \tape, \hmap) \\
       \quad \quad \sqcup \bigsqcup \opstau(\tId, \lastSY(\tape, \cpath'), \tape', \hmap))).
     \end{array}\]
     Первый и третий конъюнкты следует из того, что выполняется $\invView(\aT, \p)$ и $\cpath' > \cpath$.
     Второй конъюнкт следует из определения $\lastLD(\tape, \cpath')$ и $\invView(\aT, \p)$.

     Утверждение $\invComWrite(\aT, \p')$ выполняется, поскольку экземпляр $\tape(\cpath)$ не является ни записью,
     ни $\SY$-барьером.

   \item $\tape(\cpath) = \tapeFence{\Committed}{\SY}$. \\
    Обещающая машина делает переход, соответствующий высвобождающему барьеру памяти.
    Как следствие, новый высвобождающий фронт $\Rrel'$ равен старому базовому фронту $\Rcur$.
    Утверждения $\invMemOne(\aT, \p')$ и $\invState(\aT, \p')$ выполняются, поскольку
    переход не меняет состояния локальных переменных и памяти.
    То, что утверждение $\invView(\aT, \p')$ выполняется, может быть показано аналогичными выкладками,
    что и в случае $\tape(\cpath) = \tapeFence{\Committed}{\LD}$.
     
    Из верности утверждения $\invComWrite(\aT, \p)$ следует, что
    не существует незавершённого экземпляра записи с путём $\cpath^{write} > \cpath$.
    Это означает, что выполняется $\invComWrite(\aT, \p')$.

  \item $\tape(\cpath) = \tapeRead{(\tapeSatisfied{\Committed}{\writeEvt{\tId''}{ \cpath''}{ x}{\stval}})}$. \\
    Обещающая машина делает переход, соответствующий расслабленному чтению.
    Утверждения $\invMemOne(\aT, \p')$ и $\invComWrite(\aT, \p')$
    выполняются по тем же соображениям, что и в первом рассмотренном случае.

    Поскольку все экземпляры с путями, меньше чем $\cpath$, завершены, то
    экземпляр записи $(\tId'', \cpath'')$, из которого читает экземпляр $\tape(\cpath)$, точно завершён.
    Введём следующие обозначения:
    \[\begin{array}{l}
    \aT.\tapef(\tId'', \cpath'') = \tapeWrite{(\tapeWriteCommitted{\_}{x}{\stval})}; \\
    (\tau, \_, \R') \triangleq \aT.\hmap(\tId'', \cpath'') \not = (\bot, \_ , \bot). \\
    \end{array}\]
    Наличие соответствующего сообщения $\writeEvt{x}{\stval}{\tau}{\R}$ в памяти обещающей машины
    следует из $\invMemOne(\aT, \p)$.
    То, что метка времени сообщения не меньше, чем значение базового фронта потока, т.е. $\tau \ge \Rcur(x)$,
    следует из $\invAview(\aT)$.
  
  По определению переходов обещающей машины мы знаем, что
  $\Rcur' = \Rcur \sqcup [x@\tau]$, $\Racq' = \Racq \sqcup \R, \R \le \R'$ и $\PromState' = \PromState[\reg \mapsto \stval]$.

  Утверждение $\invState(\aT, \p')$ выполняется, поскольку
  $\PromState' = \PromState[\reg \mapsto \stval] =$
  $\regstcom(\Carm, \tape, \cpath)[\reg \mapsto \stval] = \regstcom(\Carm, \tape, \cpath')$.
  
  Выполнение утверждения $\invView (\aT, \p')$ следует из определения функций $\opstau$ и $\readsSatisfiedR$.

  \item $\tape(\cpath) = \tapeWrite{(\tapeWriteCommitted{\InMemory}{x}{\stval})}$. \\
    Обещающая машина делает переход, соответствующий выполнению ранее данного обещания.
    Мы знаем, что $(\tau, \_, \R') \triangleq \aT.\tmap(\tId, \cpath) \not = \bot$,
    поскольку экземпляр записи завершён.
    То, что существует нужное обещание, т.е. $\writeEvt{x}{\stval}{\tau}{\R} \in \p.\TSfprom(\tId).\PromSet$,
    напрямую следует из $\invMemOne(\aT, \p)$.
    Фронт $\R$ равен $\Rrel \sqcup [x@\tau]$, поскольку обещающая машина не имеет возможности
    делать обещания через высвобождающие барьеры памяти.
    Утверждение $\invState(\aT, \p')$ выполняется, поскольку верно $\invState(\aT, \p')$ и выполнение обещания
    не меняет состояния переменных.
    То, что $\Rcur(x) < \tau$ следует из $\invAview(\aT)$.
    То, что $\R \le R'$ следует из того, как машина \ARMt~конструирует компоненту $\rmap$.

    Мы знаем, что 
    \[\begin{array}{l}
\Rcur' = \Rcur \sqcup [x@\tau];\\
\Racq' = \Racq \sqcup [x@\tau];\\
\PromSet' = \PromSet \setminus \{ \writeEvt{x}{\stval}{\tau}{\R} \}.\\
    \end{array}\]

    Утверждение $\invMemOne(\aT, \p')$ следует из $\invMemOne(\aT, \p)$ и
    $\tape(\cpath) = \tapeWrite{(\tapeWriteCommitted{\InMemory}{x}{\stval})}$.
    Утверждение $\invView (\aT, \p')$ следует из определений функций $\opstau$ и $\readsSatisfiedR$.
    Утверждение $\invComWrite(\aT, \p')$ верно, т.к. все экземпляры инструкций, чей путь меньше $\cpath$,
    являются завершёнными.
  \end{itemize}

То, что переход $\p \promStepgen{} \p'$ сертифицируем, т.е. существует
конечное число переходов потока $\tId$, после которых все обещания потока выполнены,
доказывается в приложении \ref{sec:app:cert}.
\end{proof}

%% \lemmaFst*
\noindent
\textbf{Лемма \ref{lem-fst}.}
$\forall (\aT, \p) \in \simrel. \\
(\forall \aT'. \; \Cfprom \vdash \aT \armStepgen{\lnot \; \transenv{Write commit}} \aT' \Rightarrow (\aT', \p) \in \simrelPre \cup \simrel) \land {} \\
(\forall \aT'. \; \Cfprom \vdash \aT \armStepgen{\transenv{Write commit}} \aT' \Rightarrow
\exists \p'. \; \Cfprom \vdash \p \promStepgen{\transenv{Promise write}} \p' \land  (\aT', \p') \in \simrelPre \cup \simrel)$.
\begin{proof}
  Рассмотрим первый конъюнкт.
  Зафиксируем $\aT, \p$ и $\aT'$ такие, что $\aT \armStepgen{\lnot \; \transenv{Write commit} \; \tId} \aT'$.
  Введём следующие обозначения:
\[
\begin{array}{l l l}
\multicolumn{3}{l}{\angled{\cpath', \PromState, \angled{\Rcur, \Racq, \Rrel}, \PromSet} \triangleq \p.\TSfprom(\tId);}\\
\tape     & \triangleq & \aT.\tapef(\tId); \\
%% \cpathSY & \triangleq & \lastSY(\tape, \cpath');\\
%% \cpathLDSY & \triangleq & \lastLDSY(\tape, \cpath').\\
\end{array}
\]

  Нам нужно показать, что $(\aT', \p) \in \simrel \cup \simrelPre$.
  Из определений $\invReach$ и $\invMemThree$ следует, что $(\aT', \p) \in \invReach \cap \invMemThree$ выполняется.
  Утверждения $\invPrefix(\aT', \p)$ и $\invView(\aT', \p)$ выполняется, потому что переход $\aT \armStepgen{} \aT'$
  не меняет завершённый префикс $\aT.\tapef(\tId)$.
  Утверждение $\invComWrite(\aT', \p)$ следует из $\invComWrite(\aT, \p)$ и требований правила \transenv{Завершение $\SY$-барьера}.
   
  Нам нужно показать, что выполняется либо $\invPromUptoARM(\aT', \p)$, либо $\invPromUptoARMnot(\aT', \p)$.
  Если переход $\aT \armStepgen{} \aT'$ является \transenv{Уведомлением потока $\tId''$ о запросе $\e''$},
  для плёнка любого потока не меняется, а значит как следствие того, что $(\aT, \p) \in \simrel$,
  выполняется $\invPromUptoARM(\aT', \p)$.
  Иначе, существует некоторый экземпляр $(\tId, \cpath)$, часть исполнения которого выполняется на переходе $\aT \armStepgen{} \aT'$.
  Если $\cpath' \not = \cpath$, то очевидно выполняется $\invPromUptoARM(\aT', \p)$.
  Рассмотрим вариант $\cpath' = \cpath$.
  В этом случае выполняется либо $\invPromUptoARM(\aT', \p)$, либо $\invPromUptoARMnot(\aT', \p)$,
  в зависимости от завершённости экземпляра $\aT'.\tapef(\tId, \cpath)$.

  Утверждение $(\aT', \p) \in \invMemOne \cap \invMemTwo$ верно, поскольку $\aT \armStepgen{} \aT'$ не
  является переходом \transenv{Завершение записи}, а значит набор сообщений записи в подсистеме памяти машины \ARMt~не меняется.
  
  Так доказывается первый конъюнкт леммы.
  
  Рассмотрим второй конъюнкт.
  Зафиксируем $\aT$, $\p$ и $\aT'$ такие, что $\aT \armStepWriteCommit \aT'$.
  Введём следующие обозначения:
\[
\begin{array}{l l l}
\multicolumn{3}{l}{\angled{\cpath', \PromState, \angled{\Rcur, \Racq, \Rrel}, \PromSet} \triangleq \p.\TSfprom(\tId);}\\
\R' & \triangleq & \Rrel \sqcup [x @ \tau]; \\
\PromSet' & \triangleq & \PromSet \cup \{\writeEvt{x}{\stval}{\tau}{\R'}\}; \\
\TSfprom' & \triangleq & \p.\TSfprom[\tId \mapsto \angled{\cpath', \PromState, \angled{\Rcur, \Racq, \Rrel}, \PromSet'}]; \\
\tape     & \triangleq & \aT.\tapef(\tId); \\
\hmap     & \triangleq & \aT.\hmap; \\
%% \cpathSY & \triangleq & \lastSY(\tape, \cpath');\\
%% \cpathLDSY & \triangleq & \lastLDSY(\tape, \cpath').\\
\end{array}
\]
Мы знаем, что метка времени $\tau$ не была использована для сообщений к локации $x$,
поскольку она использована машиной \ARMt~на этом шаге.
В обещающей машине переход \transenv{Обещание записи} не имеет ограничений,
(с точностью до сертификации, возможность которой доказывается в приложении \ref{sec:app:cert}),
поэтому возможен переход $\p \promStepPromiseRPrime \p'$,
где $\p' = \angled{\p.\Mprom \cup \{\writeEvt{x}{\stval}{\tau}{\R'}\}, \TSfprom'}$.

Нам нужно проверить, что выполняется $(\aT', \p') \in \simrelPre \cup \simrel$.
Как следствие $(\aT, \p) \in \simrel$ и определений $\aT'$ и $\p'$, выполняется $(\aT', \p') \in \invReach \cap \invMemThree$.
Утверждения $\invPrefix(\aT', \p'), \invView(\aT', \p'), \invState(\aT', \p')$ и $\invComWrite(\aT', \p)$ выполняются,
поскольку переход \transenv{Завершение записи} машины \ARMt~не меняет завершённый префикс $\aT.\tapef(\tId)$.
Утверждение $\invPromUptoARM(\aT', \p) \cup \invPromUptoARMnot(\aT', \p)$ выполняется по тем же соображениям, что
и в предыдущем рассмотренном варианте.

Утверждение $\invMemOne(\aT', \p')$ верно, поскольку верно $\invMemOne(\aT, \p)$, а изменения памяти машин
отражают требования $\invMemOne$.

Проверим, что выполняется $\invMemTwo(\aT', \p')$. Для этого нужно показать, что верно следующее утверждение.
  \[\begin{array}{l}
  \forall \writeEvt{y}{\stval'}{\tau'}{\R''} \in \p'.\Mprom, \tau' \not = \tstamp{0} => \\
  \quad \exists \tId', \cpath'', \R''' \ge \R'', \\
  \quad \quad \tapeWrite{(\tapeWriteCommitted{\_}{y}{\stval'})} = \aT'.\tapef(\tId', \cpath''),
        \aT'.\hmap(\tId', \cpath'') = (\tau', \_, \R'''). \\
  \end{array}\]
Зафиксируем сообщение $\writeEvt{y}{\stval'}{\tau'}{\R''}$ такое, что $\tau' \not = \tstamp{0}$.
  \[\begin{array}{l}
  \writeEvt{y}{\stval'}{\tau'}{\R''} \in \p.\Mprom \cup \{\writeEvt{x}{\stval}{\tau}{\R'}\} => \\
  \quad \exists \tId', \cpath'', \R''' \ge \R'', \\
  \quad \quad \tapeWrite{(\tapeWriteCommitted{\_}{y}{\stval'})} = \aT'.\tapef(\tId', \cpath''),
        \aT'.\hmap(\tId', \cpath'') = (\tau', \_, \R'''). \\
  \end{array}\]
Если $\writeEvt{y}{\stval'}{\tau'}{\R''} \in \p.\Mprom$, то утверждение является следствием утверждения $\invMemTwo(\aT, \p)$.
Иначе, $\writeEvt{y}{\stval'}{\tau'}{\R''}$ совпадает с $\writeEvt{x}{\stval}{\tau}{\R'}$.
Тогда мы можем упростить утверждение:
      \[\begin{array}{l}
    \exists \tId', \cpath'', \R''' \ge \R',
      \tapeWrite{(\tapeWriteCommitted{\_}{x}{\stval})} = \aT'.\tapef(\tId, \cpath''), \\
      \quad \aT'.\hmap(\tId', \cpath'') = (\tau, \_, \R'''). \\
      \end{array}\]
Выберем $\tId' = \tId, \cpath'' = \cpath, \R''' = \R$. Тогда утверждение верно по определению $\aT'$.
\end{proof}
