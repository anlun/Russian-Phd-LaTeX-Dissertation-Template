\chapter{Операционная модель памяти C/C++11} \label{sec:opc11}
В данной главе описана предложенная в диссертации операционная модель
памяти $\OpCpp$ для языков C/C++11, и представлен реализующий её интепретатор.
Материал главы покрывает результат статьи \cite{Podkopaev-al:CoRR16}.

Модель $\OpCpp$ представлена как семейство аспектов, каждый из которых описывает некоторую особенность
изначальной модели C/C++11 \cite{Batty-al:POPL11}.
Это позволяет упростить модель для задач, в которых рассматривается только подмножество
языка модели C/C++11.
Также, поскольку некоторые особенности оригинальной модели,
такие как поддержка секвенциализации (см. раздел \ref{sec:opc11:join}), неоднозначны,
то аспектное представление позволяет легко настраивать интерпретатор под интересующий
вариант семантики.

%% Операционное представление различных аспектов оригинальной модели памяти C/C++11 \cite{Batty-al:POPL11}
%% базируется на комбинации двух основных идей: \emph{фронтов} и \emph{операционных буферов}.

Описание модели структурировано следующим образом.
В начале рассматриваются ряд примеров, мотивирующих введение
различных аспектов модели $\OpCpp$,
и неформально описываются сами аспекты (раздел \ref{sec:opc11:base}).
%%  модели вводятся неформально, 
%% В разделе \ref{sec:opc11:base} рассматриваются базовые концепции модели на нескольких примерах,
%% которые требуются для представления исполнения расслабленных инструкций, приобретающих чтений и
%% высвобождающих записей.
%% Далее в разделе \ref{sec:opc11:fullmodel} рассматриваются части модели, которые описывают
%% поведение $\sco$-инструкций, неатомарных обращений к памяти, потребляющих чтений, а также
%% высвобождающих цепочек (release sequences).
Далее приводится математическое определение упомянутых аспектов
(раздел \ref{sec:opc11:formal}).
Обсуждаются результаты тестирования модели на наборе ``лакмусовых'' тестов (litmus tests) и
алгоритме RCU (раздел \ref{sec:opc11:interpreter}).
В заключении главы приводятся рассуждения о свойствах модели (раздел \ref{sec:opc11:results}).

\section{Аспекты модели}
\label{sec:opc11:base}
\label{sec:opc11:fullmodel}
Модель памяти $\OpCpp$ задана операционным способом, следовательно, существует
абстрактная машина, связанная с моделью, которая исполняет программы
по шагам.
Далее для обозначения этой модели мы будем использовать термин \emph{машина} $\OpCpp$.

%% \section{Продвинутые детали модели}
%% В это разделе описывается то, как с помощью фронтов представляется поведение
%% $\sco$- и $\con$-инструкции, и ищутся гонки по данным на неатомарных обращениях к памяти.
%% Кроме того, рассматривается проблема соединения потоков (thread's joining) в контексте
%% оптимизации по секвенциализации потоков (thread's sequentialization).

\subsection{Память и базовый фронт}
Состояние машины $\OpCpp$ включается в себя множество сообщений, которое называется 
\emph{памятью}.
\emph{Сообщение} --- это тройка, состоящая из
локации, значения и \emph{метки времени} (timestamp).
Метка времени является натуральным числом и используется
для упорядочивания сообщений, которые связаны с одной и той же локацией.
Такой порядок аналогичен отношению $\lMO$ в аксиоматической модели C/C++11 \cite{Batty-al:POPL11}.

Рассмотрим машину $\OpCpp$ на примере исполнения следующей программы:
\begin{equation*}
\tag{MP-rlx-2}
\begin{tabular}{c}
  $\writeInstParam{\rlx}{x}{0}; \writeInstParam{\rlx}{y}{0};$ \\
\begin{tabular}{L || L}
  \writeInstParam{\rlx}{x}{1}; & \readInstParam{\rlx}{a}{y}; \\
  \writeInstParam{\rlx}{y}{1}  & \readInstParam{\rlx}{b}{x}; \\
                               & \readInstParam{\rlx}{c}{x}\\
\end{tabular}
\end{tabular}
\end{equation*}
Данная программа является очередной вариацией программы ${\rm MP}$,
в которой во второй поток было добавлено дополнительное
чтение из локации $x$.
После исполнения первых двух инструкций
($\writeInstParam{\rlx}{x}{0}; \writeInstParam{\rlx}{y}{0}$)
память машины будет содержать два сообщения:
\[
M = \{\angled{x:0@\tstamp{0}}, \angled{y:0@\tstamp{0}}\},
\]
где $\tstamp{0}$ -- метка времени.
После того, как левый поток закончит своё исполнение, в памяти будет находится
четыре сообщения:
\[
M = \{\angled{x:0@\tstamp{0}}, \angled{y:0@\tstamp{0}},
      \angled{y:1@\tstamp{1}},\angled{x:1@\tstamp{1}}\}.
\]

Заметим, что в оригинальной модели C/C++11 \cite{Batty-al:POPL11} у рассматриваемой программы есть сценарий поведения
с результатом $[a = 1, b = 0, c = 0]$.
Для того, чтобы разрешить этот результат,
потоки машины $\OpCpp$ имеют право при чтении выбирать из памяти
сообщение не с самой большой меткой времени,
как этого требовала бы абстрактная машина, представляющая модель SC, т.е.
не самую последнюю запись в локацию.
После завершения исполнения левого потока
правый поток может сначала прочитать сообщение $\angled{y:1@\tstamp{1}}$,
присвоив в регистр $a$ значение $1$,
а затем выполнить два чтения из старого сообщения $\angled{x:0@\tstamp{0}}$,
получив $b = c = 0$.

Отметим, что модель C/C++11 запрещает сценарий поведения
$[a = 1, b = 1, c = 0]$, поскольку гарантирует, что если поток
``увидел'' более новую запись в локацию
(в данном случае это сообщение $\angled{x:1@\tstamp{1}}$),
то он не может прочитать более старое, с точки зрения отношения $\lMO$, сообщение.
Для того, чтобы поддержать данное ограничение, в модели $\OpCpp$ у каждого потока есть
т.н. \emph{базовый фронт}, $\Rcur$.
Базовый фронт --- это частичная функция, которая по локации возвращает
максимальную метку времени сообщения, связанного с локацией,
о котором осведомлен поток.
Когда поток пытается прочитать или записать сообщение в локацию $\loc$ с меткой времени $\tau$,
он проверяет, что $\tau$ больше или равно, чем значение его базового фронта по
$\loc$%
\footnote{
Строго говоря, поток никогда не ``пытается'' делать какое-то действие.
В формальной модели упомянутая проверка реализуется как дополнительное условие в
правилах чтения и записи.
}.
%% Эта компонента состояния потока обновляется по простому правилу:
%% когда поток 
%% он обновляет свой базовый фронт по этой локации до $\tau$.
%% Используется 
%% Далее машина $\OpCpp$ и более не может
%% читать $\loc$-сообщения с меньшей меткой.

Рассмотрим действие базового фронта на примере
сценария поведения
программы ${\rm MP\text{-}rlx\text{-}2}$,
который приводит к результату $[a = 1, b = 1, c = \_]$.
Изначально в системе существует один поток $T0$ с пустым базовым фронтом.
После исполнения первых двух инструкций программы
($\writeInstParam{\rlx}{x}{0}; \writeInstParam{\rlx}{y}{0}$) базовый фронт потока, $T0.\Rcur$, будет указывать на
соответствующие сообщения из памяти:
\[
T0.\Rcur = [x@\tstamp{0}, y@\tstamp{0}].
\]
Далее машина стартует два потока $T1$ и $T2$, базовые фронты которых будут равны $T0.\Rcur$.
%% \[
%% T1.\Rcur = [x@\tstamp{0}, y@\tstamp{0}] \quad T2.\Rcur = [x@\tstamp{0}, y@\tstamp{0}]
%% \]
После исполнения инструкции (левого) потока $T1$ память машины будет
содержать два новых сообщения,
а базовый фронт потока $T1$ станет равным $\tstamp{1}$ по обоим локациям,
т.к. поток, сделавший запись, естественным образом осведомлён о ней:
\[
\begin{array}{l}
T1.\Rcur = [\graybox{x@\tstamp{1}}, \graybox{y@\tstamp{1}}];
\quad T2.\Rcur = [x@\tstamp{0}, y@\tstamp{0}].
\end{array}
\]
После этого (правый) поток $T2$ может прочитать новое сообщение в локацию $y$,
присвоив $1$ в регистр $a$
и увеличив свой фронт по локации $y$ до $\tstamp{1}$:
\[
\begin{array}{l}
T1.\Rcur = [x@\tstamp{1}, y@\tstamp{1}];
\quad T2.\Rcur = [x@\tstamp{0}, \graybox{y@\tstamp{1}}].
\end{array}
\]
Т.к. базовый фронт потока $T2$ по локации $x$ равен $\tstamp{0}$, т.е. поток ещё не осведомлён о новой записи в $x$, то
поток может прочитать либо сообщение $\angled{x:0@\tstamp{0}}$, либо сообщение $\angled{x:1@\tstamp{1}}$.
Для того, чтобы $b$ равнялось $1$, поток $T2$ должен прочитать из более нового сообщения, что обновит его
базовый фронт по локации $x$:
\[
\begin{array}{l}
T1.\Rcur = [x@\tstamp{1}, y@\tstamp{1}];
\quad T2.\Rcur = [\graybox{x@\tstamp{1}}, y@\tstamp{1}].
\end{array}
\]
После этого потоку $T2$ остаётся только выполнить последнее чтение ($\readInstParam{\rlx}{c}{x}$),
и поскольку его базовый фронт по локации $x$ равен $\tstamp{1}$, то он может прочитать только
из нового сообщения в локацию $x$ ($\angled{x:1@\tstamp{1}}$).
Как следствие, результат $[a = 1, b = 1, c = 0]$ невозможен для
программы ${\rm MP\text{-}rlx\text{-}2}$ в модели $\OpCpp$.

%% Для рассматриваемой программы модель $\OpCpp$ должна разрешать сценарий поведения с результатом $[a = 1, b = 0, c = 0]$,
%% т.к. такой результат разрешает оригинальная модель C/C++11 \cite{Batty-al:POPL11}.
%% Рассмотрим сценарий поведения машины $\OpCpp$, который приводит к нему.

\subsection{Синхронизация потоков}
Рассмотрим программу ${\rm MP\text{-}rel\text{-}acq}$, которую мы уже обсуждали в главе \ref{sec:overview}.
\begin{equation*}
  \tag{MP-rel-acq}
\begin{tabular}{c}
  $\writeInstParam{\rlx}{x}{0}; \writeInstParam{\rlx}{y}{0};$ \\
\begin{tabular}{L || L}
  \writeInstParam{\rlx}{x}{1}; & \readInstParam{\acq}{a}{y}; \\
  \writeInstParam{\rel}{y}{1} & \readInstParam{\rlx}{b}{x}\\
\end{tabular}
\end{tabular}
\end{equation*}
Для этой программы результат $[a = 1, b = 0]$ запрещён в C/C++11 MM,
т.к. если $a = 1$, то между потоками произошла
синхронизация (т.е. в соответствующем графе есть ребро отношения $\lSW$),
и перед выполнением $\readInstParam{\rlx}{b}{x}$ правый поток должен быть осведомлен
о записи $\writeInstParam{\rlx}{x}{1}$.

Для того, чтобы представить такую синхронизацию, у каждого сообщения машины $\OpCpp$
есть четвертая дополнительная компонента --- \emph{фронт сообщения}.
Фронт сообщения $m$ хранит информацию о сообщениях, о которых узнаёт
поток, выполнивший приобретающее ($\acq$) чтение сообщения $m$.
Если поток $T$ выполняет высвобождающую ($\rel$) запись, то фронтом сообщения,
которое будет добавлено в память как результат исполнения записи, будет базовый
фронт потока $T$ на момент выполнения записи.
Расслабленные ($\rlx$) записи также помещают фронт в соответствующие сообщения,
но в соответствии с более сложными правилами,
которые будут описаны в разделе \ref{sec:opc11:releaseseq}.

Рассмотрим сценарий поведения ${\rm MP\text{-}rel\text{-}acq}$, в котором $a = 1$.
После того, как выполнены две инициализирующие записи и запущены два потока, память и базовые фронты потоков
выглядят следующим образом:
\[
\begin{array}{l}
M = \{\angled{x:0@\tstamp{0}, [x@\tstamp{0}]}, \angled{y:0@\tstamp{0},[y@\tstamp{0}]} \}; \\
T1.\Rcur = [x@\tstamp{0}, y@\tstamp{0}];
\quad T2.\Rcur = [x@\tstamp{0}, y@\tstamp{0}].
\end{array}
\]
После исполнения двух записей (левым) потоком $T1$ в память попадает два новых сообщения, одно из которых
было сделано высвобождающей записью:
\[
\begin{array}{l}
M = \{
\angled{x:0@\tstamp{0}, [x@\tstamp{0}]}, \angled{y:0@\tstamp{0},[y@\tstamp{0}]}, \\
\qquad \angled{x:1@\tstamp{1}, [x@\tstamp{1}]}, \angled{y:1@\tstamp{1},\graybox{[x@\tstamp{1},y@\tstamp{1}]}}
 \}; \\
T1.\Rcur = [x@\tstamp{1}, y@\tstamp{1}];
\quad T2.\Rcur = [x@\tstamp{0}, y@\tstamp{0}].
\end{array}
\]
После того, как (правый) поток выполняет приобретающее чтение из сообщения 
$\angled{y:1@\tstamp{1},[x@\tstamp{1},y@\tstamp{1}]}$, его базовый фронт увеличивается по обоим компонентам:
\[
\begin{array}{l}
T2.\Rcur = [\graybox{x@\tstamp{1}}, y@\tstamp{1}].
\end{array}
\]
После этого (правый) поток $T2$ не может прочитать старое сообщение $\angled{x:0@\tstamp{0}, [x@\tstamp{0}]}$.
Таким образом модель $\OpCpp$ запрещает результат $[a = 1, b = 0]$ для программы ${\rm MP\text{-}rel\text{-}acq}$.

\subsection{Операционные буфера}
Тем не менее, не все слабые сценарии поведения программ, наблюдаемые в модели C/C++11,
могут быть описаны приведенными выше способами.
Рассмотрим пример --- программу ${\rm LB\text{-}rlx}$ (load buffering, буферизация записи):
\begin{equation*}
\tag{LB-rlx}\label{ex:LBrlx}
\begin{tabular}{c}
  $\writeInstParam{\rlx}{x}{0}; \writeInstParam{\rlx}{y}{0};$ \\
\begin{tabular}{L || L}
  \readInstParam{\rlx}{a}{x}; & \readInstParam{\rlx}{b}{y}; \\
  \writeInstParam{\rlx}{y}{1} & \writeInstParam{\rlx}{x}{1} \\
\end{tabular}
\end{tabular}
\end{equation*}
Модель памяти C/C++11 разрешает сценарий поведения этой программы с результатом $[a = 1, b = 1]$.
Такой результат требует, чтобы в момент исполнения инструкции $\readInstParam{\rlx}{a}{x}$
в памяти находилось сообщение $\angled{x:1@\_,\_}$.
Это означает, что инструкция $\writeInstParam{\rlx}{x}{1}$ должна быть исполненной.
Аналогичное утверждение верно и для пары инструкций
$\readInstParam{\rlx}{b}{y}$ и $\writeInstParam{\rlx}{y}{1}$.
Таким образом, хотя бы в одном из потоков инструкция записи должна быть исполнена раньше чтения.

Для решения этой проблемы модель $\OpCpp$ добавляет в состояние каждого потока по
\emph{операционному буферу} --- это списку записей об отложенных инструкциях, которые 
хранят всю необходимую информацию для дальнейшего исполнения. 
Так, в частности, когда поток откладывает инструкцию чтения, он заменяет её в программе
на новое, уникальное символьное значение%
\footnote{Семантика $\OpCpp$ задана в стиле редукционных контекстов \cite{Felleisen-Hieb:TCS92,Felleisen-al:BOOK09},
т.е. программа представляется как выражение, которое постепенно редуцируется.
Как следствие, инструкция чтения в этой семантике --- это некоторое подвыражение, которое, будучи вычисленным,
заменяется на прочитанное значение.
Подробное описание семантики в виде редукционных контекстов приведено в разделе \ref{sec:opc11:formal}.
}, а в буфер добавляет пару, состоящую из символьного значения
и целевой локации.
Для отложенной инструкции записи в буфер сохраняется целевая локация и значение,
которое нужно записать.
Далее поток машины $\OpCpp$ может недетерминировано выбрать отложенную инструкцию из буфера и
исполнить её, если в буфере перед выбранной инструкцией нет инструкции,
которая может непосредственно повлиять на результат выбранной.
Так, данный механизм позволяет в программе ${\rm LB\text{-}rlx}$ отложить исполнение инструкции чтения в левом потоке,
что даёт возможность получить результат $[a = 1, b = 1]$.

\subsection{Спекулятивное исполнение}
Оригинальная модель C/C++11 поддерживает оптимизацию,
которая выносит за пределы условного оператора инструкцию, которая
встречается в обоих ветках оператора.
Так, в следующей программе инструкция $\writeInstParam{\rlx}{y}{1}$
не зависит от условия $\kw{if}$-оператора, и поэтому может быть
выполнена перед инструкцией $\readInstParam{\rlx}{a}{x}$.
Это позволяет получить результат $c = 1$.
\begin{equation*}
\tag{SE-simple}
\begin{tabular}{c}
  $\writeInstParam{\rlx}{x}{0}; \writeInstParam{\rlx}{y}{0}; \writeInstParam{\rlx}{z}{0};$ \\
\begin{tabular}{L || L}
  \begin{array}{@{}l@{}}
    \readInstParam{\rlx}{a}{x}; \\
    \iteml{a}{
      \writeInstParam{\rlx}{z}{1}; \\
      \writeInstParam{\rlx}{y}{1}
    }
    {\writeInstParam{\rlx}{y}{1}}
  \end{array} &
  \begin{array}{@{}l@{}}
    \readInstParam{\rlx}{b}{y}; \\
    \iteml{b}{
      \writeInstParam{\rlx}{x}{1}
    }
    {\skipc}
  \end{array}
\end{tabular} \\
  $\readInstParam{\rlx}{c}{z}$
\end{tabular}
\end{equation*}

Для того, чтобы поддержать такие сценарии, в $\OpCpp$
операционные буфера могут быть \emph{вложенными}.
Когда исполнение потока подходит к условному оператору, условие которого зависит от ранее отложенной
операции, семантика добавляет в буфер кортеж,
который содержит символическое представление условия, а также два пустых буфера.
Эти буфера в дальнейшем будут пополняться отложенными инструкциями $\kw{then}$ и $\kw{else}$
веток оператора.

Рассмотрим сценарий поведения программы ${\rm SE\text{-}simple}$, в котором $c = 1$.
После исполнения инициализирующих инструкций записи память машины $\OpCpp$ содержит три сообщения:
\[
M = \{\angled{x:0@\tstamp{0}, [x@\tstamp{0}]}, \angled{y:0@\tstamp{0},[y@\tstamp{0}]},
      \angled{z:0@\tstamp{0},[z@\tstamp{0}]}\}.
\]
Далее левый поток откладывает выполнение инструкции чтения и начинает
спекулятивно, т.е. без вычисления значения условия, исполнять инструкции
веток условного оператора.
Так, в буфере левого потока оказывается две записи:
\[\angled{\readInstParam{\rlx}{a}{x}; \kw{if} \; a \; \angled{} \; \angled{}}.\]
Продолжая (спекулятивно) откладывать инструкции, левый поток помешает все инструкции из
условного оператора в соответствующие подбуфера:
\[\angled{\readInstParam{\rlx}{a}{x};
  \kw{if} \; a \; \angled{\writeInstParam{\rlx}{z}{1}; \writeInstParam{\rlx}{y}{1}} \;
  \angled{\writeInstParam{\rlx}{y}{1}}}.\]
После того, как в подбуферах оказываются одинаковые инструкции
(в данном случае это $\writeInstParam{\rlx}{y}{1}$), и перед ними в подбуферах нет
конфликтующих инструкций, модель $\OpCpp$ может вынести их на предыдущей уровень буфера:
\[\angled{\readInstParam{\rlx}{a}{x}; \writeInstParam{\rlx}{y}{1};
  \kw{if} \; a \; \angled{\writeInstParam{\rlx}{z}{1}} \;
  \angled{} }.\]
Далее, поскольку инструкции $\readInstParam{\rlx}{a}{x}$ и $\writeInstParam{\rlx}{y}{1}$
независимы, то $\writeInstParam{\rlx}{y}{1}$
может быть выполнена, после чего в памяти появляется новое сообщение:
\[
\begin{array}{@{}l@{}}
M = \{\angled{x:0@\tstamp{0}, [x@\tstamp{0}]}, \angled{y:0@\tstamp{0},[y@\tstamp{0}]},
      \angled{z:0@\tstamp{0},[z@\tstamp{0}]}, \graybox{\angled{y:1@\tstamp{1},[y@\tstamp{1}]}}\}.
\end{array}
\]
После этого результат $c = 1$ получается следующим образом.
Правый поток читает из нового сообщения, присваивая $1$ в $b$.
Поскольку в правом потоке условие после этого было вычислено к $1$,
то может быть выполнена инструкция записи в локацию $x$:
\[
\begin{array}{@{}l@{}}
M = \{\angled{x:0@\tstamp{0}, [x@\tstamp{0}]}, \angled{y:0@\tstamp{0},[y@\tstamp{0}]}, \angled{z:0@\tstamp{0},[z@\tstamp{0}]}, \\
\qquad \angled{y:1@\tstamp{1},[y@\tstamp{1}]}, \graybox{\angled{x:1@\tstamp{1},[x@\tstamp{1}]}}\}.
\end{array}
\]
После этого, левый поток может выполнить отложенное чтение $\readInstParam{\rlx}{a}{x}$ из добавленного сообщения.
Так, в буфере левого потока остаётся только одна запись,
соответствующая отложенной конструкции $\kw{if}$, чьё условие было вычислено к $1$:
\[\angled{
  \kw{if} \; 1 \; \angled{\writeInstParam{\rlx}{z}{1}} \;
  \angled{}}.\]
После вычисления отложенной конструкции $\kw{if}$ и выполнения записи в $z$ в памяти находится шесть сообщений:
\[
\begin{array}{@{}l@{}}
M = \{\angled{x:0@\tstamp{0}, [x@\tstamp{0}]}, \angled{y:0@\tstamp{0},[y@\tstamp{0}]}, \angled{z:0@\tstamp{0},[z@\tstamp{0}]}, \\
\qquad \angled{y:1@\tstamp{1},[y@\tstamp{1}]}, \angled{x:1@\tstamp{1},[x@\tstamp{1}]}, \graybox{\angled{z:1@\tstamp{1},[z@\tstamp{1}]}}\}.
\end{array}
\]
Чтение из последней записи в локацию $z$ приводит к результату $c = 1$.

Идея перевода повторяющихся инструкций из вложенных буферов естественным образом обобщается на
случай вложенных условных операторов.

\subsection{$\sco$-инструкции}
Оригинальная модель C/C++11 гарантирует наличие тотального порядка $\lSC$ на $\sco$-событиях,
который не противоречит программному порядку $\lPO$, отношению ``синхронизируется с'' $\lSW$,
и порядку памяти $\lMO$.
Помимо этого $\sco$-чтение обладает теми же свойствами, что и приобретающее чтение,
а $\sco$-записи --- что и высвобождающие записи.

Рассмотрим программу ${\rm SB\text{-}sc}$ (store buffering, буферизация записи).
\begin{equation*}
\tag{SB-sc}
\begin{tabular}{c}
  $\writeInstParam{\sco}{x}{0}; \writeInstParam{\sco}{y}{0};$ \\
\begin{tabular}{L || L}
  \writeInstParam{\sco}{x}{1}; & \writeInstParam{\sco}{y}{1} \\
 \readInstParam{\sco}{a}{y};   & \readInstParam{\sco}{b}{x}; \\
\end{tabular}
\end{tabular}
\end{equation*}
Для этой программы оригинальная модель C/C++11 запрещает результат $[a = 0, b = 0]$.
Это объясняется тем, что в её сценарии поведения
как минимум одно из чтений находится позже все остальных событий в отношении $\lSC$,
а это значит, что соответствующий поток в момент исполнения этого чтения осведомлён о всех ($\sco$-)записях в программе.

Для того, чтобы гарантировать аналогичное ограничение, в состояние машины $\OpCpp$ добавляется глобальный
(общий для всех потоков) компонент --- \emph{$\sco$-фронт} $\Rsc$.
Этот фронт используется следующим образом: при выполнении $\sco$-чтения из локации $\loc$
поток обновляет свой базовый фронт на $[\loc @ \Rsc(\loc)]$, а при выполнении $\sco$-записи
в локацию $\loc$ сообщения с меткой времени $\tau$ поток обновляет $\sco$-фронт на $[\loc@\tau]$.
Таким образом, $\sco$-чтение из локации $\loc$ не может прочитать сообщение в памяти, которое имеет
меньшую метку времени, чем метка сообщения в ту же локацию, которое было записано последней на тот момент $\sco$-записью.

\subsection{Неатомарные обращения}
Согласно модели C/C++11 программы с гонками по данным, в которых участвуют неатомарные обращения к памяти,
обладают неопределенном поведением. Так, рассмотрим следующую программу.
\begin{equation*}
\tag{DR-rlx-na}
\begin{tabular}{c}
  $\writeInstParam{\na}{d}{0};$ \\
\begin{tabular}{L || L}
 \writeInstParam{\rlx}{d}{1};   & \readInstParam{\na}{a}{d}; \\
\end{tabular}
\end{tabular}
\end{equation*}
В ней есть гонка по данным между инструкциями $\writeInstParam{\rlx}{d}{1}$ и $\readInstParam{\na}{a}{d}$.
Мы можем идентифицировать эту гонку с помощью базовых фронтов в случае сценария исполнения, в котором
сначала левый поток выполняет запись, а потом правый --- чтение.
В такой ситуации правый поток будет выполнять неатомарную операцию над локацией $d$, при этом не
являясь осведомленным о последний записи в данную локацию.
Если модель $\OpCpp$ идентифицировала гонку по данным,
в которую вовлечена неатомарная операция хотя бы в одном сценарии поведения программы,
то считается, что программа в целом обладает неопределенным
поведением.

Рассмотрим похожую программу, содержащую гонку по данным.
\begin{equation*}
\tag{DR-na-rlx}
\begin{tabular}{c}
  $\writeInstParam{\na}{d}{0};$ \\
\begin{tabular}{L || L}
 \writeInstParam{\na}{d}{1};  & \readInstParam{\rlx}{a}{d}; \\
\end{tabular}
\end{tabular}
\end{equation*}
Идентификация гонки в данном случае не может быть проведена только с помощью базовых фронтов потоков.
Для решения проблемы мы вводим в состояние машины $\OpCpp$ ещё один глобальный фронт --- \emph{$\na$-фронт} $\Rna$.
Подобно $\sco$-фронту, $\na$-фронт по локации возвращает метку времени последней $\na$-записи в неё.
Так, при выполнении любой операции над локацией $\loc$ поток проверяет, что он осведомлён о последней
$\na$-записи в $\loc$ (т.е. его базовый фронт по $\loc$ больше или равен $\Rna(\loc)$),
и если это не так, то машина $\OpCpp$ сигнализирует о гонке.

С помощью такой техники гонка по данным в программе ${\rm DR\text{-}na\text{-}rlx}$ идентифицируется в сценарии
поведения, в котором $\na$-запись левого потока выполняется до $\rlx$-чтения правого потока.

\subsection{Потребляющие чтения}
Потребляющее (consume, $\con$) чтение является более слабой версией приобретающего чтения.
Так, приобретающее чтение обновляет базовый фронт потока с помощью фронта прочитанного сообщения
и тем самым влияет на все последующие инструкции, тогда как потребляющее чтение действует только
на последующие чтения, которые зависят от него по адресу%
\footnote{Инструкция чтения $i$ \emph{зависит по адресу} от инструкции чтения $j$, если
целевой адрес $i$ зависит от результата исполнения $j$.}.

Рассмотрим программу, в которой используется потребляющее чтение.
\begin{equation*}
\tag{MP-con-na-2}
\begin{tabular}{c}
  $\writeInstParam{\na}{p}{\nullPtr}; \writeInstParam{\na}{d}{0}; \writeInstParam{\na}{x}{0};$ \\
\begin{tabular}{L || L}
  \begin{array}{@{}l@{}}
    \writeInstParam{\rlx}{x}{1}; \\
    \writeInstParam{\na}{d}{1}; \\
    \writeInstParam{\rel}{p}{d} \\
  \end{array}
  &
  \begin{array}{@{}l@{}}
    \readInstParam{\con}{a}{p}; \\
    \iteml{a \neq \nullPtr}
          {\readInstParam{\na}{b}{a}; \\
           \readInstParam{\rlx}{c}{x}}
          {\assignInst{b}{0}; \\ \assignInst{c}{0}}
  \end{array}
\end{tabular}
\end{tabular}
\end{equation*}
В этой программе левый поток передаёт информацию, записанную в локацию $d$, правому потоку через указатель $p$.
Правый поток с помощью $\con$-чтения получает содержимое указателя $p$ в переменную $a$.
Если переменная $a$ не равна $\nullPtr$, то поток читает из той локации, на которую указывает $a$ (в данном случае на локацию $d$),
а потом --- из локации $x$.
У этой программы существует три возможных результата исполнения в модели C/C++11:
$[a = \nullPtr, b = 0, c = 0]$,
$[a = d, b = 1, c = 1]$ и
$[a = d, b = 1, c = 0]$.
Если в программе $\con$-чтение заменить на $\acq$-чтение, то последний результат станет невозможным,
т.к. после выполнения $\readInstParam{\acq}{a}{p}$ с результатом $d$ базовый фронт правого потока будет
указывать на сообщения, которые были получены в результате исполнения $\writeInstParam{\rlx}{x}{1}$ и
$\writeInstParam{\na}{d}{1}$.
В то же время $\con$-чтение $\readInstParam{\con}{a}{p}$ ``синхронизирует'' только последующее чтение $\readInstParam{\na}{b}{a}$,
т.к. оно является разыменованием результата $\con$-чтения и не влияет на независимое чтение $\readInstParam{\rlx}{c}{x}$.

Для поддержки подобного поведения модель $\OpCpp$ может \emph{аннотировать} с помощью фронтов инструкции чтения, которые зависят
от $\con$-чтений. Когда потребляющее чтение получает из памяти сообщение $\angled{\loc:\val@\tau,\R}$,
оно, вместо того, чтобы обновить базовый фронт потока с помощью $\R$, как это сделало бы приобретающее чтение,
помечает все зависимые от него инструкции чтения фронтом $\R$.
В дальнейшем, когда помеченная инструкция чтения будет исполняться, она скомбинирует
базовый на тот момент фронт потока 
с фронтом-пометкой для того, чтобы вычислить минимальную метку времени, сообщение с которой доступно для чтения.
Аналогичным образом помечаются и обрабатываются отложенные чтения в операционных буферах, которые ссылаются
на символьный результат $\con$-чтения.

\subsection{Соединение потоков}
\label{sec:opc11:join}
В момент соединения потоков, т.е. когда оба потока закончили своё исполнение,
естественно ожидать, что все отложенные операции были выполнены, и, соответственно,
операционные буфера пусты.
Это подтверждается тем, что в оригинальной модели C/C++11 \cite{Batty-al:POPL11}
используется отношение ``дополнительно синхронизируется с'' (additional-synchronizes-with, $\lASW$),
которое связывает последние событие потока с первой следующей за потоком инструкцией родительского потока.
Отношение $\lASW$ является частью отношения $\lHB$. Это означает, что родительский поток
оказывается осведомлен о всех тех сообщениях, которые были прочитаны дочерними потоками.
В модели $\OpCpp$ это выражается тем, что соединение потоков возможно, только если их операционные буфера
пусты, а после соединения потоков родительский поток получает базовый фронт,
равный комбинации базовых фронтов соединяемых потоков.

Тем не менее, это противоречит стандартам C и C++11, требующим, чтобы
оптимизация секвенциализации ($C_1\;||\;C_2 \optarrow C_1;\;C_2$) была корректной.
Это делает предыдущие предположения некорректными.
Данная проблема может быть проиллюстрирована на следующей программе,
в которой параллельная композиция с пустым потоком может быть заменена на
не пустой поток.
\begin{equation*}
\tag{LB-rlx-join}
\begin{tabular}{c}
  $\writeInstParam{\rlx}{x}{0}; \writeInstParam{\rlx}{y}{0};$ \\
\begin{tabular}{L || L || L || L}
  \begin{array}{@{}l@{}}
    \readInstParam{\rlx}{a}{y} \\
  \end{array}
  &
\skipc
  &
  \begin{array}{@{}l@{}}
    \readInstParam{\rlx}{b}{x} \\
  \end{array}
  &
\skipc \\
\multicolumn{2}{c ||}{$\writeInstParam{\rlx}{x}{1}$} &
\multicolumn{2}{c}{$\writeInstParam{\rlx}{y}{1}$}
\end{tabular}
\end{tabular}
\end{equation*}
Если применить такую оптимизацию к одной из композиций потоков,
то результат $[a = 1, b = 1]$ станет возможным.
Для того, чтобы поддержать данный сценарий поведения,
мы допускаем альтернативное правило соединения потоков как отдельный аспект в интерпретаторе модели.

\subsection{Расслабленные обращения и синхронизация}
Между расслабленными операциями, высвобождающими записями и
приобретающими чтениями существует тонкое взаимодействие.
В этом подразделе мы опишем варианты этого взаимодействия, а также
принятые в связи с ним технические решения в модели $\OpCpp$.

\subsubsection{Высвобождающие цепочки}
\label{sec:opc11:releaseseq}
В связи с тем, что расслабленное чтение не может участвовать в синхронизации,
его исполнение не обновляет базовый фронт потока фронтом прочитанного сообщения,
как это происходит в случае приобретающего чтения.
Тем не менее, если приобретающее чтение потока $T_2$ читает из сообщения, которое
было добавлено расслабленной записью $w_{\rlx}$ потока $T_1$, то оно должно синхронизироваться
с высвобождающей записью в ту же локацию $w_{\rel}$, предшествующей $w_{\rlx}$ в потоке $T_1$,
если такая запись существует.
Это свойство является аналогом высвобождающих цепочек (release sequences) из аксиоматической
модели C/C++11 \cite{Batty-al:POPL11}.

Рассмотрим вариант программы ${\rm MP}$, в сценариях поведения которого имеется описанная выше синхронизация.
\begin{equation*}
\tag{MP-rel-acq-na-rlx-2}
\begin{tabular}{c}
  $\writeInstParam{\na}{f}{0}; \writeInstParam{\na}{d}{0}; \writeInstParam{\na}{x}{0};$ \\
\begin{tabular}{L || L}
  \begin{array}{@{}l@{}}
    \writeInstParam{\na}{d}{5}; \\
    \writeInstParam{\rel}{f}{1}; \\
    \writeInstParam{\rel}{x}{1}; \\
    \writeInstParam{\rlx}{f}{2} \\
  \end{array}
  &
  \begin{array}{@{}l@{}}
    \repeatInst{\readInstParam{\acq}{c}{f}; c == 2}; \\
    \readInstParam{\na}{a}{d}; \\
    \readInstParam{\rlx}{b}{x} \\
  \end{array}
\end{tabular}
\end{tabular}
\end{equation*}
Единственным значением, которое может получить регистр $a$, является $5$.
Это объясняется тем, что 
последнее приобретающее чтение $\readInstParam{\acq}{c}{f}$ в цикле должно прочитать значение $2$,
следовательно синхронизироваться с высвобождающей записью $\writeInstParam{\rel}{f}{1}$.
В то же время регистр $b$ может получить как значение $0$, так и $1$, поскольку
$\writeInstParam{\rel}{f}{1}$, с которым синхронизируется приобретающее чтение, предшествует
записи $\writeInstParam{\rel}{x}{1}$, и поэтому информация об этой записи $x$ не попадает
во фронт сообщения, записанного инструкцией $\writeInstParam{\rel}{f}{1}$.

Для того, чтобы выразить такую синхронизацию, у каждого потока в машине $\OpCpp$ имеется
\emph{фронт записи} (write-front) $\Rwrite$.
Этот фронт для каждой локации возвращает метку времени последней высвобождающей записи,
сделанной потоком в эту локацию.
Когда поток выполняет расслабленную запись в локацию $\loc$ с меткой времени $\tau$,
в соответствующее сообщение записывается фронт, который является комбинацией $[\loc@\tau]$
и фронта сообщения в $\loc$ с меткой времени $\Rwrite(\tau)$, которое было записано
высвобождающей записью того же потока.

\subsubsection{Отложенные расслабленные обращения и синхронизация}
Рассмотрим вариант программы ${\rm LB}$, в которой инструкции чтения
являются расслабленными, а записи --- высвобождающими.
\begin{equation*}
\tag{LB-rel-rlx}
\begin{tabular}{c}
  $\writeInstParam{\rlx}{x}{0}; \writeInstParam{\rlx}{y}{0};$ \\
\begin{tabular}{L || L}
  \readInstParam{\rlx}{a}{x}; & \readInstParam{\rlx}{b}{y}; \\
  \writeInstParam{\rel}{y}{1} & \writeInstParam{\rel}{x}{1} \\
\end{tabular}
\end{tabular}
\end{equation*}
Согласно оригинальной модели C/C++11 эта программа имеет сценарий поведения с результатом $[a = 1, b = 1]$,
поскольку высвобождающие записи не накладывают никаких дополнительных ограничений в отсутствии
приобретающих чтений.
Поэтому модель $\OpCpp$ разрешает исполнять высвобождающие записи даже в тот момент, когда
предшествующие отложенные инструкции чтения ещё не выполнены.

Тем не менее, требуются ввести некоторые ограничения на откладывание инструкций
чтения за высвобождающие записи.
Рассмотрим ещё один вариант программы ${\rm LB}$.
\begin{equation*}
\tag{LB-rel-acq-rlx}
\begin{tabular}{c}
  $\writeInstParam{\rlx}{x}{0}; \writeInstParam{\rlx}{y}{0};$ \\
\begin{tabular}{L || L}
  \readInstParam{\acq}{a}{x}; & \readInstParam{\rlx}{b}{y}; \\
  \writeInstParam{\rlx}{y}{1} & \writeInstParam{\rel}{x}{1} \\
\end{tabular}
\end{tabular}
\end{equation*}
В этой программе в левом потоке есть приобретающее чтение, а в правом --- высвобождающая запись.
Если это чтение прочитает сообщение, сделанное инструкцией $\writeInstParam{\rel}{x}{1}$,
т.е. регистр $a$ получит значение $1$, то в терминах оригинальной модели между
$\readInstParam{\rlx}{b}{y}$ и $\writeInstParam{\rlx}{y}{1}$ возникнет ребро отношения ``предшествует'' $\lHB$.
Как следствие, регистр $b$ не может получить значение $1$, т.к. чтение не может прочитать то, что записано
последующей за ним записью.
Таким образом, модель $\OpCpp$ должна предотвращять ситуацию, когда чтение, которое было отложено через
высвобождающую запись $W$, выполняется после того, как другой поток прочитал сообщение $W$ с помощью приобретающего
чтения.

Для реализации данного ограничения мы добавляем глобальный компонент $\stGamma$ в состояние машины $\OpCpp$,
который является списком троек, которые состоят из локации, метки времени некоторого существующего сообщения
и символического значения, идентифицирующего отложенное чтение.
При выполнении высвобождающей записи $W$, которая добавляет сообщение локации $\loc$ с меткой времени $\tau$,
для каждого отложенного потоком чтения в список $\stGamma$ добавляется по тройке $\angled{\loc,\tau, \vName}$, где
$\vName$ --- символическим значение чтения.
При этом приобретающее чтение из сообщения локации $\loc$ с меткой времени $\tau$ возможно
 только в том случае,
если в $\stGamma$ не осталось записей вида $\angled{\loc, \tau, \_}$,
а выполнение отложенного чтения с символическим значением $\vName$ удаляет из $\stGamma$ все тройки
$\angled{\_,\_,\vName}$.

Следующая программа показывает ещё одну тонкость, которая связана с откладыванием
расслабленных записей через высвобождающие.
\begin{equation*}
\tag{WR-rlx-rel}
\begin{tabular}{c}
  $\writeInstParam{\rlx}{x}{0}; \writeInstParam{\rlx}{y}{0};$ \\
\begin{tabular}{L || L}
  \writeInstParam{\rlx}{x}{1}; & \writeInstParam{\rlx}{y}{1}; \\
  \writeInstParam{\rel}{y}{1} & \writeInstParam{\rel}{x}{1} \\
\end{tabular}\\
  $\readInstParam{\rlx}{a}{x}; \readInstParam{\rlx}{b}{y}$ \\
\end{tabular}
\end{equation*}
Согласно оригинальной модели C/C++11 результат $[a = 1, b = 1]$ возможен для этой
программы, и это требует, чтобы сообщения расслабленных записей попали в память
после сообщений высвобождающих.
При этом, если другой (третий) поток выполнит приобретающее чтение из сообщения,
сделанного одной из высвобождающих записей, то он должен стать осведомлённым о
предшествующей расслабленной записи, а для этого соответствующее сообщение должно
находиться в памяти. 

Аналогично предыдущему пункту мы решаем данную проблему с помощью списка $\stGamma$.
При исполнении высвобождающей записи также, как и для отложенных чтений, в списке $\stGamma$
появляются тройки, связанные с отложенными записями.
Единственным отличием от обработки отложенных чтений является то, что при выполнении отложенной
записи $W$ мы не только удаляем все тройки $\angled{\loc, \tau, \vName}$, где $\vName$ --- символьный
идентификатор записи, но и увеличиваем фронт сообщения локации $\loc$ с меткой времени $\tau$ на
$[\loc'@\tau']$, где $\loc'$ и $\tau'$ связаны с сообщением $W$.


\app{TODO: Подвести итог}
Ключевыми понятиями в модели являются \emph{фронты} и \emph{операционные буфера}.
Фронты используются для представления знания (осведомленности) потоков
о текущем состоянии общей памяти,
тогда как операционные буфера позволяют откладывать исполнение инструкций и
производить спекулятивные вычисления.


\section{Формальное определение модели}
\label{sec:opc11:formal}
В разделе приводится математическое определение операционной модели C/C++11,
начиная с определения синтаксиса языка, для которого задана модель,
представления памяти и фронтов.

\subsection{Синтаксис языка модели и базовые правила редукции}
\label{sec:opc11:formal:baselang}
Синтаксис языка модели представлен на рис. \ref{fig:opc11:syntax}.
Мета-переменная $\Expr$ представляет выражения, которые могут быть
целыми числами $z$, локациями $\loc$, неизменяемыми локальными
переменными $\vName$, парами, проекциями пар или бинарными выражениями.
Конструкция $\kw{choice}$ является недетерминированным выбором между двумя
выражениями.

\begin{figure}%[t]\small
\[\begin{array}{rcl}
   %% \multicolumn{3}{c}{\text{\textbf{Statements and Expressions}}} 
   %% \\[3pt] 
\Expr   & ::= & \vName \mid z~(\in \Number) \mid \Expr_{1}~\op~\Expr_{2}
                \mid \Choice~\Expr_{1}~\Expr_{2} \\
        &     & \First{\Expr} \mid \Second{\Expr} \mid \Pair{\Expr_{1}}{\Expr_{2}} \mid \locVar\\
\op     & ::= & + \mid - \mid * \mid / \mid \% \mid \texttt{==} \mid \neq \\
\locVar & ::= & \loc \mid \vName \\
\loc    & \text{---} & \text{идентификатор локации} \\
\vName  & \text{---} & \text{локальная переменная} \\ 
\mvalSubst & ::= & \loc \mid z \mid \Pair{\mvalSubst_{1}}{\mvalSubst_{2}} \\  
\\
\AST & ::=  & \Ret{\Expr} \mid\Bind{\vName}{\AST_{1}}{\AST_{2}} \mid
              \Spw{\AST_{1}}{\AST_{2}}  \mid\\
     &      & \itesl{\Expr}{\AST_{1}}{\AST_{2}} \mid
              \repeatInst{\AST} \mid \\
     &      & \readExpr{\RM}{\locVar} \mid
              \writeInstParam{\WM}{\locVar}{\Expr} 
              \mid \Cas{SM}{FM}{\locVar}{\Expr_{1}}{\Expr_{2}} \\
\RT & ::=  & \Stuck \mid \Par{\AST_{1}}{\AST_{2}}\\
% \\
% \auxX   & \text{---} & \text{a generic state (to be defined)}\\ 
              \\
\RM   & ::= & \sco \mid \acq \mid \con \mid \rlx \mid \na \\
\WM   & ::= & \sco \mid \rel \mid \rlx \mid \na \\
\SM   & ::= & \sco \mid \relAcq \mid \rel \mid \acq \mid \con \mid \rlx \\
\FM   & ::= & \sco \mid \acq \mid \con \mid \rlx
\end{array}\]
\caption{Синтаксис операций и выражений языка модели $\OpCpp$}
\label{fig:opc11:syntax}
\end{figure}

Программы представляются как операторы $\AST$, где $\Bind{\vName}{\AST_{1}}{\AST_{2}}$ --- это let-выражение,
$\Spw{\AST_{1}}{\AST_{2}}$ --- параллельная композиция потоков,
$\readExpr{\RM}{\locVar}$ --- выражение, читающее из памяти.
В наших примерах мы также используем $\skipc$ как альтернативное представление константного выражения $0$;
$\readInstParam{\RM}{\vName}{\locVar}$ и $\assignInst{\vName}{\Expr}$ для обозначения
$\Bind{\vName}{\readExpr{\RM}{\locVar}}{\Ret{\vName}}$ и $\Bind{\vName}{\Expr}{\Ret{\vName}}$;
$\AST_{1}; \AST_{2}$ вместо $\Bind{\vName'}{\AST_{1}}{\AST_{2}}$, где $\vName'$ не встречается в $\AST_{2}$;
а также $\AST_{1} {\sf ||} \AST_{2}$ для обозначения $\Spw{\AST_{1}}{\AST_{2}}$.

Результатом полностью вычисленной программы является либо значение $\mvalSubst$,
либо значение времени исполнения (run-time value) $\Stuck$, которое символизирует, что-то пошло не так ---
в исполнении найдена гонка по данным или была попытка чтения из неинициализированной переменной.
Другой конструкцией времени исполнения является $\Par{\AST_{1}}{\AST_{2}}$, которая получается
в результате редукции $\Spw{\AST_{1}}{\AST_{2}}$ и представляет находящиеся в исполнении потоки.
На шаге операционной семантики, который редуцирует $\Spw{\AST_{1}}{\AST_{2}}$ в $\Par{\AST_{1}}{\AST_{2}}$,
происходит необходимая инициализация компонент машины $\OpCpp$.

Мета-переменная $\auxX$ представляет динамическое состояние машины с точностью до программы; оно описано ниже.
Вычисление программы $\AST$ в машине $\OpCpp$ начинается со стартового состояния $\angled{\AST, \auxX_{init}}$,
где $\auxX_{init}$ содержит пустую память и пустой базовый фронт для единственного стартового потока.
Переходы машины заданы в редукционном стиле~\cite{Felleisen-Hieb:TCS92},
большинство из них имеют следующую форму:
\begin{mathpar}
\inferrule{
  \dots
}
{{\tup{\EvalContext[\AST], \auxX}}  \astep{}
 {\tup{\EvalContext[\AST'], \auxX'}}}
\end{mathpar}
Здесь $\EvalContext$ --- это \emph{редукционный контекст}, заданный так: 
%
{
\[\begin{array}{rcl}
   %% \multicolumn{3}{c}{\text{\textbf{Evaluation contexts}}} 
   %% \\[3pt]
\EvalContext   & ::= & \hole
                         \mid \Bind{\vName}{\EvalContext}{\AST}  \mid \Par{\EvalContext}{\AST}
                       \mid \Par{\AST}{\EvalContext}. \\  
%% \EvalEUContext & ::= & \hole \mid (\EvalEUContext) \mid
%%                          \EvalEUContext~\op~\Expr \mid
%%                          \Expr~\op~\EvalEUContext \\
%%                &     &   \mid \Pair{\mval}{\EvalEUContext}
%%                          \mid \Pair{\EvalEUContext}{\mval} \\ 
%%                &     &   \mid \First{\EvalEUContext}
%%                          \mid \Second{\EvalEUContext} \\ 
%%                &     &   \mid \Choice{~\EvalEUContext}{\Expr} \mid
%%                          \Choice{~\Expr}{\EvalEUContext} \\
%%                &     &   \mid \Bind{\vName}{\EvalEUContext}{\AST} \\
%%                &     &   \mid \IfThenElse{\EvalEUContext}{\AST_{1}}{\AST_{2}} \\
%%                &     &   \mid \Write{\WM}{\locVar}{\EvalEUContext} \\
%%                &     &   \mid \Cas{SM}{FM}{\locVar}{\EvalEUContext}{\mval}
%%                          \mid \Cas{SM}{FM}{\locVar}{\mval}{\EvalEUContext} \\
\end{array}\]
}
Если в момент исполнения программы запущено более одного потока, т.е. в программном выражении
присутствует узел $\kw{par}$, то программное выражение может быть разбито
на контекст и подпрограмму недетерминированно, несколькими способами.

\begin{figure*}
\begin{mathpar}
\inferrule[Subst]{\quad
}
{
\angled{\EvalContext[\Bind{\vName}{\Ret{\mvalSubst}}{\AST}], \auxX} 
 \astep{}
\angled{\EvalContext[\AST\subst{\vName}{\mvalSubst}], \auxX}
} \\

\inferrule[If-False]{\quad}
{
 \angled{\EvalContext[\itesl{0}{\AST_{1}}{\AST_{2}}], \auxX}
 \astep{}
 \angled{\EvalContext[\AST_{2}]], \auxX}
} \\
\inferrule[If-True]{n \neq 0}
{
 \angled{\EvalContext[\itesl{n}{\AST_{1}}{\AST_{2}}], \auxX}
 \astep{}
 \angled{\EvalContext[\AST_{1}]], \auxX}
} \\

\inferrule[Repeat-Unroll]{
  \vName \text{ -- новая переменная}
}
{
 \angled{\EvalContext[\Repeat{\AST}], \auxX}
 \astep{} \\
 \quad \angled{\EvalContext[\Bind{\vName}{\AST}
                 {\IfThenElse{\vName}{\Ret{\vName}}
                              {\Repeat{\AST}}}],
            \auxX}
} \\

\inferrule[Spawn]{
\auxX' = \spawn{\EvalContext}{\auxX}}
{
\angled{\EvalContext[\Spw{\AST_{1}}{\AST_{2}}], \auxX}
 \astep{}
\angled{\EvalContext[\Par{\AST_{1}}{\AST_{2}}], \auxX'}
} \and

\inferrule[Join]{
\auxX' = \joinP{\EvalContext}{\auxX}
}{
\angled{\EvalContext[\Par{\Ret{\mvalSubst_{1}}}{\Ret{\mvalSubst_{2}}}], \auxX}
 \astep{}
\angled{\EvalContext[\Ret{\Pair{\mvalSubst_{1}}{\mvalSubst_{2}}}], \auxX'}
} \\

\inferrule[Choice-Fst]{\quad
}{
  \angled{\EvalContext[\EvalEUContext[\Choice{~\Expr_{1}}{\Expr_{2}}]], \auxX} \astep{} %\\
  \angled{\EvalContext[\EvalEUContext[\Expr_{1}]], \auxX}
} \\

\inferrule[Choice-Snd]{\quad
}{
  \angled{\EvalContext[\EvalEUContext[\Choice{~\Expr_{1}}{\Expr_{2}}]], \auxX} \astep{} %\\
  \angled{\EvalContext[\EvalEUContext[\Expr_{2}]], \auxX}
} \\
\end{mathpar}
\caption{Базовые правила модели $\OpCpp$}
\label{fig:opc11:baseSem}
\end{figure*}
Базовые правила семантики, которые не затрагивают операций над памятью, приведены на рисунке \ref{fig:opc11:baseSem}.
Из них интерес представляют правила ${\rm Spawn}$ и ${\rm Join}$, которые описывают старт и соединение дочерних
потоков соответственно. Эти правила модифицируют компоненты состояния машины $\OpCpp$, которые являются локальными для
потоков, например, базовый фронт и операционный буфер.
Конкретные представления правил ${\rm Spawn}$ и ${\rm Join}$ зависят от многопоточных аспектов модели,
которые определяют мета-функции ${\sf spawn}$ и ${\sf join}$.

\subsection{Представление памяти и фронтов}
\label{sec:opc11:formal:histories}
В базовом представлении состояние $\auxX$ машины $\OpCpp$ включает в себя память $M$ и функцию
$\stPsiRead$, которая по идентификатору потока $\stpath$ возвращает его базовый фронт
(см. рис. \ref{fig:auxXrelAcq}).

\begin{figure}
\[\begin{array}{l r c l}
\text{Состояние} & \auxX      & ::= & \angled{\stEta, \stPsiRead} \\
\text{Память} &\stEta     & ::= & (\loc, \stTau) \prarrow \angled{\mvalSubst, \stSigma}\\ 
%% \stEtaLoc  & ::= & \stTau \prarrow \angled{\mvalSubst, \stSigma}\\
\text{Функция базового фронта} & \stPsiRead & ::= & \stpath \prarrow \stSigma\\
\text{Фронт} & \stSigma   & ::= & \loc \prarrow \stTau\\
\text{Идентификатор потока} & \stpath    & \text{---} & (l|r)^{*}\\
\text{Метка времени} & \stTau & \in & \mathbb{N} \\ 
\end{array}\]
\caption{Базовое состояние машины $\OpCpp$}
\label{fig:auxXrelAcq}
\end{figure}

Память $\stEta$ --- это частичная функция, которая по локации и метке времени возвращает
сохраненное значение и синхронизационный фронт.
Разные аспекты модели используют фронты по-разному, но каждый фронт является частичной
функцией, которая по локации возвращает некоторую метку времени.
Функция базового фронта возвращает базовый фронт потока по его идентификатору $\stpath$,
где идентификатор потока --- это список направлений лево (l) / право (r), который показывает,
как найти подвыражение потока во всем выражении программы, проходя по вершинам $\kw{par}$.
Это путь уникально идентифицирует поток.
Для вычисления пути по редукционному контексту мы используем вспомогательную функцию $\textsf{path}$.

Стартующие дочерние потоки наследуют базовый фронт родительского потока, что
в терминах самой простой версии функции ${\sf spawn}$ определяется следующим образом:
%
\[
\spawn{\EvalContext}{\angled{\stEta,\stPsiRead}} \triangleq
\angled{\stEta, \stPsiRead
[\stpath\:l \mapsto \stSigmaRead,~\stpath\:r \mapsto \stSigmaRead]},
\]
где $\stpath = {\sf path}(\EvalContext)$ и $\stSigmaRead = \stPsiRead(\stpath)$.
Когда потоки соединяются, базовый фронт их родительского потока становится покомпонентным
максимумом базовых фронтов дочерних потоков:
\[
\joinP{\EvalContext}{\angled{\AST,\stPsiRead}} =
\angled{\AST, \stPsiRead[\stpath \mapsto \stSigmaRead^{l} \sqcup \stSigmaRead^{r}]},
\]
%
где $\stpath = \Path(\EvalContext)$,
$\stSigmaRead^{l} = \stPsiRead(\stpath\:l)$ и
$\stSigmaRead^{r} = \stPsiRead(\stpath\:r)$.

\begin{figure}
\begin{mathpar}
  \inferrule[Read-Uninit]{
  \auxX = \angled{\stEta, \stPsiRead} \quad \stpath = \Path(\EvalContext) \quad
  \stSigmaRead = \stPsiRead(\stpath) \quad \stSigmaRead(\loc) = \bot
  }{
\angled{\EvalContext[\readExpr{\RM}{\loc}], \auxX} \astep{} 
\angled{\Stuck, \auxX_{init}}
  }\\

  \inferrule[CAS-Uninit]{
  \auxX = \angled{\stEta, \stPsiRead} \quad \stpath = \Path(\EvalContext) 
  \quad
  \stSigmaRead = \stPsiRead(\stpath) \quad \stSigmaRead(\loc) = \bot
  }{
  \angled{\EvalContext[\Cas{\SM}{\FM}{\loc}{\Expr_{1}}{\Expr_{2}}], \auxX} \astep{} 
  \angled{\Stuck, \auxX_{init}}
  }
\end{mathpar}
\caption{Правила чтения из неинициализированной локации}
\label{fig:uninit-stuckRules}
\end{figure}

Далее мы определяем первый набор правил о ``плохих'' сценариях поведения ---
чтение из неинициализированной локации (см. рис. \ref{fig:uninit-stuckRules}).
Эти правила срабатывают в том случае, если поток, пытающийся прочитать значение из локации $\loc$,
не осведомлен ни об одной записи, т.е. его базовый фронт не определён для $\loc$.
В частном случае эти правила применимы, если в локацию не было сделано ни одной записи в принципе.

\subsection{Высвобождающие и приобретающие обращения}
\label{sec:opc11:formal:ra}

\begin{figure}
\begin{mathpar}
  \inferrule[Write-Release]{
  \auxX = \angled{\stEta, \stPsiRead} \quad \stpath = \Path(\EvalContext) \quad
  \stTau = \NextTau{\stEta}{\loc} \\
  \stSigmaRead = \stPsiRead(\stpath) \quad
  \stSigma = \stSigmaRead[\loc \mapsto \stTau] \\
  \auxX' = \angled{\stEta[(\loc, \stTau) \mapsto (\mvalSubst, \stSigma)],
                   \stPsiRead[\stpath \mapsto \stSigma]}
  }{
\angled{\EvalContext[\writeInstParam{\rel}{\loc}{\mvalSubst}], \auxX} \astep{} 
\angled{\EvalContext[\Ret{\mvalSubst}], \auxX'}
  } \\

  \inferrule[Read-Acquire]{
  \auxX = \angled{\stEta, \stPsiRead} \quad \stpath = \Path(\EvalContext) \quad 
  \stEta(\loc, \stTau) = (\mvalSubst, \stSigma) \\
  \stSigmaRead = \stPsiRead(\stpath) \quad
  \stSigmaRead(\loc) \leq \stTau \\
  \auxX' = \angled{\stEta, \stPsiRead[\stpath \mapsto \stSigmaRead \sqcup \stSigma]}
  }{
\angled{\EvalContext[\readExpr{\acq}{\loc}], \auxX} \astep{} 
\angled{\EvalContext[\Ret{\mvalSubst}], \auxX'}
  }
\end{mathpar}
\caption{Правила высвобождающей записи и приобретающего чтения}
\label{fig:rel/acq-sem}
\end{figure}

Правила, описывающие поведение высвобождающих записей и приобретающих чтений, приведены на рис. \ref{fig:rel/acq-sem}.
Высвобождающая запись добавляет в память новую запись $(\loc, \tau) \mapsto (\mvalSubst, \stSigma)$, где
$\mvalSubst$ --- записываемое значение, а $\stSigma$ --- фронт добавленного сообщения, который далее может быть
использован для синхронизации с другими потоками.
Сам фронт сообщения является обновлённым на $[\loc@\tau]$
базовым фронтом соответствующего потока.

Правило обработки приобретающего чтения является недетерминированным, поскольку выбирает из памяти запись
$(\loc, \tau) \mapsto (\mvalSubst, \stSigma)$,
метка времени $\tau$ которой не меньше значения базового фронта потока по этой локации
$\stSigmaRead(\loc)$.
Значение $\mvalSubst$ заменяет инструкцию чтения внутри редукционного контекста $\EvalContext$,
а базовый фронт потока $\stSigmaRead$ комбинируется с прочитанным фронтом сообщения $\stSigma$.
Здесь и далее правила для CAS-инструкций опущены;
они могут быть найдены в реализации интерпретатора \cite{opCppCode}.

\subsection{$\sco$-инструкции}
\label{sec:opc11:formal:sc}

\begin{figure}
\begin{mathpar}
  \inferrule[WriteSC]{
  \auxX = \angled{\stEta, \stPsiRead, \graybox{\stSC}} \quad \stpath = \Path(\EvalContext) \quad
  \stTau = \NextTau{\stEta}{\loc} \\
  \stSigmaRead = \stPsiRead(\stpath) \quad
  \stSigma = \stSigmaRead[\loc \mapsto \stTau] \\
  \auxX' = \angled{\stEta[(\loc, \stTau) \mapsto (\mvalSubst, \stSigma)],
                   \stPsiRead[\stpath \mapsto \stSigma], \graybox{\stSC[\loc \mapsto \stTau]}}
  }{
\angled{\EvalContext[\writeInstParam{\sco}{\loc}{\mvalSubst}]
, \auxX} \astep{} 
\angled{\EvalContext[\Ret{\mvalSubst}], \auxX'}
  } \\

  \inferrule[ReadSC]{
  \auxX = \angled{\stEta, \stPsiRead, \graybox{\stSC}} \quad \stpath = \Path(\EvalContext) \quad 
  \stEta(\loc, \stTau) = (\mvalSubst, \stSigma) \\
  \stSigmaRead = \stPsiRead(\stpath) \quad
  \graybox{\mathsf{max}(\stSigmaRead(\loc), \stSC(\loc)) \leq \stTau} \\
  \auxX' = \angled{\stEta, \stPsiRead[\stpath \mapsto \stSigmaRead \sqcup \stSigma],
                   \graybox{\stSC}}
  }{
\angled{\EvalContext[\readExpr{\acq}{\loc}], \auxX} \astep{} 
\angled{\EvalContext[\Ret{\mvalSubst}], \auxX'}
  }
\end{mathpar}
\caption{Правила обработки $\sco$-инструкций}
\label{fig:sc-sem}
\end{figure}

Для представления редукционных правил $\sco$-инструкций в состояние машины $\OpCpp$
нужно добавить дополнительную компоненту --- глобальный \emph{$\sco$-фронт} $\stSC$:
\[\begin{array}{rcl}
\auxX & ::= & \angled{..., \stSC}
\end{array}\]
Этот фронт по локации определяет максимальную метку времени среди сообщений в эту локацию,
которые были сделаны с помощью $\sco$-записи.

Правила обработки $\sco$-инструкций приведены на рис. \ref{fig:sc-sem}.
Они совпадают с правилами для высвобождающих записей и приобретающих чтений с рис. \ref{fig:rel/acq-sem}
с точностью до фрагментов, выделенных серым цветом.
Так, правило $\sco$-записи обновляет $\sco$-фронт машины, чтобы по целевой локации $\loc$ он
возвращал метку времени добавленной записи, а правило $\sco$-чтения проверяет, что метка времени
выбранного сообщения не меньше, чем значение $\sco$-фронта по целевой локации.

\subsection{Неатомарные обращения}
\label{sec:opc11:formal:na}

\begin{figure}
\begin{mathpar}
  \inferrule[WriteNA]{
  \auxX = \angled{\stEta, \stPsiRead, \graybox{\stNA}} \quad \stpath = \Path(\EvalContext) \\
  \stTau = \NextTau{\stEta}{\loc} \\
  \stSigmaRead = \stPsiRead(\stpath) \\
  \stSigma = \stSigmaRead[\loc \mapsto \stTau] \\
  \graybox{\stSigmaRead(\loc) \equiv \LastTau{\stEta}{\loc}} \\
  \auxX' = \angled{\stEta[(\loc, \stTau) \mapsto (\mvalSubst, \graybox{\stSigmaEmpty})],
                   \stPsiRead[\stpath \mapsto \stSigma], \graybox{\stNA[\loc \mapsto \stTau]}}
  }{
\angled{\EvalContext[\writeInstParam{\na}{\loc}{\mvalSubst}], \auxX} \astep{} 
\angled{\EvalContext[\Ret{\mvalSubst}], \auxX'}
  } \\

  \inferrule[ReadNA]{
  \auxX = \angled{\stEta, \stPsiRead, \graybox{\stNA}} \\
  \stpath = \Path(\EvalContext) \\
  \graybox{\stTau = \LastTau{\stEta}{\loc}} \\
  \stEta(\loc, \stTau) = (\mvalSubst, \stSigma) \\
  \graybox{\stTau \equiv \stSigmaRead(\loc)}  \\
  \auxX' = \angled{\stEta, \graybox{\stPsiRead}, \graybox{\stNA}}
  }{
\angled{\EvalContext[\readExpr{\na}{\loc}], \auxX} \astep{} 
\angled{\EvalContext[\Ret{\mvalSubst}], \auxX'}
  } \\
  
  \inferrule[ReadNA-stuck1]{
    \auxX = \angled{\stEta, \stPsiRead, \stNA} \\
    \stpath = \Path(\EvalContext) \\
    \stSigmaRead = \stPsiRead(\stpath) \\
    \stSigmaRead(\loc) \neq \LastTau{\stEta}{\loc}
  }{
    \angled{\EvalContext[\readExpr{\na}{\loc}], \auxX} \astep{}
    \angled{\Stuck, \auxX_{init}}
  } \\

  \inferrule[WriteNA-stuck1]{
    \auxX = \angled{\stEta, \stPsiRead, \stNA} \\
    \stpath = \Path(\EvalContext) \\
    \stSigmaRead = \stPsiRead(\stpath) \\
    \stSigmaRead(\loc) \neq \LastTau{\stEta}{\loc}
  }{
    \angled{\EvalContext[\writeInstParam{\na}{\loc}{\mvalSubst}], \auxX} \astep{}
    \angled{\Stuck, \auxX_{init}}
  } \\

  \inferrule[ReadNA-stuck2]{
    \auxX = \angled{\stEta, \stPsiRead, \stNA} \\
    \stpath = \Path(\EvalContext) \\
    \stSigmaRead = \stPsiRead(\stpath) \\
    \stSigmaRead(\loc) < \stNA(\loc)
  }{
    \angled{\EvalContext[\readExpr{\RM}{\loc}], \auxX} \astep{}
    \angled{\Stuck, \auxX_{init}}
  } \\

  \inferrule[WriteNA-stuck2]{
    \auxX = \angled{\stEta, \stPsiRead, \stNA} \\
    \stpath = \Path(\EvalContext) \\
    \stSigmaRead = \stPsiRead(\stpath) \\
    \stSigmaRead(\loc) < \stNA(\loc)
  }{
    \angled{\EvalContext[\writeInstParam{\WM}{\loc}{\mvalSubst}], \auxX} \astep{}
    \angled{\Stuck, \auxX_{init}}
  } \\
\end{mathpar}
\caption{Правила обработки неатомарных обращений и идентификации гонок по данным}
\label{fig:na-sem}
\end{figure}

Для обработки неатомарных чтений и записей мы добавляем в состояние машины
глобальный $\na$-фронт:
\[\begin{array}{rcl}
\auxX & ::= & \angled{..., \stNA}.
\end{array}\]
Аналогично $\sco$-фронту, $\na$-фронт по локации возвращает максимальную метку времени $\na$-записи
в неё, а сам фронт обновляется в правиле $\na$-записи.

$\na$-фронт предназначен для поиска гонок по данным, которые включают неатомарные обращения к памяти.
При выполнении $\na$-обращения (см. правила ${\rm ReadNA}$ и ${\rm WriteNA}$ на рис. \ref{fig:na-sem})
происходит проверка того, что выполняющий обращение поток осведомлён о последнем сообщении в целевую локацию.
Если данное требование не выполняется, то в программе присутствует гонка, и программа имеет неопределённое
поведение (см. правила ${\rm ReadNA\text{-}stuck1}$ и ${\rm WriteNA\text{-}stuck1}$).
Кроме того, если поток выполняет необязательно неатомарное обращение к локации $\loc$, о последней
$\na$-записи в которую он не осведомлён, т.е. его базовый фронт $\stSigmaRead$ по $\loc$ меньше,
чем $\stNA(\loc)$, то это также является состоянием гонки
(см. правила ${\rm ReadNA\text{-}stuck2}$ и ${\rm WriteNA\text{-}stuck2}$).

В отличие от рассмотренных ранее высвобождающих и $\sco$-записей, $\na$-запись не может быть использована
для синхронизации (даже как часть высвобождающей цепочки), поэтому её сообщение имеет пустой фронт.
Аналогично, $\na$-чтение игнорирует фронт прочитанного им сообщения.

\subsection{Расслабленные обращения}
\label{sec:opc11:formal:rlx}

\begin{figure}
\begin{mathpar}
  \inferrule[Read-Relaxed]{
  \auxX = \angled{\stEta, \stPsiRead, \graybox{\stPsiWrite}} \quad \stpath = \Path(\EvalContext) \quad 
  \stEta(\loc, \stTau) = (\mvalSubst, \stSigma) \\
  \stSigmaRead = \stPsiRead(\stpath) \quad
  \stSigmaRead(\loc) \leq \stTau \\
  \auxX' = \angled{\stEta, \stPsiRead[\stpath \mapsto \stSigmaRead \sqcup \graybox{[\loc@\stTau]}], \graybox{\stPsiWrite}}
  }{
\angled{\EvalContext[\readExpr{\rlx}{\loc}], \auxX} \astep{} 
\angled{\EvalContext[\Ret{\mvalSubst}], \auxX'}
  } \\

  \inferrule[Write-Relaxed]{
  \auxX = \angled{\stEta, \stPsiRead, \graybox{\stPsiWrite}} \quad \stpath = \Path(\EvalContext) \quad
  \stTau = \NextTau{\stEta}{\loc} \\
  \stSigmaRead = \stPsiRead(\stpath) \quad
  \stSigma = \stSigmaRead[\loc \mapsto \stTau] \\
  \graybox{\stTau_{\rel} = \stPsiWrite(\stpath)(\loc)} \\
  \graybox{(\_, \stSigmaSync) = \stEta(\loc, \stTau_{\rel})}\\
  \auxX' = \angled{\stEta[(\loc, \stTau) \mapsto (\mvalSubst, \graybox{\stSigmaSync}[\loc \mapsto \stTau])],
                   \stPsiRead[\stpath \mapsto \stSigma], \graybox{\stPsiWrite}}
  }{
\angled{\EvalContext[\writeInstParam{\rlx}{\loc}{\mvalSubst}], \auxX} \astep{} 
\angled{\EvalContext[\Ret{\mvalSubst}], \auxX'}
  } \\

  \inferrule[Write-Release']{
  \auxX = \angled{\stEta, \stPsiRead, \graybox{\stPsiWrite}} \quad \stpath = \Path(\EvalContext) \quad
  \stTau = \NextTau{\stEta}{\loc} \\
  \stSigmaRead = \stPsiRead(\stpath) \quad
  \stSigma = \stSigmaRead[\loc \mapsto \stTau] \\
  \graybox{\stSigmaWrite' = \stPsiWrite(\stpath)[\loc \mapsto \stTau]}\\
  \auxX' = \angled{\stEta[(\loc, \stTau) \mapsto (\mvalSubst, \stSigma)],
                   \stPsiRead[\stpath \mapsto \stSigma], \graybox{\stPsiWrite[\stpath \mapsto \stSigmaWrite']}}
  }{
\angled{\EvalContext[\writeInstParam{\rel}{\loc}{\mvalSubst}], \auxX} \astep{} 
\angled{\EvalContext[\Ret{\mvalSubst}], \auxX'}
  } \\
\end{mathpar}
\caption{Правила расслабленных обращений}
\label{fig:rlx-sem}
\end{figure}

Исполнение расслабленных инструкций чтения не обновляет
базовый фронт потока на фронт прочитанного сообщения
(см. правило ${\rm Read	ext{-}Relaxed}$ на рис. \ref{fig:rlx-sem}), это отличает
расслабленные инструкции от приобретающих.

Для поддержки расслабленных записей в состояние машины $\OpCpp$ нужно внести дополнительную компоненту, $\stPsiWrite$:
%
\[\begin{array}{rcl}
\auxX      & ::= & \angled{..., \stPsiWrite},
\end{array}\]
%
где $\stPsiWrite$ --- это функция, которая по идентификатору потока возвращает его \emph{фронт записи} $\stSigmaWrite$.
Фронт записи для каждой локации хранит метку времени последней высвобождающей записи, сделанной потоком в эту локацию.
Когда поток выполняет расслабленную запись в локацию $\loc$ с меткой времени $\tau$
(см. правило ${\rm Write	ext{-}Relaxed}$ на рис. \ref{fig:rlx-sem}),
то в добавляемое сообщение записывается фронт, равный комбинации $[\loc@\tau]$ и фронта сообщения, на который указывает
$\stSigmaWrite(\loc)$.
Для поддержки описанного механизма нужно также внести небольшое изменение в правило обработки высвобождающей записи
(см. правило ${\rm Write	ext{-}Release'}$ на рис. \ref{fig:rlx-sem}): после выполнения данного правила фронт записи потока
по целевой локации возвращает метку времени добавленного сообщения. Аналогичные изменения нужно внести в другие
схожие правила, в частности, в ${\rm WriteSC}$.

Кроме того, мета-функции, связанные с запуском и соединением потоков, также требуют доопределения:
\[
\begin{array}{r c l}
\spawn{\EvalContext}{\angled{\stEta,\stPsiRead,\stPsiWrite}} & = &
\angled{\stEta,
\stPsiRead[\stpath\:l \mapsto \stSigmaRead,~\stpath\:r \mapsto \stSigmaRead], \\
& & \quad ~~~ \graybox{\stPsiWrite[\stpath\:l \mapsto \bot,~\stpath\:r \mapsto \bot]}} \\

\joinP{\EvalContext}{\angled{\stEta, \stPsiRead, \stPsiWrite}} & = &
\angled{\stEta, \stPsiRead[\stpath \mapsto \stSigmaRead^{l} \sqcup \stSigmaRead^{r}],
  \graybox{\stPsiWrite[\stpath \mapsto \bot]}}
\end{array}
\]
Дочерние потоки при запуске, также как и родительский после соединения, не наследуют
фронты записи, т.к. согласно оригинальной модели C/C++11 \cite{Batty-al:POPL11}
высвобождающие цепочки не могут выходить за пределы потока напрямую%
\footnote{Высвобождающие цепочки могут ``покидать'' поток с помощью CAS-операций.}.

\subsection{Отложенные операции и спекулятивное исполнение}
\label{sec:opc11:formal:spec}

Поддержка отложенных операций и спекулятивного исполнения в машине $\OpCpp$ осуществляется
с помощью двух компонент состояния:
\[\begin{array}{r c l}
\auxX             & ::=        & \angled{..., \stPhi, \stGamma}. \\
\end{array}\]
Основной из них является функция $\stPhi$, которая по идентификатору потока $\stpath$ возвращает его иерархический
операционный буфер $\stAlpha$ отложенный операций $\stPostOp$:
\[\begin{array}{r l}
    \stPhi    ::= & \stpath \prarrow \stAlpha \\
    \stAlpha  ::= & \stPostOp^{*} \\
    \stPostOp ::= & read\angled{\vName,\locVar,\RM} \mid
                    write\angled{\vName,\locVar,\WM,\Expr} \mid
                    bind\angled{\vName,\Expr} \mid
                    if\angled{\vName,\Expr,\stAlpha,\stAlpha}\\
\end{array}\]
Каждая отложенная операция $\stPostOp$ обладает уникальным идентификатором --- символьным значением $\vName$.
Отложенные операции чтения $read\angled{\vName,\locVar,\RM}$ хранят выражение для вычисления целевой локации $\locvar$%
\footnote{Целевая локация отложенной операции может зависеть от других,
ещё не вычисленных, отложенных операций.},
а также модификатор чтения $\RM$.
В случае отложенной записи также хранится выражение $\Expr$, результат вычисления которого будет записан как целевое значение.
Для представления отложенного присваивания в локальную переменную используется конструкция $bind\angled{\vName, \Expr}$, которая
может быть использована для того, чтобы не форсировать вычисление отложенного чтения:
\[
\readInstParam{\rlx}{a}{x}; \assignInst{b}{a + 1}; \dots
\]
Для представления информации о спекулятивном исполнении веток условного оператора используется конструкция
$if\angled{\vName,\Expr,\stAlpha_1,\stAlpha_2}$,
где $\Expr$ является представлением условия, а $\stAlpha_1$ и $\stAlpha_2$ --- вложенных буферов отложенных операций
веток $\kw{then}$ и $\kw{else}$ соответственно.
Редукционный контекст $\EvalSpecContext$, внутри которого возможно спекулятивное исполнение инструкций, представлен
следующей грамматикой:
\[\begin{array}{rcl}
\EvalSpecContext & ::= & \hole \mid
                         \Bind{\vName}{\EvalSpecContext}{\AST} \mid
    \IfThenElse{\vName}{\EvalSpecContext}{\AST}\mid \\
&& \IfThenElse{\vName}{\AST}{\EvalSpecContext}
\end{array}\]
У конкретного подвыражения редукционного контекста символическое значение $\vName$, представляющее условие спекулятивно
исполняемой конструкции, должно совпадать с идентификатором соответствующей записи $if\angled{\vName,\Expr,\stAlpha_1,\stAlpha_2}$
в буфере отложенных операций.

Вторая компонента состояния машины $\OpCpp$, $\stGamma$, представляет ограничения, накладываемые на приобретающие чтения,
и является списком троек вида $\angled{\loc, \stTau, \vName}$.
Присутствие тройки $\angled{\loc, \stTau, \vName}$ в списке $\stGamma$ запрещает чтение из памяти сообщения $(\loc, \stTau)$,
пока отложенная операция с символическим значением $\vName$ не будет выполнена.

В ходе исполнения программы любая инструкция чтения, записи или присваивания может быть
отложена, даже если она находится под условным оператором, путём добавления
соответствующей записи в операционный буфер.
Правила по откладыванию исполнения инструкций приведены на рис. \ref{fig:postpone-sem}.

\begin{figure}
\begin{mathpar}
  \inferrule[Write-Postpone]{
  \auxX = \angled{\stEta, \stPsiRead, \stPhi, \stGamma} \\
  \vName \text{ --- новое символическое значение} \\
  \stAlpha = \stPhi(\stpath) \\
  \auxX' = \angled{\stEta, \stPsiRead,
\stPhi[\stpath \mapsto \AppendAlpha(\stAlpha, \EvalSpecContext, write\angled{\vName, \locVar, \WM, \Expr})],
  \stGamma} \\
  }{
\angled{\EvalContext[\EvalSpecContext[\writeInstParam{\WM}{\locVar}{\Expr}]], \auxX} \astep{} 
\angled{\EvalContext[\EvalSpecContext[\Ret{\vName}]], \auxX'}
  } \\

  \inferrule[Read-Postpone]{
    \auxX = \angled{\stEta, \stPsiRead, \stPhi, \stGamma} \\
    \vName \text{ --- новое символическое значение} \\
     \stAlpha = \stPhi(\stpath) \\
     \auxX' = \angled{\stEta, \stPsiRead,
     \stPhi[\stpath \mapsto \AppendAlpha(\stAlpha, \EvalSpecContext, read\angled{\vName, \locVar, \RM})],
     \stGamma} \\
  }{
\angled{\EvalContext[\EvalSpecContext[\readExpr{\RM}{\locVar}]], \auxX} \astep{} 
\angled{\EvalContext[\EvalSpecContext[\Ret{\vName}]], \auxX'}
  } \\

  \inferrule[Let-Postpone]{
  \auxX = \angled{\stEta, \stPsiRead, \stPhi, \stGamma} \\ \Expr~\text{зависит от отложенной операции}\\
  \vName \text{ --- новое символическое значение} \\
  \stAlpha = \stPhi(\stpath) \\
  \auxX' = \angled{\stEta, \stPsiRead,
\stPhi[\stpath \mapsto \AppendAlpha(\stAlpha, \EvalSpecContext, let\angled{\vName,\Expr})],
   \stGamma} \\
  }{
    \angled{\EvalContext[\EvalSpecContext[\Bind{\vName'}{\Expr}{\AST}]], \auxX} \astep{} 
    \angled{\EvalContext[\EvalSpecContext\subst{\vName'}{\vName}], \auxX'}
  } 
\end{mathpar}
\caption{Правила по откладыванию исполнения инструкций чтения, записи и присваивания}
\label{fig:postpone-sem}
\end{figure}

\begin{figure}
\begin{mathpar}
  \inferrule[Write-Resolve]{
  \auxX = \angled{\stEta, \dots, \stPhi, \stGamma} \\ ... \\
  write\angled{\vName, \loc, \WM, \mvalSubst}\;\text{в списке}\;\stPhi(\stpath) \\
  \text{и не конфликтует с предшествующими элементами списка} \\
  %% \forall \stpath', \not\exists (\vName', \vName) \in \stObservedWrites(\stpath') \\
  \stPhi' = \remove(\stPhi, \stpath, write\angled{\vName, \loc, \WM, \mvalSubst}) \\
  %% \stObservedWrites' = \remove(\stObservedWrites, \vName)\\
 \stGamma' = \updateDep(\vName, \WM, \stPsiWrite, \loc, \stTau, \stGamma, \stPhi(\stpath))\\ %, \stObservedWrites(\stpath)) \\
 \stEta' = \updateSync(\vName, \WM, \stSigma, \stGamma, \stEta) \\
 \auxX' = \angled{\stEta'[(\loc, \stTau) \mapsto (\mvalSubst, \stSigma)], \dots,
\stPhi'[\mvalSubst/\vName], \stGamma'} \\
}{
\angled{\AST, \auxX} \astep{}
\angled{\AST[\mvalSubst/\vName], \auxX'}
}

  \inferrule[Read-Resolve]{
  \auxX = \angled{\stEta, \dots, \stPhi, \stGamma} \\ ... \\
  read\angled{\vName, \loc, \RM}\;\text{внутри }\;\stPhi(\stpath) \\
  \text{и не конфликтует с предшествующими элементами} \\
   \\
  %% \not \exists \vName' \in \stObservedWrites(\stpath), \vName'\;\text{is a write to}\;\loc \\
  \stPhi' = \remove(\stPhi, \stpath, read\angled{\vName, \loc, \RM}) \\
  \stGamma' = \stGamma \setminus \{\angled{\_, \_, \vName}\} \\
  \auxX' = \angled{\stEta, \dots,
\stPhi'[\mvalSubst/\vName], \stGamma'} \\
  }{
\angled{\AST, \auxX} \astep{}
\angled{\AST[\mvalSubst/\vName], \auxX'}
  } \\

  \inferrule[Let-Resolve]{
  \auxX = \angled{\stEta, \stPsiRead, \stPhi, \stGamma} \\
  bind\angled{\vName, \mvalSubst}\;\text{внутри}\;\stPhi(\stpath) \\
   \\
  %% \not \exists \vName' \in \stObservedWrites(\stpath), \vName'\;\text{is a write to}\;\loc \\
  \stPhi' = \remove(\stPhi, \stpath, bind\angled{\vName, \mvalSubst}) \\
  \auxX' = \angled{\stEta, \stPsiRead,
\stPhi'[\mvalSubst/\vName], \stGamma} \\
  }{
\angled{\AST, \auxX} \astep{}
\angled{\AST[\mvalSubst/\vName], \auxX'}
  }

\end{mathpar}
\caption{Правила по выполнению отложенных инструкций чтения, записи и присваивания}
\label{fig:resolve-sem}
\end{figure}

После того, как операция была отложена, она может быть выполнена (см. правила на рис. \ref{fig:resolve-sem}).
В правилах для записи и чтения опущены стандартные части, связанные с обновлением базового фронта и фронта записи.
Рассмотрим подробнее правило ${\rm Write\text{-}Resolve}$.
С его помощью (недетерминированно) выбирается элемент буфера отложенных операций, соответствующий некоторой инструкции
записи, причём этот элемент обязан быть на первом уровне буфера. Без последнего требования семантика допускала бы 
``значения из воздуха''.
Кроме того, перед выбранным элементом списка не должно быть элементов, которые находятся в конфликте с ним,
таких как приобретающее чтение или запись в ту же локацию.
Из новой компоненты отложенных операций убирается соответствующий элемент
($\stPhi' = \remove(\stPhi, \stpath, write\angled{\vName, \loc, \WM, \mvalSubst})$),
обновляются фронты зависимых сообщений согласно $\stGamma$-компоненте
($\stEta' = \updateSync(\vName, \WM, \stSigma, \stGamma, \stEta)$),
а из самой $\stGamma$-компоненты удаляются зависимости
($\stGamma' = \updateDep(\vName, \WM, \stPsiWrite, \loc, \stTau, \stGamma, \stPhi(\stpath))$).

\begin{figure}
\begin{mathpar}
  \inferrule[Write-Promote]{
  \auxX = \angled{\stEta, \stPsiRead, \stPhi, \stGamma} \\
  if\angled{\vName'', \Expr, \stAlpha_1, \stAlpha_2 }\;\text{внутри}\;\stPhi(\stpath)\\\\
  write\angled{\vName, \loc, \WM, \mvalSubst}\;\text{в списке}\; \stAlpha_1 \\
  \text{и не конфликтует с предшествующими элементами списка} \\\\
  write\angled{\vName', \loc, \WM, \mvalSubst}\;\text{в списке}\; \stAlpha_2 \\
  \text{и не конфликтует с предшествующими элементами списка} \\\\
  \stPhi' = \promote(\vName, \vName', \stPhi) \\
  \stGamma' = \stGamma[\vName'/\vName]
  }{
\angled{\AST, \auxX} \astep{} \angled{\AST[\vName'/\vName], \auxX'}
  }
\end{mathpar}
\caption{Правило по переносу отложенной записи на предыдущий уровень вложенности буфера отложенных операций}
\label{fig:promote-sem}
\end{figure}

Отдельно стоит отметить правило, которое позволяет вынести отложенные инструкции записи,
повторяющиеся в ветках спекулятивно исполняемого условного оператора, на предыдущий уровень вложенности
буфера отложенных операций (см. рис. \ref{fig:promote-sem}).

\begin{figure}
\begin{mathpar}
  \inferrule[If-Speculation-Init]{
  \auxX = \angled{\stEta, \stPsiRead, \stPhi, \stGamma} \\
  \Expr\;\text{зависит от отложенной операции} \\
  \vName \text{ --- новое символическое значение} \\
  \stAlpha = \stPhi(\stpath) \\
  \auxX' = \angled{\stEta, \stPsiRead,
\stPhi[\stpath \mapsto \AppendAlpha(\stAlpha, \EvalSpecContext,
  if\angled{\vName,\Expr, \angled{}, \angled{}})], \stGamma} \\
  }{
  \angled{\EvalContext[\EvalSpecContext[\IfThenElse{\Expr}{\AST_{1}}{\AST_{2}}]], \auxX} \astep{} \\\\
  \angled{\EvalContext[\EvalSpecContext[\IfThenElse{\vName}{\AST_{1}}{\AST_{2}}]], \auxX'} \\
  } \\
  
  \inferrule[If-Resolve-True]{
  \auxX = \angled{\stEta, \stPsiRead, \stPhi, \stGamma} \\
  if\angled{\vName, z, \stAlpha_1, \stAlpha_2} \in \stPhi(\stpath) \\
  z \neq 0\\
  \stPhi' = \stPhi[if\angled{\vName, z, \stAlpha_1, \stAlpha_2} / \stAlpha_1] \\
  \auxX' = \angled{\stEta, \stPsiRead, \stPhi', \stGamma}
  }{
\angled{\EvalContext[\EvalSpecContext[\IfThenElse{\vName}{\AST_{1}}{\AST_{2}}]], \auxX} \astep{}
\angled{\EvalContext[\EvalSpecContext[\AST_{1}]], \auxX'}
  } \\

  \inferrule[If-Resolve-False]{
  \auxX = \angled{\stEta, \stPsiRead, \stPhi, \stGamma} \\
  if\angled{\vName, 0, \stAlpha_1, \stAlpha_2} \in \stPhi(\stpath) \\
  \stPhi' = \stPhi[if\angled{\vName, z, \stAlpha_1, \stAlpha_2} / \stAlpha_2] \\
  \auxX' = \angled{\stEta, \stPsiRead, \stPhi', \stGamma}
  }{
\angled{\EvalContext[\EvalSpecContext[\IfThenElse{\vName}{\AST_{1}}{\AST_{2}}]], \auxX} \astep{}
\angled{\EvalContext[\EvalSpecContext[\AST_{2}]], \auxX'}
  } \\
\end{mathpar}
\caption{Правила начала и завершения спекулятивного исполнения условного оператора}
\label{fig:spec-if-sem}
\end{figure}
Правила обработки условного оператора (начало и завершение спекулятивного исполнения) приведены на рис. \ref{fig:spec-if-sem}.

\app{TODO: consume!!!}
 
\section{Интерпретация и тестирование модели}
\label{sec:opc11:interpreter}

Интерпретатор для модели $\OpCpp$ \cite{opCppCode} был разработан на языке программирования Racket%
\footnote{Язык программирования Racket, \url{http://racket-lang.org/}}
с использованием средства разработки интерпретаторов PLT/Redex%
\footnote{Средство разработки интерпретаторов PLT/Redex, \url{https://redex.racket-lang.org/}}.
Средство PLT/Redex позволяет задать интерпретатор в стиле, использованном нами для описания модели:
как множества правил переписывания состояния некоторой абстрактной машины.
Также это средство базируется на идеях редукционной семантики \cite{Klein-al:POPL12,Felleisen-al:BOOK09,Felleisen-Hieb:TCS92}
и, как следствие, имеет встроенные механизмы разбиения термов на редукционный контекст и подтерм.

Реализация базовых правил целевого языка интерпретации, описанных в разделах
\ref{sec:opc11:formal:baselang} и \ref{sec:opc11:formal:histories}, и вспомогательных функций занимает
2070 строк кода, а различных аспектов модели C/C++11
(разделы \ref{sec:opc11:formal:ra}--\ref{sec:opc11:formal:spec})
--- 1310 строк.
Код тестов, описанных в разделах \ref{sec:opc11:litmus} и \ref{sec:opc11:rcu}, занимает 3130 строк.

\subsection{``Лакмусовые'' тесты}
\label{sec:opc11:litmus}
Проверка адекватности модели $\OpCpp$ и её сравнение с оригинальной моделью памяти C/C++11 \cite{Batty-al:POPL11}
были проведены на наборе т.н. \emph{``лакмусовых'' тестов} (litmus tests) --- небольших программ, которые
являются показательными примерами разных взаимодействий потоков и активно используются в литературе
\cite{Bornat-al:LACE,Batty-al:POPL11,Lahav-al:POPL16,Maranget-al:tutorial,Turon-al:OOPSLA14}
для обсуждения свойств моделей памяти.
При тестировании нам нужно было проверить, что множества ожидаемых результатов
исполнения программы и все возможные её исходы в рамках модели $\OpCpp$ совпадают.
Для этого средствами PLT/Redex по каждому тесту строился полный, т.е. включающий в себя все возможные исполнения теста,
граф состояний и переходов согласно множеству правил, задающих интерпретатор $\OpCpp$.
Далее из графа извлекалось множество финальных состояний, которое и сравнивалось с ожидаемыми результатами.

Таблица \ref{fig:litmusTbl} предоставляет информацию о ``лакмусовых'' тестах в контексте модели $\OpCpp$.
Столбцы ${\sf VF}$--${\sf JN}$ показывают, какие аспекты модели требуются для поддержки нужного поведения тестов.
В таблице использованы следующие сокращения:
  \textsf{VF} (viewfront) --- базовый фронт, $\stPsiRead$;
  \textsf{WF} (write-fronts) --- фронт записи, $\stPsiWrite$;
  \textsf{SCF} ($\sco$-front) --- $\sco$-фронт, $\stSC$;
  \textsf{NAF} ($\na$-front) --- $\na$-фронт, $\stNA$;
  \textsf{PO} (postponed operations) --- отложенные операции, $\stAlpha$;
  \textsf{ARR} (acquire read restrictions) --- ограничение приобретающих чтений, $\stGamma$;
  \textsf{CR} (consume-reads) --- маркировка, связанная с потребляющими чтениями;
  \textsf{JN} (joining threads) --- соединение потоков с не пустыми буферами.
Последний столбец ${\sf C11}$ --- полностью ли совпадают множества исходов $\OpCpp$ и оригинальной С/C++11 моделей.

В таблице тесты разделены на группы; в рамках каждой группы тесты имеют схожую структуру, но различаются модификаторами
доступа.
Код тестов в месте с информацией об ожидаемом поведении размещён в приложении \ref{sec:litmusTests}.

\subsubsection{Расхождения с оригинальной моделью C/C++11}
Для того, чтобы на тестах \textsf{LB-acq-rlx} и \textsf{LB-acq-rlx-join} поддержать те же результаты исполнения,
что и в оригинальной модели C/C++11, нужно позволить инструкции расслабленной записи, которая следует за
инструкцией приобретающего чтения, быть исполненной перед этим чтением.
Как и все слабые сценарии поведения, такой сценарий может быть следствием либо компиляторной оптимизации,
либо оптимизирующего исполнения программы на процессоре.
В общем случае перестановка приобретающего чтения с какой бы то ни было последующей инструкцией небезопасно,
т.к. приобретающее чтение может быть частью синхронизации, а, значит, в результате перестановки может быть
изменено отношение ``предшествует'', $\lHB$. Как следствие, промышленные компиляторы, такие как
GCC\footnote{Семейство компиляторов GCC, \url{https://gcc.gnu.org/}} и
Clang\footnote{Компилятор языка C в платформу LLVM \url{https://clang.llvm.org/}}, эту оптимизацию не делают.
В то же время, все корректные схемы компиляции инструкций приобретающего чтения в основные процессорные архитектуры (x86, Power, ARM)
также гарантируют, что сценарий поведения, который разрешается в оригинальной модели C/C++11, но запрещён в модели $\OpCpp$,
не наблюдается также на этих архитектурах.

Кроме того, наша модель не совпадает с оригинальной моделью C/C++11 на примерах со ``значениями из воздуха''
(\textsf{OOTA-lb}, \textsf{OOTA-if}), что является преимуществом нашей модели.

\app{TODO: описать пример из [Kang-al:POPL17]}

%% \setlength{\belowcaptionskip}{-20pt} 
\begin{table}
\centering
{\scriptsize
 \input{Dissertation/litmusTestsTable}
}
\caption{Результаты запуска интерпретатора $\OpCpp$ на ``лакмусовых'' тестах}
\label{fig:litmusTbl}
\end{table}
  %% \ifext{(Appendix~\ref{sec:litmusTests})}{} and corresponding
  %% semantic aspects of our framework:
  %% {viewfronts}~(\textsf{VF},~\S\ref{sec:hist}),
  %% {write-fronts}~(\textsf{WF},~\S\ref{sec:wrf}),
  %% SC-fronts~(\textsf{SCF},~\S\ref{sec:sc}), {non-atomic
  %%   fronts}~(\textsf{NAF},~\S\ref{sec:na}), {postponed
  %%   operations}~(\textsf{PO},~\S\ref{sec:postponed-sem}),
  %% {acquire read restrictions}),
  %%   %($\stGamma$)}~(\textsf{ARR},~\S\ref{sec:postponed-sem}),
  %% %% {value stealing}~(\textsf{VS},~\S\ref{sec:postponed-sem}),
  %% %% {if speculations}~(\textsf{IS}),
  %% {consume-reads}~(\textsf{CR}), {joining threads with non-empty
  %%   operation buffers}~(\textsf{JN},~\S\ref{sec:join}).  The column
  %% \textbf{C11} indicates whether the behavior is coherent with the C11
  %% standard.


\subsection{Проверка модели на примере структуры RCU}
\label{sec:opc11:rcu}

\begin{figure*}
\input{Dissertation/rcuProg}
\caption[Реализация алгоритма QSBR RCU]
{Реализация алгоритма QSBR RCU}
 %% При тестировании была рассмотрена также версия без фрагментов, выделенных серым фоном
 %% (Раздел~\ref{sec:testing})}
\label{fig:rcuProg} \end{figure*}

Кроме ``лакмусовых'' тестов мы также рассмотрели нашу модель в контексте тестирования и отладки
многопоточной структуры данных, реализующей стратегию Read-Copy-Update (RCU) \cite{McKenney-Slingwine:PDCS98,McKenney:PhD}.
Стратегия RCU является одной из стандартных подходов к реализации неблокирующего доступа к
связной структуре данных, такой как список или дерево, между одним писателем и множеством читателей.
Конкретнее, мы выбрали RCU для односвязного списка, реализованный с помощью
\emph{освобождения памяти в момент затишья} (quiescent state-based reclamation, QSBR) \cite{Desnoyers-al:TPDS12}.
Центральной идеей стратегии RCU является то, как писатель структуры обновляет её узлы.
Так, если писатель собирается изменить некоторый узел в списке, то вместо того, чтобы
изменить узел непосредственно, он создаёт копию старого узла, обновляет её, а потом изменяет ссылки в структуре
таким образом, чтобы они показывали на новый узел вместо старого.
Далее писатель ждёт, пока все читатели не перестанут использовать старый узел, после чего
память, отведенная под узел, может быть переиспользована или освобождена.
Ключевой частью реализации алгоритма, которая необходима для его корректности, является
правильная синхронизация между писателем и читателями:
писатель обновляет ссылки на узлы с помощью высвобождающей записи,
тогда как читатели обходят список с помощью приобретающих чтений.
Это гарантирует, что читатели не увидят частичные изменения в структуре данных.

Реализация QSBR RCU списка и его использующей клиентской программы приведена на рис. \ref{fig:rcuProg}.
В первой строчке программы происходит инициализация счётчиков потоков:
$cw$ -- счётчик (первого) потока-писателя,
$cr1$ и $cr2$ -- счётчики второго и третьего потоков программы, которые являются читателями структуры.
В той же строчке происходит инициализация указателя на голову списка, $lhead$.
Далее в программе происходит старт трёх потоков.

Поток-писатель добавляет в список три значения: 1, 10 и 100.
Заметим, что поскольку в нашей модели мы
не описываем выделение памяти, то для записи значений используются константные локации $a$, $b$ и $c$.
После того, как поток записывает три значения, он заменяет второй элемент списка, в котором хранится значение 10,
на новый узел $d$, в который записывается значение $1000$.
При обновлении списка с помощью функции $\funcSt{updateSecondNode}$
поток-читатель вызывает функцию синхронизации $\funcSt{sync}$, внутри которой происходит обновление
счётчика $cw$, после чего происходит ожидание обновления других потоков (вызовы функции $\funcSt{syncWithReader}$).

Рассмотрим подробнее функцию $\funcSt{append}$, которая используется для добавления второго и третьего значений в список.
В этой функции сначала создаётся новый узел ($\writeInstParam{\rlx}{loc}{(value, \nullPtr)}$),
далее указатель на последний элемент списка записывается в переменную $rt$ ($\readInstParam{\na}{rt}{ltail}$),
происходит разыменование указателя ($\readInstParam{\rlx}{rtc}{rt}$),
после чего по указателю $rt$ записывается старое значение последнего элемента списка ($\kw{fst} \; rtc$)
и указатель на новый узел ($loc$).
В конце обновляется указатель на последний элемент списка ($\writeInstParam{\na}{ltail}{loc}$).
Отметим, что в функции $\funcSt{append}$ все обращения к памяти, кроме $\writeInstParam{\rel}{rt}{(\kw{fst} \; rtc, loc)}$,
либо неатомарные, либо расслабленные. Это связано с тем, что локация $ltail$ и переменные $rt$ и $rtc$ локальны
для первого потока. При этом высвобождающая запись $\writeInstParam{\rel}{rt}{(\kw{fst} \; rtc, loc)}$
делает так, что потоки-читатели, обходящие список с помощью приобретающих чтений в функции $\funcSt{traverse}$,
становятся осведомлёнными о записи в новый узел ($\writeInstParam{\rlx}{loc}{(value, \nullPtr)}$),
когда получают указатель на ячейку $loc$.

Потоки-читатели по два раза обходят список, создаваемый писателем, и вычисляют сумму (переменные $r11, r12, r21$ и $r22$).
Перед началом обхода списка они вызывают функцию $\funcSt{rcuOnline}$.
Она выполняет две задачи. Во-первых, в ней происходит приобретающее чтение из $cw$, которое синхронизирует
поток с некоторой версией списка. Во-вторых, с помощью увеличения счётчика $cr$ поток сигнализирует писателю о том,
что он начал обход списка.
Симметрично, читатель обновляет свой счётчик и уведомляет поток-писатель после обхода списка с помощью функции $\funcSt{rcuOffline}$.

\subsubsection{Дополнительная инфраструктура для тестирования RCU}
Имея запускаемую операционную семантику, мы можем провести динамический анализ приведённой выше программы,
а именно построить все пространство состояний исполнения программы в модели $\OpCpp$ и проверить его на
определённые свойства, такие как отсутствие гонок по данным.
Тем не менее, такой подход не реалистичен, поскольку само пространство для этой программы огромно.
Это связано с тем, что модель имеет три аспекта недетерминированности:
\begin{itemize}
  \item планирование потоков;
  \item отложенные операции;
  \item недетерминированное чтение даже из фиксированной локации.
\end{itemize}
Все эти аспекты приводят к комбинаторному взрыву пространства состояний.

Для того, чтобы сделать динамический анализ возможным на практике, хотя бы в ограниченном варианте,
мы реализовали версию модели, которая строит некоторый случайный путь в пространстве состояний исполнения программы.
Данная версия строит этот путь по следующему принципу.
На первом шаге к текущему состоянию машины недетерминированно применяются все возможные правила.
Далее проверяется, есть ли в получившемся множестве $\kw{stuck}$-состояние, которое сигнализирует о том, что
программа имеет неопределённое поведение. Если такого состояние нет, то из множества случайным образом выбирается
новое состояние, и процедура повторяется.
Имея такое представление модели, мы можем проводить свойство-ориентированное тестирование программы \cite{Hritcu-al:ICFP13}.

Дополнительно мы добавили в язык оператор $\kw{delete}$, который ``удаляет'' переданную ему локацию.
Данный оператор может быть использован для проверки, что некоторая локация, начиная с некоторого момента исполнения программы,
более не используется, что является одним из свойств стратегии RCU.
Для задания семантики этому оператору мы добавили в состояние машины $\OpCpp$ дополнительный список ``удалённых'' локаций.
Обращение к локации из этого списка приводит к $\kw{stuck}$-состоянию.

\subsubsection{Тестирование и отладка программы с RCU}
С помощью рандомизированной модели мы проверили приведенную программу с RCU.
На более чем 20 запусках программы не было получено $\kw{stuck}$-состояния.

Далее, мы специально внесли ошибку синхронизации, а именно удалили вызовы функции $\funcSt{syncWithReader}$,
помеченные серым фоном на рис. \ref{fig:rcuProg}.
Кроме того, мы учитывали ещё два дополнительных критерия корректности программы.
Во-первых, все значения $r11, r12, r21$ и $r22$ должны быть из множества $\{0, 1, 11, 111, 1101\}$,
что гарантирует корректность прочтения списка.
Во-вторых, должны выполняться неравенства $r11 \le r12$ и $r21 \le r22$, поскольку после каждого добавления и
изменения в списке сумма его элементов увеличивается.

\begin{table}
\centering
  \input{Dissertation/rcuTbl}
\caption{Результаты тестирования модифицированной программы с RCU}
\label{fig:tblRun}
\end{table}

Мы запустили тест 20 раз на компьютере с Core i7 2.5Ghz процессоре, 8Gb оперативной памяти и системой Linux.
Каждый из запусков завершился менее чем за 27 секунд, и критерий корректности про переменные $r*$ не был нарушен
(см. табл. \ref{fig:tblRun}). Тем не менее, из-за того, что в модифицированной версии программы освобождение
локации с помощью оператора $\kw{delete}$ не защищено вызовами $\funcSt{syncWithReader}$, потоки-читатели
обращаются к ``удалённым'' локациям, о чём свидетельствует графа $\kw{stuck}$.

Аналогично, рандомизированное тестирование указывает на наличие ошибки, если в функции $\funcSt{traverse}$
приобретающее чтение внутри цикла $\kw{repeat}$ поменять на расслабленное. Это приводит к тому, что между
читателем и писателем не происходит синхронизации, и позволяет читателю провести чтение из локаций $a-d$,
о которых он не осведомлён. Последнее приводит к $\kw{stuck}$-состоянию по правилу ${\rm Read\text{-}Uninit}$.

\section{Свойства модели. Выводы}
\label{sec:opc11:results}
\app{TODO}
