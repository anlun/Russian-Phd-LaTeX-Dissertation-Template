\chapter{Операционная модель памяти C/C++11} \label{sec:opc11}
В главе описана операционная модель памяти C/C++11 \cite{Podkopaev-al:CoRR16}.
Операционное представление различных аспекты оригинальной модели памяти C/C++11 \cite{Batty-al:POPL11}
базируется на комбинации двух основных идей: \emph{фронтов} и \emph{операционных буферов}.
Фронты используются для представления осведомленности потоков о текущем состоянии общей памяти,
тогда как операционные буферы позволяют откладывать исполнение инструкций и
производить спекулятивные вычисления.

Описание структурировано следующим образом.
В разделе \ref{sec:opc11:base} рассматриваются базовые концепции модели на нескольких примерах.
\app{TODO}

\section{Основные концепции модели}
\label{sec:opc11:base}



Как было отмечено в главе \ref{sec:overview}, модель памяти представлена операционно, если
сценарии поведения в ней являются трассами исполнения некоторой абстрактной машины.
Обычно, состояние абстрактной машины включает в себя компоненту, которая олицетворяет собой
память машины --- функцию, которая по локации в памяти возвращает значение, которое было записано
в локацию последним.
Такое представление является слишком ограничивающим при определении абстрактной машины слабой
модели памяти --- 

При моделировании эффектов слабых моделей памяти такое представление самой памяти является слишком
ограничивающим --- в общем случае в каждый момент существует

означает, что существует 

Операцион представлении слабой модели памяти 

Начнём со следующего варианта программы ${\rm MP}$, в котором все обращения
к памяти являются расслабленными:
\begin{equation*}
\tag{MP-rlx}
\begin{tabular}{c}
  $\writeInstParam{\rlx}{x}{0}; \writeInstParam{\rlx}{y}{0};$ \\
\begin{tabular}{L || L}
  \writeInstParam{\rlx}{x}{1}; & \readInstParam{\rlx}{a}{y}; \\
  \writeInstParam{\rlx}{y}{1} & \readInstParam{\rlx}{b}{x} \\
\end{tabular}
\end{tabular}
\end{equation*}
В рамках C/C++11 MM данная программа имеет четыре возможных результата исполнения:
$[a = 0, b = 0]$, $[a = 0, b = 1]$, $[a = 1, b = 0]$ и $[a = 1, b = 1]$.



 программы

${\rm MP\text{-}rlxrel\text{-}acq}$ (см. рис. \ref{fig:MPrelAcq}),
которую мы уже обсуждали в контексте модели C/C++11.
В аксиоматической C/C++11 MM программа имеет три сценария поведения (см. рис. \ref{fig:MPrelAcqSem}).
Рассмотрим один из этих сценариев (см. рис. \ref{fig:MPrelAcqSemSW}),
в котором присутствует ребро отношения $\lSW$, т.е. есть синхронизация.
\begin{figure}
\[
\begin{tikzpicture}[yscale=1,xscale=1.8]
  \node (01)  at (-2,3) {$p: \wlab{\na}{x}{0}$ };
  \node (02)  at (0,3) {$q: \wlab{\na}{y}{0}$ };
  \node (1)  at (-2,1.5) {$r: \wlab{\rlx}{x}{1}$ };
  \node (2)  at (-2,0) {$s: \wlab{\rel}{y}{1}$ };
  \node (11) at (0,1.5)  {$t: \rlab{\acq}{y}{1}$ };
  \node (12) at (0,0)  {$u: \rlab{\rlx}{x}{1}$ };

  \draw[po] (1)  edge  (2);
  \draw[po] (11) edge (12);
  \draw[po] (01) edge (11);
  \draw[po] (02) edge (11);
  %% \draw[hb] (01) edge node[right] {\small $\lHB$} (1);
  \draw[po] (01) edge (1);
  \draw[po] (02) edge  (1);
  %% \draw[deps,bend left=20] (11)  edge node[right] {\small $\lDEPS$} (12);
  \draw[sw,bend right=20] (2) edge node[below] {\small $\lSW$} (11);
  \draw[rf] (2) edge node[above] {\small $\lRF$} (11);
  \draw[rf] (1) edge node[below] {} (12);
  \draw[mo,bend right=20] (01)  edge node[left] {\small $\lMO$} (1);
  \draw[mo,bend right=90] (02)  edge node[above] {} (2); %{\small $\lCO$} (2);
\end{tikzpicture}
\]
\caption{Сценарий поведения программы ${\rm MP\text{-}rel\text{-}acq}$, в котором есть синхронизация потоков}
\label{fig:MPrelAcqSemSW}
\end{figure}

%% На рис. \ref{fig:MPrelAcq} представлена сама программа и одни из сценариев поведения
%% этой программы в рамках C/C++11 MM.
%% \begin{figure}
%%   \begin{minipage}{.4\textwidth}
%% \begin{equation*}
%% %% \tag{MP-rel-acq}
%% \begin{tabular}{c}
%%   $\writeInstParam{\na}{x}{0}; \writeInstParam{\na}{y}{0};$ \\
%% \begin{tabular}{L || L}
%%   \writeInstParam{\rlx}{x}{1}; & \readInstParam{\acq}{a}{y}; \\
%%   \writeInstParam{\rel}{y}{1} & \readInstParam{\rlx}{b}{x} \\
%% \end{tabular}
%% \end{tabular}
%% \end{equation*}
%%   \end{minipage}
%%   \begin{minipage}{.4\textwidth}
%% \[
%% \begin{tikzpicture}[yscale=1,xscale=1.8]
%%   \node (01)  at (-2,3) {$p: \wlab{\na}{x}{0}$ };
%%   \node (02)  at (0,3) {$q: \wlab{\na}{y}{0}$ };
%%   \node (1)  at (-2,1.5) {$r: \wlab{\rlx}{x}{1}$ };
%%   \node (2)  at (-2,0) {$s: \wlab{\rel}{y}{1}$ };
%%   \node (11) at (0,1.5)  {$t: \rlab{\acq}{y}{1}$ };
%%   \node (12) at (0,0)  {$u: \rlab{\rlx}{x}{1}$ };

%%   \draw[po] (1)  edge  (2);
%%   \draw[po] (11) edge (12);
%%   \draw[po] (01) edge (11);
%%   \draw[po] (02) edge (11);
%%   %% \draw[hb] (01) edge node[right] {\small $\lHB$} (1);
%%   \draw[po] (01) edge (1);
%%   \draw[po] (02) edge  (1);
%%   %% \draw[deps,bend left=20] (11)  edge node[right] {\small $\lDEPS$} (12);
%%   \draw[sw,bend right=20] (2) edge node[below] {\small $\lSW$} (11);
%%   \draw[rf] (2) edge node[above] {\small $\lRF$} (11);
%%   \draw[rf] (1) edge node[below] {} (12);
%%   \draw[mo,bend right=20] (01)  edge node[left] {\small $\lMO$} (1);
%%   \draw[mo,bend right=90] (02)  edge node[above] {} (2); %{\small $\lCO$} (2);
%% \end{tikzpicture}
%% \]
%%   \end{minipage}
%% \caption{Программа ${\rm MP\text{-}rel\text{-}acq}$ и её сценарий исполнения в модели C/C++11}
%% \label{fig:MPrelAcq}
%% \end{figure}


\subsection{Синхронизация потоков. Фронты}
\subsection{Спекулятивное исполнение. Операционные буферы}

\section{Полная модель}
В разделе описываются более сложные аспекты модели памяти C/C++, такие как
$\sco$-обращения, неатомарные инструкции и гонки по данным,
$\con$-чтения, соединение потоков (thread's joining),
а также расслабленные обращения.

\section{Формальное определение модели}
В разделе приводится математическое определение операционной модели C/C++11.

\section{Интерпретация и тестирование модели}

\subsection{Тестирование алгоритма RCU}

\input{Dissertation/litmusTestsTable}

\begin{figure*}[t]
\input{Dissertation/rcuProg}
\caption[Реализация алгоритма QSBR RCU]
{Реализация алгоритма QSBR RCU.
 При тестировании была рассмотрена также версия без фрагментов, выделенных серым фоном
 (Раздел~\ref{sec:testing}).}
\label{fig:rcuProg}
\end{figure*}

\section{Свойства модели. Выводы}
