\chapter{Операционная модель памяти C/C++11} \label{sec:opc11}
В главе описана операционная модель памяти C/C++11 \cite{Podkopaev-al:CoRR16}, или \OpCpp.
Ключевыми понятиями в модели являются \emph{фронты} и \emph{операционные буферы}.
%% Операционное представление различных аспектов оригинальной модели памяти C/C++11 \cite{Batty-al:POPL11}
%% базируется на комбинации двух основных идей: \emph{фронтов} и \emph{операционных буферов}.
Фронты используются для представления осведомленности потоков о текущем состоянии общей памяти,
тогда как операционные буферы позволяют откладывать исполнение инструкций и
производить спекулятивные вычисления.

Описание структурировано следующим образом.
В разделе \ref{sec:opc11:base} рассматриваются базовые концепции модели на нескольких примерах.
\app{TODO}

\section{Основные концепции модели}
\label{sec:opc11:base}
Модель памяти $\OpCpp$ задана операционным способом, а, значит, существует
некоторая абстрактная машина, связанная с моделью, которая исполняет программы
по шагам. Далее мы будем использовать термин \emph{машина} $\OpCpp$ для её обозначения.

\subsection{Память и базовый фронт}
Рассмотрим машину $\OpCpp$ на примере исполнения следующей программы в ней.
\begin{equation*}
\tag{MP-rlx-2}
\begin{tabular}{c}
  $\writeInstParam{\rlx}{x}{0}; \writeInstParam{\rlx}{y}{0};$ \\
\begin{tabular}{L || L}
  \writeInstParam{\rlx}{x}{1}; & \readInstParam{\rlx}{a}{y}; \\
  \writeInstParam{\rlx}{y}{1}  & \readInstParam{\rlx}{b}{x}; \\
                               & \readInstParam{\rlx}{c}{x}\\
\end{tabular}
\end{tabular}
\end{equation*}
Эта программа является очередной вариацией программы ${\rm MP}$, в которой во второй поток было добавлено дополнительное
чтение из локации $x$.

Состояние машины $\OpCpp$ включается в себя множество сообщений, которое называется 
\emph{памятью}. Сообщение --- это тройка из локации, значения и \emph{метки времени} (timestamp).
Метки времени являются натуральными числами и используются для упорядочивания сообщений, которые связаны с одной и той же локацией.
Такой порядок аналогичен отношению $\lMO$ в аксиоматической модели C/C++11 \cite{Batty-al:POPL11}.

После исполнения первых двух инструкций программы
($\writeInstParam{\rlx}{x}{0}; \writeInstParam{\rlx}{y}{0}$) память машины будет содержать два сообщения:
\[
M = \{\angled{x:0@\tstamp{0}}, \angled{y:0@\tstamp{0}}\},
\]
где $\tstamp{0}$ -- метка времени.
После того, как левый поток закончит своё исполнение, в памяти будет четыре сообщения:
\[
M = \{\angled{x:0@\tstamp{0}}, \angled{y:0@\tstamp{0}},
      \angled{y:1@\tstamp{1}},\angled{x:1@\tstamp{1}}\}.
\]

Заметим, что в оригинальной модели C/C++11 \cite{Batty-al:POPL11} у рассматриваемой программы есть сценарий поведения
с результатом $[a = 1, b = 0, c = 0]$.
Для того, чтобы разрешить результат $[a = 1, b = 0, c = 0]$, потоки машины $\OpCpp$ имеют право при чтении выбирать из памяти
сообщение не с самым большой меткой времени (как этого требовала бы абстрактная машина, представляющая модель SC), т.е.
не самую последнюю запись в локацию.
Так, после завершения исполнения левого потока, правый поток может сначала прочитать сообщение $\angled{y:1@\tstamp{1}}$,
присвоив в регистр $a$ значение $1$, а после --- два раза из старого сообщения $\angled{x:0@\tstamp{0}}$,
получив $b = c = 0$.

В то же время модель C/C++11 запрещает сценарий поведения $[a = 1, b = 1, c = 0]$, поскольку гарантирует, что если поток
``увидел'' более новую запись в локацию, в данном случае сообщение $\angled{x:1@\tstamp{1}}$,
то более он не может прочитать более старое, с точки зрения отношения $\lMO$, сообщение.
Для того, чтобы поддержать данное ограничение, в модели $\OpCpp$ у каждого потока есть т.н. \emph{базовый фронт}.
Базовый фронт --- это частичная функция, которая по локации возвращает максимальную метку времени связанного с локацией сообщения, о
котором ``осведомлен'' поток.
Расмотрим действие базового фронта на примере сценария поведения программы ${\rm MP\text{-}rlx\text{-}2}$,
который приводит к результату $[a = 1, b = 1, c = \_]$.


Так, после того, как поток читает или записывает сообщение в локацию $\loc$ с меткой времени $\tau$, он обновляет
свой базовый фронт по этой локации до $\tau$ и более не может читать $\loc$-сообщения с меньшей меткой.

Изначально в системе один поток $T0$ с пустым базовым фронтом.
После исполнения первых двух инструкций программы
($\writeInstParam{\rlx}{x}{0}; \writeInstParam{\rlx}{y}{0}$) базовый фронт потока, $T0.\Rcur$, будет указывать на
соответствующие сообщения из памяти:
\[
T0.\Rcur = [x@\tstamp{0}, y@\tstamp{0}]
\]
Далее машина стартует два потока, $T1$ и $T2$, базовые фронты которых будут равняться $T0.\Rcur$.
\[
T1.\Rcur = [x@\tstamp{0}, y@\tstamp{0}] \quad T2.\Rcur = [x@\tstamp{0}, y@\tstamp{0}]
\]
Далее, исполняются инструкции (левого) потока $T1$ и память содержит два новых сообщения,
а базовый фронт потока $T1$ увеличивается до $\tstamp{1}$ по обоим локациям,
т.к. поток, сделавший запись, естественным образом осведомлен о ней.
\[
\begin{array}{l}
T1.\Rcur = [\graybox{x@\tstamp{1}}, \graybox{y@\tstamp{1}}] \quad T2.\Rcur = [x@\tstamp{0}, y@\tstamp{0}]
\end{array}
\]
После этого (правый) поток $T2$ может прочитать новое сообщение в локацию $y$, присвоив $1$ в регистр $a$
и обновив свой фронт по локации $y$ до $\tstamp{1}$.
\[
\begin{array}{l}
T1.\Rcur = [x@\tstamp{1}, y@\tstamp{1}] \quad T2.\Rcur = [x@\tstamp{0}, \graybox{y@\tstamp{1}}]
\end{array}
\]
Т.к. базовый фронт потока $T2$ по локации $x$ равен $\tstamp{0}$, т.е. поток ещё не осведомлён о новой записи в $x$,
поток может прочитать либо сообщение $\angled{x:0@\tstamp{0}}$, либо сообщение $\angled{x:1@\tstamp{1}}$.
Для того, чтобы $b$ равнялось $1$, поток $T2$ должен прочитать из более нового сообщения, что обновит его
базовый фронт по локации $x$.
\[
\begin{array}{l}
T1.\Rcur = [x@\tstamp{1}, y@\tstamp{1}] \quad T2.\Rcur = [\graybox{x@\tstamp{1}}, y@\tstamp{1}]
\end{array}
\]
После этого потоку $T2$ остаётся только выполнить последнее чтение ($\readInstParam{\rlx}{c}{x}$),
и поскольку его базовый фронт по локации $x$ равен $\tstamp{1}$, то он может прочитать только
из нового сообщения в локацию $x$ ($\angled{x:1@\tstamp{1}}$).
Таким образом модель $\OpCpp$ запрещает результат $[a = 1, b = 1, c = 0]$.

%% Для рассматриваемой программы модель $\OpCpp$ должна разрешать сценарий поведения с результатом $[a = 1, b = 0, c = 0]$,
%% т.к. такой результат разрешает оригинальная модель C/C++11 \cite{Batty-al:POPL11}.
%% Рассмотрим сценарий поведения машины $\OpCpp$, который приводит к нему.

\subsection{Синхронизация потоков}
Рассмотрим программу ${\rm MP\text{-}rel\text{-}acq}$, которую мы уже обсуждали в главе \ref{sec:overview}.
\begin{equation*}
  \tag{MP-rel-acq}
\begin{tabular}{c}
  $\writeInstParam{\rlx}{x}{0}; \writeInstParam{\rlx}{y}{0};$ \\
\begin{tabular}{L || L}
  \writeInstParam{\rlx}{x}{1}; & \readInstParam{\acq}{a}{y}; \\
  \writeInstParam{\rel}{y}{1} & \readInstParam{\rlx}{b}{x}\\
\end{tabular}
\end{tabular}
\end{equation*}
Результат $[a = 1, b = 0]$ запрещён в C/C++11 MM для этой программы, т.к. если $a = 1$, то между потоками произошла
синхронизация (в соответствующем графе есть ребро отношения $\lSW$),
и перед выполнением $\readInstParam{\rlx}{b}{x}$ правый поток должен быть осведомлен
о записи $\writeInstParam{\rlx}{x}{1}$.

Для того, чтобы представить такую синхронизацию, у каждого сообщения машины $\OpCpp$
есть четвертая дополнительная компонента --- \emph{фронт сообщения}.
Фронт сообщения $m$ хранит информацию о сообщениях, о которых станет осведомлен
поток, который выполнит приобретающее ($\acq$) чтение сообщения $m$.
Если поток $T$ выполняет высвобождающую ($\rel$) запись, то фронтом сообщения,
которое будет добавлено в память как результат исполнения записи, будет базовый
фронт потока $T$ на момент выполнения записи.
Расслабленные ($\rlx$) записи также помещают некоторый фронт в соответствующие сообщения,
но по более сложным правилам, которые будут описаны в разделе \ref{sec:opc11:fullmodel}.

Рассмотрим сценарий поведения ${\rm MP\text{-}rel\text{-}acq}$, в котором $a = 1$, т.е. происходит синхронизация.
После того, как выполнены две инициализирующие записи и запущены два потока, память и базовые фронты потоков
выглядят следующим образом:
\[
\begin{array}{l}
M = \{\angled{x:0@\tstamp{0}, [x@\tstamp{0}]}, \angled{y:0@\tstamp{0},[y@\tstamp{0}]} \} \\
T1.\Rcur = [x@\tstamp{0}, y@\tstamp{0}] \quad T2.\Rcur = [x@\tstamp{0}, y@\tstamp{0}]
\end{array}
\]
После исполнения двух записей (левым) потоком $T1$, в память попадает два новых сообщения, одно из которых
было сделано высвобождающей записью:
\[
\begin{array}{l}
M = \{
\angled{x:0@\tstamp{0}, [x@\tstamp{0}]}, \angled{y:0@\tstamp{0},[y@\tstamp{0}]}, \\
\qquad \angled{x:1@\tstamp{1}, [x@\tstamp{1}]}, \angled{y:1@\tstamp{1},\graybox{[x@\tstamp{1},y@\tstamp{1}]}}
 \} \\
T1.\Rcur = [x@\tstamp{1}, y@\tstamp{1}] \quad T2.\Rcur = [x@\tstamp{0}, y@\tstamp{0}]
\end{array}
\]
После того, как (правый) поток выполняет приобретающее чтение из сообщения 
$\angled{y:1@\tstamp{1},[x@\tstamp{1},y@\tstamp{1}]}$, его базовый фронт увеличивается по обоим компонентам.
\[
\begin{array}{l}
T2.\Rcur = [\graybox{x@\tstamp{1}}, y@\tstamp{1}]
\end{array}
\]
После этого (правый) поток $T2$ не может прочитать старое сообщение $\angled{x:0@\tstamp{0}, [x@\tstamp{0}]}$.
Таким образом модель $\OpCpp$ запрещает результат $[a = 1, b = 0]$ для программы ${\rm MP\text{-}rel\text{-}acq}$.

\subsection{Операционные буферы}
Тем не менее, не все слабые сценарии поведения программ, наблюдаемые в модели C/C++11, могут быть описаны
приведенными выше механизмами.
Одной из таких программ является программа ${\rm LB\text{-}rlx}$ (load buffering, буферизация записи):
\begin{equation*}
\tag{LB-rlx}\label{ex:LBrlx}
\begin{tabular}{c}
  $\writeInstParam{\rlx}{x}{0}; \writeInstParam{\rlx}{y}{0};$ \\
\begin{tabular}{L || L}
  \readInstParam{\rlx}{a}{x}; & \readInstParam{\rlx}{b}{y}; \\
  \writeInstParam{\rlx}{y}{1} & \writeInstParam{\rlx}{x}{1} \\
\end{tabular}
\end{tabular}
\end{equation*}
Модель памяти C/C++11 разрешает сценарий поведения этой программы с результатом $[a = 1, b = 1]$.
Такой результат требует, чтобы в момент исполнения инструкции $\readInstParam{\rlx}{a}{x}$
запись, соответствующая инструкции $\writeInstParam{\rlx}{x}{1}$, и аналогично для пары инструкций
$\readInstParam{\rlx}{b}{y}$ и $\writeInstParam{\rlx}{y}{1}$.
Таким образом, хотя бы в одном из потоков инструкция записи должна быть исполнена раньше чтения.

Для решения этой проблемы модель $\OpCpp$ добавляет в состояние каждого потока по
\emph{операционному буферу}.
Операционный буфер --- это список записей об отложенных инструкциях, которые 
хранят всю необходимую информацию для дальнейшего их исполнения. 
Так, в частности, когда поток откладывает инструкцию чтения, он заменяет её в программе
на новое, уникальное символьное значение%
\footnote{Семантика $\OpCpp$ задана в стиле редукционных контекстов \cite{Felleisen-Hieb:TCS92,Felleisen-al:BOOK09},
т.е. программа в ней представляется как выражение, которое постепенно редуцируется.
Как следствие, инструкция чтения в этой семантике --- это некоторое подвыражение, которое, будучи вычисленным,
заменяется на прочитанное значение.
Подробное описание семантики в виде редукционных контекстов приведено в разделе \ref{sec:opc11:formal}.
}, а в буфер добавляет пару, состоящую из символьного значения
и целевой локации.
В то время как для отложенной инструкции записи в буфер сохраняется целевая локация и значение,
которое нужно записать.
Далее поток машины $\OpCpp$ может недетерминировано выбрать отложенную инструкцию из буфера и,
если в буфере перед выбранной инструкцией нет инструкции, которая может непосредственно повлиять на результат
выбранной, исполнить её.
Так, данный механизм позволяет в программе ${\rm LB\text{-}rlx}$ отложить исполнение инструкции чтения в левом потоке,
что даёт возможность получить результат $[a = 1, b = 1]$.

\subsection{Спекулятивное исполнение}


\section{Полная модель}
\label{sec:opc11:fullmodel}
В разделе описываются более сложные аспекты модели памяти C/C++, такие как
$\sco$-обращения, неатомарные инструкции и гонки по данным,
$\con$-чтения, соединение потоков (thread's joining),
а также расслабленные обращения.

\section{Формальное определение модели}
\label{sec:opc11:formal}
В разделе приводится математическое определение операционной модели C/C++11.

\section{Интерпретация и тестирование модели}

\subsection{Тестирование алгоритма RCU}

\input{Dissertation/litmusTestsTable}

\begin{figure*}[t]
\input{Dissertation/rcuProg}
\caption[Реализация алгоритма QSBR RCU]
{Реализация алгоритма QSBR RCU.
 При тестировании была рассмотрена также версия без фрагментов, выделенных серым фоном
 (Раздел~\ref{sec:testing}).}
\label{fig:rcuProg}
\end{figure*}

\section{Свойства модели. Выводы}
