\chapter{Операционная модель памяти C/C++11} \label{sec:opc11}
В главе описана операционная модель памяти C/C++11 \cite{Podkopaev-al:CoRR16}, или \OpCpp.
Ключевыми понятиями в модели являются \emph{фронты} и \emph{операционные буферы}.
%% Операционное представление различных аспектов оригинальной модели памяти C/C++11 \cite{Batty-al:POPL11}
%% базируется на комбинации двух основных идей: \emph{фронтов} и \emph{операционных буферов}.
Фронты используются для представления осведомленности потоков о текущем состоянии общей памяти,
тогда как операционные буферы позволяют откладывать исполнение инструкций и
производить спекулятивные вычисления.

Описание структурировано следующим образом.
В разделе \ref{sec:opc11:base} рассматриваются базовые концепции модели на нескольких примерах.
\app{TODO}

\section{Основные концепции модели}
\label{sec:opc11:base}
Модель памяти $\OpCpp$ задана операционным способом, а, значит, существует
некоторая абстрактная машина, связанная с моделью, которая исполняет программы
по шагам. Далее мы будем использовать термин \emph{машина} $\OpCpp$ для её обозначения.

\subsubsection{Память и базовый фронт}
Рассмотрим машину $\OpCpp$ на примере исполнения следующей программы в ней.
\begin{equation*}
\tag{MP-rlx-2}
\begin{tabular}{c}
  $\writeInstParam{\rlx}{x}{0}; \writeInstParam{\rlx}{y}{0};$ \\
\begin{tabular}{L || L}
  \writeInstParam{\rlx}{x}{1}; & \readInstParam{\rlx}{a}{y}; \\
  \writeInstParam{\rlx}{y}{1}  & \readInstParam{\rlx}{b}{x}; \\
                               & \readInstParam{\rlx}{c}{x}\\
\end{tabular}
\end{tabular}
\end{equation*}
Эта программа является очередной вариацией программы ${\rm MP}$, в которой во второй поток было добавлено дополнительное
чтение из локации $x$.

Состояние машины $\OpCpp$ включается в себя множество сообщений, которое называется 
\emph{памятью}. Сообщение --- это тройка из локации, значения и \emph{метки времени} (timestamp).
Метки времени являются натуральными числами и используются для упорядочивания сообщений, которые связаны с одной и той же локацией.
Такой порядок аналогичен отношению $\lMO$ в аксиоматической модели C/C++11 \cite{Batty-al:POPL11}.

Заметим, что в оригинальной модели C/C++11 \cite{Batty-al:POPL11} у этой программы есть сценарий поведения
с результатом $[a = 1, b = 0, c = 0]$, однако сценарий с результатом $[a = 1, b = 1, c = 0]$ запрещен.
По сути, C/C++11 MM запрещает сценарий поведения $[a = 1, b = 1, c = 0]$, поскольку гарантирует, что если поток
``увидел'' более новую запись в локацию, %в данном случае сообщение в локацию $x$ с меткой времени $\tstamp{1}$,
то более он не может прочитать старое значение из той же локации.

Для того, чтобы разрешить результат $[a = 1, b = 0, c = 0]$, потоки машины $\OpCpp$ имеют право при чтении выбирать из памяти
сообщение не с самым большой меткой времени (как этого требовала бы абстрактная машина, представляющая модель SC), т.е.
не самую последнюю запись в локацию.
В то же время для запрещения результата $[a = 1, b = 1, c = 0]$ у каждого потока в модели $\OpCpp$ есть свой т.н. \emph{базовый фронт},
который является частичной функцией, которая по локации возвращает максимальную метку времени связанного с локацией сообщения, о
котором ``осведомлен'' поток.
Так, после того, как поток читает или записывает сообщение в локацию $\loc$ с меткой времени $\tau$, он обновляет
свой базовый фронт по этой локации до $\tau$ и более не может читать $\loc$-сообщения с меньшей меткой.

%% Для рассматриваемой программы модель $\OpCpp$ должна разрешать сценарий поведения с результатом $[a = 1, b = 0, c = 0]$,
%% т.к. такой результат разрешает оригинальная модель C/C++11 \cite{Batty-al:POPL11}.
%% Рассмотрим сценарий поведения машины $\OpCpp$, который приводит к нему.

Рассмотрим сценарий поведения программы  ${\rm MP\text{-}rlx\text{-}2}$ в машине $\OpCpp$,
который приводит к $[a = 1, b = 0, c = 0]$.
Изначально в системе один поток $T0$ с пустым базовым фронтом.
После исполнения первых двух инструкций программы
($\writeInstParam{\rlx}{x}{0}; \writeInstParam{\rlx}{y}{0}$) память машины будет содержать два сообщения 
\[
M = \{\angled{x:0@\tstamp{0}}, \angled{y:0@\tstamp{0}}\},
\]
где $\tstamp{0}$ -- метка времени, а базовый фронт потока, $T0.\Rcur$, будет указывать на эти сообщения:
\[
T0.\Rcur = [x@\tstamp{0}, y@\tstamp{0}]
\]
Далее машина стартует два потока, $T1$ и $T2$, базовые фронты которых будут равняться $T0.\Rcur$.
\[
T1.\Rcur = [x@\tstamp{0}, y@\tstamp{0}] \quad T2.\Rcur = [x@\tstamp{0}, y@\tstamp{0}]
\]
Далее, исполняются инструкции (левого) потока $T1$ и память содержит два новых сообщения,
а базовый фронт потока $T1$ увеличивается до $\tstamp{1}$ по обоим локациям.
\[
\begin{array}{l}
M = \{\angled{x:0@\tstamp{0}}, \angled{y:0@\tstamp{0}},\graybox{\angled{y:1@\tstamp{1}},\angled{x:1@\tstamp{1}}}\} \\
T1.\Rcur = [\graybox{x@\tstamp{1}}, \graybox{y@\tstamp{1}}] \quad T2.\Rcur = [x@\tstamp{0}, y@\tstamp{0}]
\end{array}
\]
После этого (правый) поток $T2$ может прочитать новое сообщение в локацию $y$, присвоив $1$ в регистр $a$
и обновив свой фронт по локации $y$ до $\tstamp{1}$.
\[
\begin{array}{l}
M = \{\angled{x:0@\tstamp{0}}, \angled{y:0@\tstamp{0}},\angled{y:1@\tstamp{1}},\angled{x:1@\tstamp{1}}\} \\
T1.\Rcur = [x@\tstamp{1}, y@\tstamp{1}] \quad T2.\Rcur = [x@\tstamp{0}, \graybox{y@\tstamp{1}}]
\end{array}
\]
Т.к. базовый фронт потока $T2$ по локации $x$ равен $\tstamp{0}$, поток может прочитать старое сообщение в локацию $x$
два раза, присвоив $0$ в регистры $b$ и $c$.
Если же в этой точке сценария поведения поток $T2$ прочитает сообщение $\angled{x:1@\tstamp{1}}$ и, соответственно,
присвоит регистру $b$ значение $1$, то его фронт станет равным $[\graybox{x@\tstamp{1}}, y@\tstamp{0}]$, после чего
поток не сможет прочитать старое сообщение $\angled{x:0@\tstamp{0}}$. Так разрешается результат $[a = 1, b = 0, c = 0]$
и запрещается $[a = 1, b = 1, c = 0]$.

\subsubsection{Синхронизация потоков}
Рассмотрим программу ${\rm MP\text{-}rel\text{-}acq}$, которую мы уже обсуждали в главе \ref{sec:overview}.
\begin{equation*}
  \tag{MP-rel-acq}
\begin{tabular}{c}
  $\writeInstParam{\rlx}{x}{0}; \writeInstParam{\rlx}{y}{0};$ \\
\begin{tabular}{L || L}
  \writeInstParam{\rlx}{x}{1}; & \readInstParam{\acq}{a}{y}; \\
  \writeInstParam{\rel}{y}{1} & \readInstParam{\rlx}{b}{x}\\
\end{tabular}
\end{tabular}
\end{equation*}
Результат $[a = 1, b = 0]$ запрещён в C/C++11 MM для этой программы, т.к. если $a = 1$, то между потоками произошла
синхронизация, и перед выполнением $\readInstParam{\rlx}{b}{x}$ правый поток должен быть осведомлен
о записи $\writeInstParam{\rlx}{x}{1}$.

Для того, чтобы представить такую синхронизацию, сообщения машины $\OpCpp$ хранят дополнительную четвертую компоненту
--- \emph{фронт сообщения}.
%% Также у каждого потока появляется по два дополнительных фронта --- приобретающему и
%% высвобождающему. Приобретающий фронт, также как и базовый, является функцией 



Рассмотрим сценарии поведения модели $\OpCpp$ на со следующего варианта программы ${\rm MP}$, в котором все обращения
к памяти являются расслабленными:

Так, для приведенной выше программы начальная память будет состоять из двух сообщений:


Как было отмечено в главе \ref{sec:overview}, модель памяти представлена операционно, если
сценарии поведения в ней являются трассами исполнения некоторой абстрактной машины.
Обычно, состояние абстрактной машины включает в себя компоненту, которая олицетворяет собой
память машины --- функцию, которая по локации в памяти возвращает значение, которое было записано
в локацию последним.
Такое представление является слишком ограничивающим при определении абстрактной машины слабой
модели памяти --- 

При моделировании эффектов слабых моделей памяти такое представление самой памяти является слишком
ограничивающим --- в общем случае в каждый момент существует

означает, что существует 

Операцион представлении слабой модели памяти 

Начнём со следующего варианта программы ${\rm MP}$, в котором все обращения
к памяти являются расслабленными:
\begin{equation*}
\tag{MP-rlx}
\begin{tabular}{c}
  $\writeInstParam{\rlx}{x}{0}; \writeInstParam{\rlx}{y}{0};$ \\
\begin{tabular}{L || L}
  \writeInstParam{\rlx}{x}{1}; & \readInstParam{\rlx}{a}{y}; \\
  \writeInstParam{\rlx}{y}{1} & \readInstParam{\rlx}{b}{x} \\
\end{tabular}
\end{tabular}
\end{equation*}
В рамках C/C++11 MM данная программа имеет четыре возможных результата исполнения:
$[a = 0, b = 0]$, $[a = 0, b = 1]$, $[a = 1, b = 0]$ и $[a = 1, b = 1]$.



 программы

${\rm MP\text{-}rlxrel\text{-}acq}$ (см. рис. \ref{fig:MPrelAcq}),
которую мы уже обсуждали в контексте модели C/C++11.
В аксиоматической C/C++11 MM программа имеет три сценария поведения (см. рис. \ref{fig:MPrelAcqSem}).
Рассмотрим один из этих сценариев (см. рис. \ref{fig:MPrelAcqSemSW}),
в котором присутствует ребро отношения $\lSW$, т.е. есть синхронизация.
\begin{figure}
\[
\begin{tikzpicture}[yscale=1,xscale=1.8]
  \node (01)  at (-2,3) {$p: \wlab{\na}{x}{0}$ };
  \node (02)  at (0,3) {$q: \wlab{\na}{y}{0}$ };
  \node (1)  at (-2,1.5) {$r: \wlab{\rlx}{x}{1}$ };
  \node (2)  at (-2,0) {$s: \wlab{\rel}{y}{1}$ };
  \node (11) at (0,1.5)  {$t: \rlab{\acq}{y}{1}$ };
  \node (12) at (0,0)  {$u: \rlab{\rlx}{x}{1}$ };

  \draw[po] (1)  edge  (2);
  \draw[po] (11) edge (12);
  \draw[po] (01) edge (11);
  \draw[po] (02) edge (11);
  %% \draw[hb] (01) edge node[right] {\small $\lHB$} (1);
  \draw[po] (01) edge (1);
  \draw[po] (02) edge  (1);
  %% \draw[deps,bend left=20] (11)  edge node[right] {\small $\lDEPS$} (12);
  \draw[sw,bend right=20] (2) edge node[below] {\small $\lSW$} (11);
  \draw[rf] (2) edge node[above] {\small $\lRF$} (11);
  \draw[rf] (1) edge node[below] {} (12);
  \draw[mo,bend right=20] (01)  edge node[left] {\small $\lMO$} (1);
  \draw[mo,bend right=90] (02)  edge node[above] {} (2); %{\small $\lCO$} (2);
\end{tikzpicture}
\]
\caption{Сценарий поведения программы ${\rm MP\text{-}rel\text{-}acq}$, в котором есть синхронизация потоков}
\label{fig:MPrelAcqSemSW}
\end{figure}

%% На рис. \ref{fig:MPrelAcq} представлена сама программа и одни из сценариев поведения
%% этой программы в рамках C/C++11 MM.
%% \begin{figure}
%%   \begin{minipage}{.4\textwidth}
%% \begin{equation*}
%% %% \tag{MP-rel-acq}
%% \begin{tabular}{c}
%%   $\writeInstParam{\na}{x}{0}; \writeInstParam{\na}{y}{0};$ \\
%% \begin{tabular}{L || L}
%%   \writeInstParam{\rlx}{x}{1}; & \readInstParam{\acq}{a}{y}; \\
%%   \writeInstParam{\rel}{y}{1} & \readInstParam{\rlx}{b}{x} \\
%% \end{tabular}
%% \end{tabular}
%% \end{equation*}
%%   \end{minipage}
%%   \begin{minipage}{.4\textwidth}
%% \[
%% \begin{tikzpicture}[yscale=1,xscale=1.8]
%%   \node (01)  at (-2,3) {$p: \wlab{\na}{x}{0}$ };
%%   \node (02)  at (0,3) {$q: \wlab{\na}{y}{0}$ };
%%   \node (1)  at (-2,1.5) {$r: \wlab{\rlx}{x}{1}$ };
%%   \node (2)  at (-2,0) {$s: \wlab{\rel}{y}{1}$ };
%%   \node (11) at (0,1.5)  {$t: \rlab{\acq}{y}{1}$ };
%%   \node (12) at (0,0)  {$u: \rlab{\rlx}{x}{1}$ };

%%   \draw[po] (1)  edge  (2);
%%   \draw[po] (11) edge (12);
%%   \draw[po] (01) edge (11);
%%   \draw[po] (02) edge (11);
%%   %% \draw[hb] (01) edge node[right] {\small $\lHB$} (1);
%%   \draw[po] (01) edge (1);
%%   \draw[po] (02) edge  (1);
%%   %% \draw[deps,bend left=20] (11)  edge node[right] {\small $\lDEPS$} (12);
%%   \draw[sw,bend right=20] (2) edge node[below] {\small $\lSW$} (11);
%%   \draw[rf] (2) edge node[above] {\small $\lRF$} (11);
%%   \draw[rf] (1) edge node[below] {} (12);
%%   \draw[mo,bend right=20] (01)  edge node[left] {\small $\lMO$} (1);
%%   \draw[mo,bend right=90] (02)  edge node[above] {} (2); %{\small $\lCO$} (2);
%% \end{tikzpicture}
%% \]
%%   \end{minipage}
%% \caption{Программа ${\rm MP\text{-}rel\text{-}acq}$ и её сценарий исполнения в модели C/C++11}
%% \label{fig:MPrelAcq}
%% \end{figure}


\subsection{Спекулятивное исполнение. Операционные буферы}

\section{Полная модель}
В разделе описываются более сложные аспекты модели памяти C/C++, такие как
$\sco$-обращения, неатомарные инструкции и гонки по данным,
$\con$-чтения, соединение потоков (thread's joining),
а также расслабленные обращения.

\section{Формальное определение модели}
В разделе приводится математическое определение операционной модели C/C++11.

\section{Интерпретация и тестирование модели}

\subsection{Тестирование алгоритма RCU}

\input{Dissertation/litmusTestsTable}

\begin{figure*}[t]
\input{Dissertation/rcuProg}
\caption[Реализация алгоритма QSBR RCU]
{Реализация алгоритма QSBR RCU.
 При тестировании была рассмотрена также версия без фрагментов, выделенных серым фоном
 (Раздел~\ref{sec:testing}).}
\label{fig:rcuProg}
\end{figure*}

\section{Свойства модели. Выводы}
