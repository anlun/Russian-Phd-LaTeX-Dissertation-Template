\chapter{Корректность компиляции из обещающей модели в аксиоматическую модель ARMv8.3} \label{sec:armv83}
В этой главе описываются следующие результаты, полученные диссертантом
в~\cite{Podkopaev-al:NTV17,Podkopaev-al:ISPRAS17}:
доказательство корректности эффективной схемы компиляции из
подмножества обещающей модели памяти \cite{Kang-al:POPL17} в аксиоматическую
модель памяти ARMv8.3 POP \cite{Pulte-al:POPL18}.
Рассмотренное подмножество обещающей модели состоит из расслабленных обращений к памяти,
высвобождающего и приобретающего барьеров памяти без сертификации.
%% \section{Мотивировка доказательства корректности компиляции}
%% \label{sec:armv83:motive}
Как было описано в разделе \ref{sec:armpop:motive}, доказательство корректности
компиляции из обещающей модели памяти является важной задачей. 
В главе \ref{sec:armpop} было рассмотрено доказательство для модели ARMv8 POP \cite{Flur-al:POPL16},
однако задача для архитектуры ARM оказалась не полностью закрыта --- 
в апреле 2017 года была предложена новая модель памяти ARMv8.3 \cite{ARMv82,Pulte-al:POPL18} и потребовалось новое доказательство. 
Также как и в случае с моделью ARMv8 POP, схема доказательства корректности компиляции,
использованная в \cite{Kang-al:POPL17} для моделей x86 и Power, не подходит для модели ARMv8.3.
Дело в том, что для использования этой схемы нужно, чтобы модель была представлена в виде оптимизаций над более строгой
моделью, и все результаты сценариев поведения в этой более строгой модели должны быть получены также и в обещающей модели, при этом 
механизм обещаний не должен быть использован.
Данное утверждение для модели ARMv8.3 не является истинным.
Чтобы убедиться в этом, рассмотрим такую программу:
\[\inarrII{
\readInst{a}{x}; ~\valuecom{1} \\
\itne{a=1}{\readInst{b}{y} ~\valuecom{0}} 
}
{
\writeInst{y}{1}; \\
\fenceInst{\SY}; \\
\writeInst{x}{1}
}\]
Между инструкциями чтения в левом потоке имеется  зависимость по управлению, а в правом потоке находится барьер памяти, запрещающий неупорядоченное  исполнение записей.
В рамках модели памяти ARMv8.3 возможен сценарий программы с результатом $a = 1$ и $b = 0$. Следует отметить, 
что в обоих потоках инструкции не могут быть переставлены. 
Модель ARMv8.3 является аксиоматической, и это
существенно отличает ее от модели ARMv8 POP \cite{Flur-al:POPL16}.
Следовательно, невозможно простым способом задать симуляцию модели ARMv8.3 обещающей моделью.
Преодолевая это ограничение, автор диссертационного исследования  разработал специальный способ обхода графа модели ARMv8.3
(раздел \ref{sec:traversal}),
представленный в виде операционной семантики.
Этот обход используется при доказательстве симуляции 
(раздел \ref{sec:simulation}).
%% Данный метод может быть использован для доказательства корректности компиляции из
%% обещающей в аксиоматические модели памяти, и является более общим, чем использованные ранее методы
%% (см. раздел \ref{sec:related}), базирующиеся на особых свойствах целевых аксиоматических моделей.
%% Глава структурирована следующим образом.
%% В начале приводится высокоуровневое описание обещающей и ARMv8 POP моделей и мотивировка для доказательства
%% корректности компиляции между ними (раздел \ref{sec:armpop:motive}).
%% В разделе \ref{sec:armpop:examples} обе модели иллюстрируются на наборе примеров.
%% Далее приводится описание идеи доказательства корректности компиляции между ними (раздел \ref{sec:armpop:highlevel}).
%% В разделах \ref{sec:armpop:armmodel}  и \ref{sec:armpop:promisemodel} приводятся формальные описания моделей.
\section{Модель ARMv8.3}
\label{sec:armv83examples}
\label{sec:armv83formally}
Модель ARMv8.3 \cite{Pulte-al:POPL18} является аксиоматической и 
представляет семантику программы как набор графов, где каждый граф 
соответствует определённому запуску программы.
Как и в модели C/C++11 \cite{Batty-al:POPL11}
она использует отношения $\lPO$, ``читает из'' $\lRF$, порядка памяти
$\lMO$.
Кроме того, используется производное отношение ``читает ранее'' $\lFR$
(reads before): \[ \lFR \defeq \lRF^{-1}; \lCO, \]
связывающее событие чтения $a$ с событием записи $b$,
которое $\lCO$-следует за записью, из которой читает $a$.
%
%% Здесь и далее композиция отношений с помощью `$;$' задается так:
Композиция отношений `$;$' задаётся следующим образом:
\[A; B \defeq \{\tup{a, b} \mid \exists c. \; \tup{a, c} \in A \land \tup{c, b} \in B \}.\]
\begin{figure}
\[
\begin{tikzpicture}[yscale=1.5,xscale=3]
  %% \node (01) at (-1,3) {$\wlab{}{x}{0}$ };
  %% \node (02) at (0,3) {$\wlab{}{y}{0}$ };
  \node (1)  at (-1,2) {$\wlab{}{x}{1}$ };
  \node (b1) at (-1,1) {$\flab{\SY}$ };
  \node (2)  at (-1,0) {$\wlab{}{y}{1}$ };
  \node (11) at (0,2)  {$\rlab{}{y}{1}$ };
  \node (b2) at (0,1)  {$\flab{\LD}$ };
  \node (12) at (0,0)  {$\rlab{}{x}{0}$ };
  \draw[po] (1)  edge  (b1);
  \draw[po] (b1)  edge  (2);
  \draw[po] (11) edge (b2);
  \draw[po] (b2) edge (12);
  %% \draw[po] (01) edge (11);
  %% \draw[po] (02) edge (11);
  %% \draw[po] (01) edge (1);
  %% \draw[po] (02) edge  (1);
  %% \draw[deps,bend left=20] (11)  edge node[right] {\small $\lDEPS$} (12);
  %% \draw[rf,bend left=70] (01)  edge node[above] {\small $\lRF$} (12);
  \draw[rf] (2)  edge node[below] {$\lRFE$} (11);
  %% \draw[mo,bend right=20] (01)  edge node[below] {\small $\lCO$} (1);
  %% \draw[mo,bend right=90] (02)  edge node[below] {\small $\lCO$} (2);
  \draw[fr] (12) edge node[above] {$\lFRE$} (1);
  \draw[deps,bend right=30] (1)  edge node[left] {$\lBOB^{+}$} (2);
  \draw[deps,bend left=30] (11) edge node[right] {$\lBOB^{+}$} (12);
\end{tikzpicture}
\]
\caption{Сценарий поведения программы \textrm{MP-SY-LD}, запрещённый в модели ARMv8.3}
\label{fig:arm83:mpsyld}
\end{figure}
Добавление в программу \textrm{MP} барьеров памяти, как и в случае с моделью ARMv8 POP,
делает невозможным результат $[a = 1, b = 0]$ (см. рис. \ref{fig:arm83:mpsyld}):
\begin{equation*}
\tag{MP-sy-ld}
\begin{tabular}{L || L}
  \writeInst{x}{1}; & \readInst{a}{y}; ~\valuecom{1} \\
  \syFence;         & \ldFence; \\
  \writeInst{y}{1}; & \readInst{b}{x}; ~\valuefail{0} \\
\end{tabular}
\end{equation*}
В данном графе опущены инициализирующие записи и добавлено отношение барьеров $\lBOB$ (barrier-ordered-before), которое задаётся так:
\[
\lBOB \defeq \inarr{\lPO; [\lDMBSY] \cup [\lDMBSY]; \lPO  \cup [\lR]; \lPO; [\lDMBLD] \cup [\lDMBLD]; \lPO},
\]
где $[A] \defeq \{(a, a) \suchthat a \in A\}$.
Также заменены ребра отношений $\lRF$ и $\lFR$  на $\lRFE$ и $\lFRE$, где $\lmakeE{}$ (external) означает,
что отношение связывает только события, принадлежащие разным потокам.
В представленном графе имеется цикл: $\lBOB$, $\lRFE$, $\lFRE$, и это противоречит одной из аксиом, используемой
в модели ARMv8.3 для задания \ARM-согласованного сценария поведения.
Следовательно, данный граф не является \ARM-согласованным,
и результат $[a = 1, b = 0]$ запрещен для программы \textrm{MP-SY-LD}.
%% \section{Формальное определение модели ARMv8.3}
%% В этом разделе модель ARMv8.3 описывается  формально, в соответствии с \cite{Pulte-al:POPL18}.
%% Синтаксис
%% \label{sec:appendixProg}
%% Мы не будем явным образом использовать язык \ARM-ассемблера
%% и будем считать, что он совпадает с исходным языком (см. рис. \ref{fig:syn-prog}) с точностью до
%% модификаторов барьера памяти:
%% \[\FtypeARM ::= \SY \mid \LD. \]
%% Также мы будем считать, что результатом компиляции любой программы $\Prog$ на исходном языке
%% является той же программой, в которой модификаторы $\rel$ заменены на $\SY$, а $\acq$ --- на $\LD$.
%% \label{subsec:arm-formally}
%% \url{https://github.com/herd/herdtools7/blob/master/herd/libdir/aarch64.cat}  \qquad (07-June-17)
%% \[\begin{array}{lccll}
%% \lL & = & STLR & \text{release(SC)} & \lW^\sco\\
%% \lA & = & LDAR & \text{acquire(SC)} & \lR^\sco\\
%% \lQ & = & ?    & \text{acquire(C11)} & \lR^\acq 
%% %% X & =      & atomic(RMW)
%% \end{array}\]
%% В нашей работе мы рассматриваем подмножество модели памяти ARMv8.3.
Ниже представлено формальное определение сценария поведения в
модели ARMv8.3 \cite{Pulte-al:POPL18}:
%% DK --- зачем столько курсива – здесь и в других местах?
\begin{definition}
%% \begin{restatable}{mydefinition}{graphexdef}
\label{def:execution}
\emph{Сценарий поведения} $G$ является графом, включающий следующие компоненты.
\begin{enumerate}
\item Конечное множество \emph{событий} $\lE \suq \mathbb{N}$, которое включает 
      начальные события $\lE_0 = \{ a^x_0 \suchthat x \in \Loc \}$.
      Для обозначения событий используются символы $a,b,\ldots$
\item Функция $\lTID$, возвращающая по событию из $\lE$  номер потока, создавшего это событие;
любое начальное событие мы считаем относящимся к потоку с номером 0, $\lTID(a^x_0) = 0$.
\item Функция $\lLAB$, присваивающая каждому событию из $\lE$ \emph{метку}; метки могут обозначать следующие операции: 
      
\begin{itemize}%squishlist
\item \emph{чтение}, $\evlab{\lR}{o}{x}{v}$, где $x\in\Loc$ --- это
  \emph{локация}, из которой событие читает \emph{значение} $v\in\Val$;
\item \emph{запись}, $\evlab{\lW}{o}{x}{v}$, где $x\in\Loc$ --- это
  \emph{локация}, в которую событие записывает \emph{значение} $v\in\Val$;
\item \emph{барьер памяти}, $\flab{o}$, где $o\in \{\ld,\full\}$ --- это \emph{тип барьера}, причём $\full$-барьеры более строгие, чем
  $\ld$, $\ld \sqsu \full$.
\end{itemize}%\squishend
Каждое начальное событие является инициализирующей записью в определённую локацию:
\[\forall a^x_0 \in \lE_0. \; \lLAB(a^x_0) = \evlab{\lW}{\pln}{x}{0}.\]
Функция $\lLAB$ определяет следующие частичные функции, которые по событию возвращают:
%% $\lTYP$, $\lMOD$, $\lLOC$, $\lVALR$ и $\lVALW$, такие что:
%% \squishlist
\begin{itemize}
  \item $\lTYP$ --- тип события ($\lR,\lW$ или $\lF$);
  \item $\lMOD$ --- тип барьера;
  \item $\lLOC$ --- целевую локацию;
  \item $\lVALR$ --- прочитанное значение;
  \item $\lVALW$ --- записанное значение.
\end{itemize}
%% \squishend
Далее мы будем использовать символы $\lR, \lW$ и $\lF$ в том числе и для обозначения соответствующих множеств
событий, например, $\lR$ --- для обозначения $\{e\in \lE \suchthat \lTYP(e)=\lR\}$.
%% Далее $\lX$, элемент $\{\lR,\lW,\lF\}$, будет обозначать
%% множество $\{e\in \lE \suchthat \lTYP(e)=\lX\}$.
%% Мы пишем локацию в нижнем регистре для обозначения множества событий, оперирующих
%% над этой локацией и пишем обозначения множеств рядом, имея ввиду объединение множеств.
%% Например, $\lW_x = \{a \in \lW \mid \lLOC(a)=x\}$ и $\lR\lW= \lR\cup \lW$.
\item Строгий частичный порядок на событиях $\lPO \suq \lE \times \lE$, называемый \emph{программным порядком}; он
      является объединением непересекающихся множеств $\{\lPO_i\}_{i\in \{0\} \cup \Tid}$,
      где $\lPO_0=\lE_0\times (\lE\setminus \lE_0)$, и для каждого потока 
      $i\in\Tid$ отношение $\lPO_i$ является полным порядком на множестве его событий 
      $\{a\in \lE \suchthat \lTID(a)=i\}$.
\item Отношения $\lDATA,\lCTRL,\lADDR\suq \lPO\setminus \lPO_0$, удовлетворяющие следующим ограничениям:
%% \vspace{-5pt}
%% \begin{multicols}{2}
\begin{itemize}
%% \squishlist
\item $\lDATA \suq \lR \times \lW$;
\item $\lADDR\suq \lR \times (\lR \cup \lW)$;
\item $\lCTRL;\lPO \suq \lCTRL$. 
%% \squishend
\end{itemize}
%% \end{multicols}
Они позволяют задавать зависимости по данным, по потоку управления и по целевому адресу инструкции соответственно.
\item Отношение $\lRF \suq [\lW]; {=_\lLOC}; [\lR]$, удовлетворяющее следующим ограничениям:
$(i)$ $\lVALW(a)=\lVALR(b)$ для любой пары $\tup{a,b}\in \lRF$;
$(ii)$ $a_1=a_2$, если $\tup{a_1,b},\tup{a_2,b}\in \lRF$; также вводится функция $\lRF^{-1}$, которая определена на
области отображения $\lRF$, $\codom{\lRF}$, и для любого $a$ из $\codom{\lRF}$ верно следующее: $\tup{\lRF^{-1}(a), a} \in \lRF$.
%% $\lRFI^{-1}$ и $\lRFE^{-1}$ are also partial functions such that for all $a \in \codom{\lRF}$,
%% $\{\lRFI^{-1}(a), \lRFE^{-1}(a)\} = \{\bot, \lRF^{-1}(a)\}$, $\lRFI^{-1}(a) \neq \bot$ if $\lTID(a) = \lTID(\lRF^{-1}(a))$,
%% and $\lRFE^{-1}(a) \neq \bot$ if $\lTID(a) \neq \lTID(\lRF^{-1}(a))$.
\item Строгий частичный порядок $\lCO$ на элементах $\lW$,
      являющийся объединением отношений $\{\lCOx\}_{x\in\Loc}$,
      где $\lCOx$ --- это полный порядок на элементах $\lW_x = \{ e \in \lW \suchthat \lLOC(e) = x\}$.
\end{enumerate}
%% \end{restatable}
\end{definition}
%% Мы также используем некоторые производные отношения. Так, $\lFR \defeq \lRF^{-1}; \lCO$ --- это отношение
%% связывает событие чтения с событием записи, которое $\lCO$-следует за прочитанным событием записи.
\noindent
С помощью суффиксов $\mathtt{i}$ и $\mathtt{e}$ обозначаются подмножества отношений, которые связывают события одного
и разных потоков соответственно. 
Например, $\lCOI = \{ \tup{w, w'} \in \lCO \mid \lTID(w) = \lTID(w') \}$ и
$\lRFE = \{ \tup{w, r} \in \lRF \mid \lTID(w) \neq \lTID(r) \}$.
\begin{align*}
\lOBS &\defeq  \lRFE \cup \lFRE \cup \lCOE  \tag{\emph{observed-by}} \\
\lDOB &\defeq \inarr{(\lADDR \cup \lDATA); \lRFI^? \cup {} \\
	(\lCTRL \cup \lDATA); [\lW]; \lCOI^? \cup {} \\
	\lADDR; \lPO; [\lW]} \tag{\emph{dependency-ordered-before}} \\
\lBOB &\defeq \inarr{\lPO; [\lDMBSY] \cup [\lDMBSY]; \lPO  \cup {} \\
                    {} [\lR]; \lPO; [\lDMBLD] \cup [\lDMBLD]; \lPO} \tag{\emph{barrier-ordered-before}}
\end{align*}
\begin{definition}
%% \label{def:model}
Сценарий поведения $G$ является \ARM-согласованным, если выполняются следующие условия:
%% \squishlist
\begin{itemize}
\item $\lR = \codom{\lRF}$; \labelAxiom{completeness}{ax:comp}
\item отношение $\lPO\rst{\lLOC} \cup \lFR \cup \lCO \cup \lRF$ не имеет циклов; \labelAxiom{internal}{ax:internal}
\item отношение $\lOBS \cup \lDOB \cup \lBOB$ не имеет циклов. \labelAxiom{external}{ax:external}
%% \squishend
\end{itemize}
\end{definition}
\section{Доказательство корректности компиляции}
\label{sec:highlevel}
\noindent
Центральным результатом данной главы является следующая теорема. 
%% \begin{restatable}{thm}{mainthm}
\begin{theorem}
  \label{prop:compile-theorem}
  Для любой программы \Prog, результата её компиляции \ProgARM и \ARM-согласованного
  сценария поведения $G$ программы
  \ProgARM существует такой сценарий поведения обещающей машины, что
  финальное состояние памяти машины совпадает с состоянием памяти $G$.
\end{theorem}
%% \end{restatable}
\noindent
Здесь под ``финальным состоянием памяти'', также как и в случае корректности компиляции для
ARMv8 POP, понимается, в случае обещающей семантики, значение последних записей в локации (т.е. записей с наибольшими
метками времени), а в случае ARMv8.3 --- события-максимумы в отношении частичного порядка $G.\lCO$. Обе модели заданы в существенно разных стилях и, как следствие, имеют множество концептуальных отличий. Для доказательства теоремы \ref{prop:compile-theorem} необходимо преодолеть данные различия.
Главным отличием этих моделей является то, что обещающая модель памяти представлена операционно, в терминах
шагов некоторой абстрактной машины, а модель ARMv8.3 является аксиоматической и задаёт семантику 
сценария поведения программы в виде графа с определёнными свойствами. 
Для решения данной проблемы вводится операционная семантика обхода графа \ARM-согласованного
сценария поведения,
шаги которой обещающая машина может непосредственно повторять (раздел \ref{sec:traversal}).
Другим существенным отличием являются те способы, которыми данные модели запрещают ``плохие'' сценарии.  Например,
такие как чтение потоком старой записи в $x$ в случае, если поток уже выполнял чтение из более новой записи в $x$.
Для предотвращения этой ситуации модель ARMv8.3 использует аксиомы, которые проверяют отсутствие циклов в графе, 
обещающая модель в этом случае использует фронты потоков и сообщений.
Для того, чтобы обойти описанное различие между моделями,
мы вводим дополнительные отношения на вершинах \ARM-согласованного сценария поведения,
которые тесно связаны с фронтами обещающей модели (раздел \ref{sec:view}).
Используя эти идеи, мы доказываем корректность компиляции между обещающей и ARMv8.3 моделями
с помощью симуляции (раздел \ref{sec:simulation}).
%% DK --- и надо сказать, что это является лишь схемой доказательства. 
%% И указать в приложение, где находится все доказательство целиком. 
%
%% Как читатель мог убедиться после прочтения разделов \ref{sec:promise} и \ref{sec:arm}, обещающая и ARMv8.3 модели памяти
%% очень сильно отличаются по стилю представления. Для того, чтобы приодолеть это 
%семантики программы.
%% В данной работе мы исходим из двух предположений.
%% Во-первых, любая программа представляет собой вернеуровневую композицию потоков
%% и новые потоки не могут создаваться динамически. Такое ограничение принято в обоих моделях.
%% Во-вторых, мы считаем, что целевая программа и результат компиляции отличаются только инструкциями
%% обращения к памяти и, с точностью до семантики обращений к памяти, поведение программ в обоих моделях
%% совпадает. Это означает, что для любой программы \Prog, результата ее компиляции \ProgARM,
%% \ARM-согласованного исполнения $G$ программы \ProgARM и потока $tid$, существует цепочка в помеченной
%% системе переходов обещающей модели памяти, которая соответствуют множеству событий $\{e \in G \st \lTID(e) = tid\}$.
%% Последнее позволяет нам сформулировать основную теорему без упоминания конкретных программ.

\section{Обход \ARM-согласованных сценариев}
\label{sec:traversal}

%% В разделе \ref{sec:highlevel} мы обсудили, что наше доказательство корректности компиляции представляет
%% собой симуляцию обещающей машиной некоторого обхода \ARM-согласованных исполнений.
%% В этом разделе мы введем данный обход.
В этом разделе
мы сначала определяем вспомогательные понятия,
затем формализуем понятие шага обхода и доказываем существование
последовательности шагов, которые полностью обходят любой \ARM-согласованный сценарий поведения.
\begin{definition}
%% \begin{restatable}{mydefinition}{confdef}
\emph{Конфигурацией обхода} для \ARM-согласованного сценария поведения $G$
называются множества $\tup{C, \IssuedSet}$ такие, что:
\begin{itemize}
  \item $C \suq G.\lE$,
  \item $\dom{G.\lPO;[C]}\suq C$,
  \item $C \cap G.\lW \suq \IssuedSet \suq G.\lW$.
\end{itemize}
Элементы $C$ мы будем называть \emph{покрытыми} (covered), а $\IssuedSet$ --- \emph{выпущенными} (issued).
\end{definition}
%% \end{restatable}
%% DK в определении выше снова произвольно прыгает курсив и некурсив. 
%% Обратите на это пристальное внимание. 
Покрытые события при симуляции будут соответствовать префиксу программы,
который исполнен обещающей машиной, а выпущенные --- записями, 
находящимся в памяти обещающей машины
в соответствующий момент исполнения.
%% \begin{restatable}{mydefinition}{nextsetdef}
\begin{definition}
  Для 
  сценария поведения $G$ и его покрытия $C \suq G.\lE$ \emph{множеством следующих событий} $\nextset(G, C)$
  называется множество, состоящие из событий, для которых все $\lPO$-предшествующие события уже покрыты:
  \[\nextset(G, C) \defeq \{b \in G.\lE \mid \dom{G.\lPO;[b]} \suq C\} \setminus C.\]
\end{definition}
%% \end{restatable}
При симуляции данное множество будет содержать по одному событию для каждого ещё не завершённого в обещающей машине потока,
причём события будут соответствовать следующему переходу в потоке --- переходу, который не является обещанием.
Так, если бы обещающая семантика была определена поверх некоторого синтаксиса, то множество
следующих событий соответствовало бы инструкциям, на которые указывают счётчики команд  потоков (program counters)
в обещающей модели.
\begin{definition}
%% \begin{restatable}{mydefinition}{coverdef}
В конфигурации обхода $\tup{C, \IssuedSet}$ событие $a$ является \emph{покрываемым} для сценария поведения $G$
и обозначается $a\in \coverable(G, C, \IssuedSet)$, если событие $a$:
  \begin{itemize}
    \item является событием чтения, и связанное с ним событие записи оказывается выпущенным ($a \in G.\lR$ и $\lRF^{-1}(a) \in \IssuedSet$),
    \item или выпущенным событием ($a \in \IssuedSet$),
    \item или барьером памяти ($a \in G.\lF$).
  \end{itemize}
\end{definition}
%% \end{restatable}
В нашем обходе, заданном операционным образом, имеется шаг, который ``покрывает'' событие, т.е. добавляет
его во множество покрытых. Событие, которое покрывается данным правилом, должно соответствовать представленным выше ограничениям.
Эти ограничения, в свою очередь,  соответствуют ограничениям обещающей машины. Например, обещающая машина может 
прочитать из некоторого конкретного сообщения только тогда, когда данное сообщение есть в памяти,
т.е. соответствующее ему событие $w$ уже выпущено: $w \in \IssuedSet$.
\begin{definition}
%% \begin{restatable}{mydefinition}{issuedef}
Для сценария $G$ событие $w$ называется \emph{выпускаемым}
в конфигурации обхода $\tup{C, \IssuedSet}$,
$w\in\issuable(G, C, \IssuedSet)$, если выполнены следующие условия:
      \begin{itemize}
        \item $w$ является событием записи ($w\in G.\lW$);
        \item все $\lPO$-предшествующие барьеры покрыты
          ($\dom{[\lF];G.\lPO;[w]} \suq C$);
          \labelAxiom{write-bob}{req:write-bob}
        \item все записи других потоков, от которых зависит $w$, выпущены
          ($\dom{G.\lRFE;G.\lDOB^{+};[w]} \suq \IssuedSet$).
          \labelAxiom{write-dob}{req:write-dob}
        %% \item все $\lPO$-предшествующие записи в ту же локацию выпущены
        %%   ($\dom{G.\lCOI;[w]} \suq \IssuedSet$)
        %%   \labelAxiom{write-coi}{req:write-coi}
      \end{itemize}
\end{definition}
%% \end{restatable}
Если шаг обхода  ``выпускает'' событие записи, то он соответствует в симуляции обещанию, которое делает обещающая машина.
Ограничение \ref{req:write-bob} является более строгим, чем ограничение из обещающей семантики ---
обещание может быть сделано  посредством приобретающего барьера, который соответствует $\fenceInst{\LD}$ в ARMv8.3,
однако более строгое ограничение позволяет упростить симуляцию.
Ограничение \ref{req:write-dob} требуется для того, чтобы обещающая модель могла сертифицировать обещание, которое она
делает.
Шаги обхода задаются так:
\begin{mathpar}
\inferrule*{
    a \in \nextset(G, C) \cap \coverable(G, C, \IssuedSet) 
}{
    G \vdash 
    \tup{C, \IssuedSet} \travConfigStep \tup{C \cup \{a\}, \IssuedSet}
} \and
\inferrule*{
    w \in \issuable(G, C, \IssuedSet) \setminus \IssuedSet 
    }{
    G \vdash
    \tup{C, \IssuedSet} \travConfigStep \tup{C, \IssuedSet \cup \{w\}}
}
\end{mathpar}
Здесь левое правило покрывает событие, если оно принадлежит множеству
следующих за ним событий и при этом покрываемо в данной конфигурации.
Правое правило выпускает событие записи, если событие выпускаемо и при этом ещё не выпущено.
%% Из определения конфигурации обхода очевидно, что правила обхода связывают конфиг
Поскольку каждое конкретное \ARM-согласованный сценарий поведения
является конечным графом,
а указанные выше шаги обхода наращивают конфигурации, то для доказательства наличия полного
обхода графа достаточно показать, что для каждой не конечной конфигурации существует шаг к новой конфигурации.
\begin{theorem}
%% \begin{restatable}{thm}{travthm}
  \label{prop:trav-step}
  Пусть $\tup{C, \IssuedSet}$ является конфигурацией \ARM-согласованного сценария поведения $G$,
  при этом конфигурация достижима из начальной
  ($G \vdash \tup{\emptyset, \emptyset} \travConfigStep^{*} \tup{C, \IssuedSet}$) и $C \neq G.\lE$.
  Тогда существуют такие $C'$ и $\IssuedSet'$, что
  $G \vdash \tup{C, \IssuedSet} \travConfigStep \tup{C', \IssuedSet'}$.
\end{theorem}
%% \end{restatable}
Доказательство теоремы основано на следующих вспомогательных леммах.%
\begin{lemma}
%% \begin{restatable}{lem}{travproplem}
  \label{prop:trav-prop-preserve}
  Пусть $G \vdash \tup{\emptyset, \emptyset} \travConfigStep^{*} \tup{C, \IssuedSet}$.
  %If $G$ is  $\ARM$-consistent, 
  Тогда $C \suq \coverable(G,C,\IssuedSet)$ и $\IssuedSet \suq \issuable(G,C,\IssuedSet)$.
\end{lemma}
%% \end{restatable}
\begin{proof}
  Утверждение леммы следует из определений $\coverable$ и $\issuable$, а также из того, что размеры множеств покрытых и выпущенных событий при обходе $G$ увеличиваются.
\end{proof}
\begin{lemma}
%% \begin{restatable}{lem}{nextwritelem}
  \label{prop:next-write}
  Пусть $G \vdash \tup{\emptyset, \emptyset} \travConfigStep^{*} \tup{C, \IssuedSet}$.
  %If $G$ is  $\ARM$-consistent, 
  Тогда $\lW \cap \nextset(G, C) \suq \issuable(G,C,\IssuedSet)$.
\end{lemma}
%% \end{restatable}
\begin{proof}
  Зафиксируем $w \in \lW \cap \nextset(G, C)$ и покажем, что $w \in \issuable(G, C, \IssuedSet)$.
  Т.к. $w \in \nextset(G, C)$, то все $\lPO$-предшествующие события являются покрытыми (т.е.
  находятся в $C$), из этого следует, что выполняется \ref{req:write-bob}. Кроме того, из леммы
  \ref{prop:trav-prop-preserve} следует, что все покрытые события являются покрываемыми. Таким образом, можно заключить, что выполняется 
  \ref{req:write-dob}.
\end{proof}
\begin{proof}[Доказательство теоремы \ref{prop:trav-step}]
  Нам известно, что $\nextset(G, C) \neq \emptyset$, т.к. $C \neq G.\lE$.
  Рассмотрим два следующих варианта: (i) существует
  элемент $\nextset(G, C)$, который покрываем, или сначала выпускаем, а потом покрываем; (ii) 
  все элементы в $\nextset(G, C)$ не покрываемы и не выпускаемы
  (для этого случая мы показываем, что в $G$ существует событие записи, которое выпускаемо в данной конфигурации).

  {\bf Первый вариант}.
  Зафиксируем элемент $a \in \nextset(G, C)$.
  Если $a \in \lR$ и $\lRF^{-1}(a) \in \IssuedSet$, или $a \in \lF$, или $a \in \lW \cap \IssuedSet$,
  тогда $a$ покрываем по определению.
  Если $a \in \lW \setminus \IssuedSet$, тогда $a$ --- выпускаемо по лемме \ref{prop:next-write}.

  {\bf Второй вариант}.
  В этом случае мы предполагаем, что не существует  события из $\nextset(G, C)$, которое покрываемо или выпускаемо.
  Таким образом $\nextset(G, C) \suq \lR$ является следствием леммы \ref{prop:next-write} и определения покрываемого события.
  Кроме того, для любого чтения события $r$ из $\nextset(G, C)$ мы знаем, что $\lRF^{-1}(r) \nin \IssuedSet$.
  Далее покажем, что существует событие записи, которое выпускаемо в данной конфигурации.
  Для этого введём вспомогательное отношение $\lEORD \defeq (\lOBS \cup \lDOB \cup \lBOB)^{+}$,
  которое антирефлексивно по определению \ARM-согласованности (\ref{ax:external}).
  
  Мы знаем, что имеется, как минимум, одно событие (чтения) из $\nextset(G, C)$, которое при этом не покрываемо.
  Это означает, что существует событие записи, которое ещё не выпущено.
  Выберем событие записи $w \in \lW \setminus \IssuedSet$, которое является минимальным среди не выпущенных записей по отношению $\lEORD$,
т.е. $\nexists w' \in \lW \setminus \IssuedSet. \; \lEORD(w', w)$.
  Осталось показать, что событие $w$ выпускаемо.
  
  Т.к. $w \nin \nextset(G, C)$, то существует событие чтения $r \in \nextset(G, C)$ такое, что $\lPO(r, w)$
  и $\lRF^{-1}(r) \nin \IssuedSet$. При этом $\lRF^{-1}(r) = \lRFE^{-1}(r)$, т.к.
  $C \cap \lW \suq \IssuedSet$ и $\forall e \in C. \; \dom{\lPO; [e]} \in C$.
  Для доказательства того, что $w$ выпускаемо, требуется  показать, что два следующих утверждения выполняются.
  \begin{itemize}
    \item[\ref{req:write-bob}:] Пусть $f \in \lF$ и $\lPO(f, w)$.
      Предположим, что $f \nin C$. Тогда $\lPO(r, f)$ и $\tup{\lRFE^{-1}{(r)}, w} \in \lOBS; \lBOB^{+} \suq \lEORD$.
      Т.к. $\lRFE^{-1}(r) \nin \IssuedSet$, то существует $\lEORD$-предшествующее $w$ событие записи, которое не выпущено.
      Это противоречит выбору $w$.
    \item[\ref{req:write-dob}:] Пусть существует событие чтения $r'$ такое, что $\lDOB^{+}(r', w)$.
      Если $\lRFE^{-1}(r') \neq \bot$, то
      $\tup{\lRFE^{-1}(r'), w} \in \lRFE; \lDOB^{+} \suq \lOBS; \lDOB^{+} \suq \lEORD$. По опеределению $w$ это означает,
      что $\lRFE^{-1}(r') \in \IssuedSet$.
    %% \item[\ref{req:write-coi}:]
      %% Let $w'$ such that $\lCOI(w', w)$. If $w' \nin \IssuedSet$, it contradicts $\lEORD$-minimality of $w$.
\qedhere
\end{itemize}  
\end{proof}

\section{Симуляция обхода обещающей машиной}
\label{sec:simulation} 
\noindent
{\bf Теорема \ref {prop:compile-theorem}.}
  Для любой программы \Prog, результата её компиляции \ProgARM и \ARM-согласованного
  сценария поведения $G$ программы
  \ProgARM существует такой сценарий поведения обещающей машины, что 
  финальное состояние памяти машины совпадает с состоянием памяти $G$.
\begin{proof}
  Зафиксируем \ARM-согласованный сценарий $G$.
Покажем, что обещающая модель может симулировать
  обход сценария $G$ (лемма \ref{lem:simulation}).
 Для этого, как это обычно делается в доказательствах с помощью симуляции, введём
  отношение симуляции $\simrel$, которое будет связывать конфигурацию обхода $G$ с состоянием обещающей машины.
  
\begin{lemma}
%% \begin{restatable}{lem}{lemsimulation}
  \label{lem:simulation}
  Существуют такие $\TSf$ и $M$, что $\simRel(G.\lE, G.\lW, \TSf, M)$ и
  $\tup{\TSf_{\rm init}, M_{\rm init}} \stepp^{*} \tup{\TSf, M}$.
%% \end{restatable}
\end{lemma}
%% \begin{proof}
%%   We define $T$ to be correct by construction.
%%   We show $(\tup{\emptyset, \emptyset}, \TSf_{\rm init}, M_{\rm init}) \in \simRel$
%%   We choose a traversal $G, \lSC \vdash \tup{\emptyset, \emptyset} \travConfigStep^{*} \tup{G.\lE, G.\lW}$, which
%%   exists via \cref{prop:trav-step}. For each step of the traversal we apply \cref{prop:sim-step}.
%% \end{proof}
  Мы определим отношение симуляции $\simrel$ так, чтобы из него было очевидно, что финальное состояние памяти
  $M$ совпадает с состоянием памяти сценария $G$, а также что выполняется $\simRel(\emptyset, \emptyset, \TSf_{\rm init}, M_{\rm init})$.
   После этого доказательство теоремы будет непосредственно следовать из доказательства леммы \ref{lem:simulation}.
Сама лемма доказывается индукцией с использованием леммы \ref{lem:sim-step}. Последняя показывает,
  что для любой неполной конфигурации обхода существует шаг, который обещающая машина может симулировать. 
\begin{lemma}
%% \begin{restatable}{lem}{lemsimstep}
  \label{lem:sim-step}
  Пусть для некоторых конфигураций обхода $\tup{C, \IssuedSet}$ и $\tup{C', \IssuedSet'}$ сценария $G$,
  а также некоторого состояния обещающей машины $\tup{\TSf, M}$ выполняется
  $G \vdash \tup{C, \IssuedSet} \travConfigStep \tup{C', \IssuedSet'}$ и
  $\simRel(C, \IssuedSet, \TSf, M)$.
  Тогда существуют такие $\TSf'$ и $M'$, что $\tup{\TSf, M} \stepp\!\!^{+} \tup{\TSf', M'}$ и
  $\simRel(C', \IssuedSet', \TSf', M')$.
%% \end{restatable}
\end{lemma}
\noindent Доказательство леммы \ref{lem:sim-step} приведено в приложении \ref{sec:sim-step-proof}.
\end{proof}
  
  Далее опишем вспомогательные отношения на графах, которые будут нужны для выражения связи 
с фронтами обещающей модели в отношении симуляции, а также  само отношение симуляции.
  
Как и в доказательстве теоремы \ref{prop:compile-theorem} мы зафиксируем \ARM-согласованный сценарий $G$ и будем вводить
все определения в контексте $G$.
  
\subsection{Аналоги фронтов для \ARM-согласованных сценариев}
\label{sec:view}
  %% Этот раздел посвящен данным вопросам.
  Введём вспомогательную функцию $T: \TimestampMap = \lW \rightarrow \mathbb{N}$,
  сопоставляющую событиям записи в $G$ их порядковые номера в отношении $\lCO$ так, чтобы  выполнялось $\correctTmap(G, T)$:
  \[\inarr{
    \correctTmap(G, T) \defeq \forall w, w'. \; \\
    %%, r \in \lE
    \quad (\tup{w, w'} \in \lCO \implies T(w) < T(w')) \land {} \\
    \quad (w \nin \codom{\lCO} \implies T(w) = 0).
    %% \land {} \\ \quad (\tup{w,r} \in \lRF \implies T(w) = T(r)). \\
    %% a compilation function $\compileF : \lE \rightarrow \TransSet$ s.t. $\compileReq(\compileF)$ holds.
  }\]
  Данная функция, фактически, вводит метки времени на событиях записи $G$.
  
  Далее введём вспомогательные отношения $\lSW$ (synchronized-with) и $\lHB$ (happens-before):
  \[\begin{array}{@{}r@{~}r@{~}l}
  \lSW & \defeq & [\lDMBSY]; \lPO; \lRF; \lPO; [\lDMBLD] \\
  \lHB & \defeq & (\lSW \cup \lPO)^{+}. \\
  \end{array}\]
  Здесь отношение $\lSW$ представляет пути в графе, соответствующие передаче информации о событиях
  записи с помощью \ARM-аналогов высвобождающего ($\lDMBSY$) и приобретающего ($\lDMBLD$) барьеров
  памяти. Отношение $\lHB$ мы будем использовать, чтобы определить
  отношения $\curRel$, $\acqRel$ и $\relRel$. Они в паре с функцией $T$ будут использованы в симуляции
  как ограничения для базового, приобретающего и высвобождающего фронтов потока в обещающей модели памяти.
  \[\begin{array}{@{}r@{~}r@{~}l}
  \curRel & \defeq & \lRF^{?}; \lHB \\
  \acqRel & \defeq & \lRF^{?}; \lHB; ([\lDMBSY]; \lPO; \lRF; \lPO)^? \\
  \relRel & \defeq & \lRF^{?}; \lHB; [\lDMBSY]; \lPO \\
  \end{array}\]
  Аналогичным образом отношение $\msgRel \suq \lW \times \lW$ представляет ограничение на фронт сообщения
  из обещающей модели. Так, если $\tup{w, w'} \in \msgRel$ и события $w$ и $w'$ соответствуют
  сообщениям $m$ и $m'$ в памяти обещающей модели, то $m.\tau = T(w)$, $m'.\tau = T(w')$ и
  $m'.\view(\lLOC(w)) \ge m.\tau$.
  \[\begin{array}{@{}r@{~}r@{~}l}
  \msgRel & \defeq & \lRF^{?}; \lHB; [\lDMBSY]; \lPO \cup [\lW] \\
  \end{array}\]
  
  \subsection{Отношение симуляции $\simrel$}
  Это отношение мы определим следующим образом:
  \[\inarr{
    \simRel(C, \IssuedSet, \TSf, M) \defeq \invMemOne(C, \IssuedSet, \TSf, M) \land  \invMemTwo(C, \IssuedSet, M) \land {} \\
    \quad \invView(C, \TSf) \land \invViewRel(\TSf) \land \invState(C, \TSf).
  }\]
  $\invMemOne(C, \IssuedSet, \TSf, M)$ утверждает, что все выпущенные
  события $\IssuedSet$ имеют аналоги в памяти обещающей машины, причём выполненные обещания соответствуют покрытым
  событиям записи:
  \[\inarr{
  \invMemOne(C, \IssuedSet, \TSf, M) \defeq \forall w \in \IssuedSet. \; \exists \view \le \domView(\msgRel; [w]). \; \\
  \quad \letdef{msg}{\msg{\lLOC(w)}{\lVALW(w)}{T(w)}{\view}} \\
  \quad \letdef{\PromSet}{\TSf(\lTID(w)).\PromSet} \\
  \quad (w \in  C \implies msg \in M \setminus \PromSet) \land (w \nin C \implies msg \in \PromSet). \\
  }\]
  Здесь $\domView$ является вспомогательной функцией, которая по множеству записей строит соответствующий фронт:
  \[\begin{array}{@{}l@{~}l}
    \setView(S) & \defeq \lambda \loc. \; \max \{ T(w) \mid w \in S, \lLOC(w) = \loc\}. \\
    \domView(R) & \defeq \setView(\dom{R}). \\
  \end{array}\]
  
  $\invMemTwo(C, \IssuedSet, M)$ обозначает обратную связь --- для каждого сообщения из $M$ существует
  соответствующее ему выпущенное событие в $\IssuedSet$:
  \[\inarr{
  \invMemTwo(C, \IssuedSet, M) \defeq \forall \msg{\loc}{\val}{\tau}{\view} \in M. \; \tau \neq 0 \Rightarrow
    \exists w \in \IssuedSet. \; \\
  \quad \loc = \lLOC(w) \land \val = \lVALW(w) \land \tau = T(w) \land \view \le \domView(\msgRel; [w]). \\
  }\]
  $\invView(C, \TSf)$ утверждает, что для любого элемента множества следующих событий ($\nextset(G, C)$)
  фронты, представляющие связанные с ним отношениями $\curRel$, $\acqRel$ и $\relRel$ события записи, больше, чем
  базовый, приобретающий и высвобождающие фронты соответствующего потока:
%% DK предложение выше я не понял. Разбейте, пожалуйста, его на два. 
  \[\inarr{
  \invView(C, \TSf) \defeq
  \forall e \in \nextset(G, C). \\
  \quad \letdef{\tup{\viewCur, \viewAcq, \viewfRel}}{\TSf(\lTID(e)).\View} \\
  \quad
  \begin{array}{@{}r@{~}l@{~}l}
    \viewCur & \le \domView(\curRel; [e]) & \land {} \\
    \viewAcq & \le \domView(\acqRel; [e]) & \land {} \\
    \viewfRel & \le \domView(\relRel; [e]). \\
  \end{array}
  }\]
  $\invViewRel(\TSf)$ показывает, что все обещания, которые ещё не выполнены, имеют специальную форму
  фронтов, а именно состоят  из значения высвобождающего фронта соответствующего потока и метки времени самого обещания:
  \[\inarr{
  \invViewRel(\TSf) \defeq \forall tid, \msg{\loc}{\_}{\tau}{view} \in \TSf(tid).\PromSet. \\
    \quad view = [\loc @ \tau] \sqcup \TSf(tid).\View.\viewfRel. \\
  }\]
  $\invState(C, \TSf)$ утверждает, что для каждого потока $tid$ существует список переходов $\{t_i\}_{i \in [1..k]}$,
  который соответствует событиям в $tid$-подграфе сценария $G$, и текущее состояние потока $\TSf(tid).\sigma$
  получено с помощью $p$ переходов из списка, где $p$ --- это количество покрытых событий, $|\lEID \cap C|$.
  \[\inarr{
  \invState(C, \TSf) \defeq \forall tid, k = |\lEID|. \;
     \exists \{\pstate_i\}_{i \in [0 .. k]}, \{t_i\}_{i \in [1..k]}. \; \\
  \quad \letdef{p}{|\lEID \cap C|} \\
  \quad \TSf(tid).\pstate = \pstate_{p} \land 
    (\forall j \in [0..k-1]. \; \pstate_j \astep{\epsilon}\!\!^{*}\astep{t_j} \pstate_{j + 1})\land {} \\
  \quad \forall n \in [1..k], a \in \nthf \; ([\lEID]; \lPO; [\lEID]) \; (n - 1). \;
    t_{n + 1} \approx \lLAB(a).
  %% \quad \ltsReq(tid, \compileF, \{\pstate_i\}_{i \in [0 .. k]}, \{t_i\}_{i \in [1..k]}). \\
  }\]
  Здесь функция $\nthf \; porder \; n$ возвращает
  элементы с номером $n$ из отношения частичного порядка $porder$, 
  a предикат $t \approx \lLAB(a)$ является истинным тогда и только тогда, когда метка перехода $t$
  соответствует метке события $a$.
  Формальные определения  $\nthf$ и $\approx$ приведены в приложении \ref{sec:lts-rel}.
  %% отношение, в частности, утверждает связь между выпущенными событиями записи
  %% (компонентой $\IssuedSet$ в конфигурации обхода $G$)
  %% и состоянием памяти обещающей машины.
  %% Отношение $\invMemOne(C, \IssuedSet, \TSf, M)$ утверждает, что для каждого выпущенного события существует соответствующая
  %% ему запись во памяти обещающей машины (с теми же локацией, значением и меткой времени).
\section{Выводы}
В этой главе мы привели доказательство корректности компиляции для подмножества
обещающей модели памяти \cite{Kang-al:POPL17} в модель памяти ARMv8.3 \cite{Pulte-al:POPL18}.
Рассмотренное подмножество состоит из ослабленных операций чтения и записи, приобретающих и высвобождающих барьеров памяти. 

Доказательство базируется на новой идее обхода исполнений в аксиоматических
семантиках, который может симулировать обещающая модель памяти. 
Данная идея может быть использована для доказательств
корректности компиляции в другие модели памяти, что ценно, т.к. подобные задачи регулярно появляются
ввиду бурного развития области.
В дальнейшие планы входит расширение доказательства
до полной обещающей модели памяти. Для этого нужно будет поддержать операции
приобретающего чтения (read acquire) и высвобождающей записи (write release),
атомарные инструкции чтения и записи (read-modify-write), частным случаем которых
является сравнение с обменом (compare-and-set, CAS), а также полные барьеры памяти (SC fences).
Поддержка данных инструкций потребует небольшого усложнения обхода \ARM-согласованных
исполнений, а также существенного усложнения отношения симуляции ввиду большого количества деталей,
связанных с упомянутыми инструкциями в рамках обещающей модели памяти.
