\chapter{Корректность компиляции из ,,обещающей`` модели в аксиоматическую модель ARMv8.3} \label{sec:armv83}

\section{Модель ARMv8.3 на примерах} \label{sec:armv83examples}
Распространенным способом показать корректность компиляции из абстрактной машины $A$ в машину $B$
является доказательство \emph{симуляции} между ними \cite{Milner:Book89}. Для этого определяется \emph{отношение симуляции},
связывающее состояния машин, и доказывается, что если текущие состояния машин $A$ и $B$ связаны отношением
симуляции, и машина $B$ делает шаг, то машина $A$ может сделать ноль и более шагов так, чтобы новые состояния
машин были также связаны отношением симуляции. Напрямую данный подход не применим для доказательства
корректности компиляции из обещающей модели в модель ARMv8.3, т.к.
модель памяти ARMv8.3 является аксиоматической, т.е. семантика конкретной программы в этой модели есть
множество графов, каждый из которых представляет некоторый конкретный запуск программы. Это означает, что
в модели ARMv8.3 запуск программы определяется сразу и целиком, а не по шагам, как это происходит в
обещающей модели, заданной в виде абстрактной машины.
Чтобы преодолеть данное ограничение, мы разработали способ обхода графов модели ARMv8.3,
который представлен в виде операционной семантики.
Этот обход и используется при доказательстве симуляции между обещающей и ARMv8.3 моделями.
Данный метод может быть использован для доказательства корректности компиляции из
обещающей в аксиоматические модели памяти, и является более общим, чем использованные ранее методы
(см. раздел \ref{sec:related}), базирующиеся на особых свойствах целевых аксиоматических моделей.

%% Модель ARMv8.3 является аксиоматической моделью памяти.
%% Как и многие другие аксиоматические семантики,
%% представленные в работах \cite{Batty-al:POPL11, Alglave-al:TOPLAS14, }
Модель памяти ARMv8.3 представляет семантику программы как множество графов, каждый
из которых соответствует некоторому конкретному запуску программы \cite{Pulte-al:draft17}.
Так, например, для программы ${\rm MP}$, которую мы уже рассматривали в разделе \ref{sec:promise},
%% \begin{equation*}
%% \tag{MP}
%% \begin{tabular}{L || L}
%%   \writeInst{x}{1}; & \readInst{a}{y}; \\
%%   \writeInst{y}{1}; & \readInst{b}{x}; \\
%% \end{tabular}
%% \end{equation*}
исполнение программы с результатом $a = 1, b = 0$ выглядит следующий образом:
\[
\begin{tikzpicture}[yscale=1,xscale=1.8]
  \node (01)  at (-1,2) {$\wlab{}{x}{0}$ };
  \node (02)  at (0,2) {$\wlab{}{y}{0}$ };
  \node (1)  at (-1,1) {$\wlab{}{x}{1}$ };
  \node (2)  at (-1,0) {$\wlab{}{y}{1}$ };
  \node (11) at (0,1)  {$\rlab{}{y}{1}$ };
  \node (12) at (0,0)  {$\rlab{}{x}{0}$ };
  \draw[po] (1)  edge  (2);
  \draw[po] (11) edge (12);
  \draw[po] (01) edge (11);
  \draw[po] (02) edge (11);
  \draw[po] (01) edge (1);
  \draw[po] (02) edge  (1);
  %% \draw[deps,bend left=20] (11)  edge node[right] {\small $\lDEPS$} (12);
  \draw[rf,bend left=70] (01)  edge node[above] {\small $\lRF$} (12);
  \draw[rf] (2)  edge node[below] {\small $\lRF$} (11);
  \draw[fr] (12) edge node[above] {\small $\lFR$} (1);
  \draw[mo,bend right=20] (01)  edge node[left] {\small $\lCO$} (1);
  \draw[mo,bend right=90] (02)  edge node[above] {} (2); %{\small $\lCO$} (2);
\end{tikzpicture}
\]
В графовом представлении каждый узел представляет некоторое \emph{событие} (event) ---
операцию над памятью. Событие может быть записью (например, $\wlab{}{x}{0}$), чтением (например, $\rlab{}{y}{1}$)
или барьером памяти (например, $\flab{\acq}$). В представленном выше графе
$\wlab{}{x}{0}$ и $\wlab{}{y}{0}$ обозначают инициализацию, %локаций $x$ и $y$ соответственно,
а остальные вершины --- операции левого и правого потоков.
Далее в статье мы будем использовать $\lW$, $\lR$ и $\lF$ как для обозначения меток конкретных событий,
так и для обозначения подмножества событий соответствующего типа.

Ребра в графе используются для обозначения различных отношений между событиями. Стрелки без подписи
обозначают $\lPO$ --- отношение \emph{программного порядка} (program order).
Программный порядок связывает инициализирующие записи со всеми остальными событиями в графе,
а также является полным порядком на событиях одного и того же потока\footnote{%
Программный порядок транзитивен, но в приведенном графе мы оставили только непосредственные ребра.
}.

События записи в одну и ту же локацию тотально упорядочены с помощью $\lCO$ ---
отношения \emph{согласованности} (coherence order).
Это отношение выполняет ту же функцию, что и метки времени в рамках обещающей машины.

Отношение $\lRF$ (``читает из'', reads from) связывает события записи с событиями чтения, причем
у каждого чтения должно существовать одна и только одна запись, с которой оно (чтение) связано
данным отношением, и целевые локации и значения событий должны совпадать.

Отношение $\lFR$ (``читает ранее'', reads before) является производным от $\lRF$ и $\lCO$:
\[ \lFR \defeq \lRF^{-1}; \lCO \]
и связывает чтение $a$ с записью, которая $\lCO$-следует за записью, из которой читает $a$.
%
%% Здесь и далее композиция отношений с помощью `$;$' задается так:
Здесь и далее композиция отношений `$;$' задается так:
\[A; B \defeq \{\tup{a, b} \mid \exists c. \; \tup{a, c} \in A \land \tup{c, b} \in B \}\]

Как и в случае обещающей семантики, добавление в программу ${\rm MP}$ барьеров памяти
запрещает результат $a = 1$ и $b = 0$:
\begin{equation*}
\tag{MP-sy-ld}\label{ex:MP-sy-ld}
\begin{tabular}{L || L}
  \writeInst{x}{1}; & \readInst{a}{y}; ~\valuecom{1} \\
  \syFence;         & \ldFence; \\
  \writeInst{y}{1}; & \readInst{b}{x}; ~\valuefail{0} \\
\end{tabular}
\end{equation*}
Данная программа не соответствует один в один программе ${\rm MP\text{-}rel\text{-}acq}$ из раздела \ref{sec:promise},
но является результатом компиляции ${\rm MP\text{-}rel\text{-}acq}$ в ассемблер ARMv8.3.

Каким образом модель ARMv8.3 запрещает поведение $a = 1$ и $b = 0$ для программы ${\rm MP\text{-}sy\text{-}ld}$?
Рассмотрим граф, который соответствует данному поведению:
\[
\begin{tikzpicture}[yscale=1,xscale=1.8]
  %% \node (01) at (-1,3) {$\wlab{}{x}{0}$ };
  %% \node (02) at (0,3) {$\wlab{}{y}{0}$ };
  \node (1)  at (-1,2) {$\wlab{}{x}{1}$ };
  \node (b1) at (-1,1) {$\flab{\SY}$ };
  \node (2)  at (-1,0) {$\wlab{}{y}{1}$ };
  \node (11) at (0,2)  {$\rlab{}{y}{1}$ };
  \node (b2) at (0,1)  {$\flab{\LD}$ };
  \node (12) at (0,0)  {$\rlab{}{x}{0}$ };
  \draw[po] (1)  edge  (b1);
  \draw[po] (b1)  edge  (2);
  \draw[po] (11) edge (b2);
  \draw[po] (b2) edge (12);
  %% \draw[po] (01) edge (11);
  %% \draw[po] (02) edge (11);
  %% \draw[po] (01) edge (1);
  %% \draw[po] (02) edge  (1);
  %% \draw[deps,bend left=20] (11)  edge node[right] {\small $\lDEPS$} (12);
  %% \draw[rf,bend left=70] (01)  edge node[above] {\small $\lRF$} (12);
  \draw[rf] (2)  edge node[below] {\small $\lRFE$} (11);
  %% \draw[mo,bend right=20] (01)  edge node[below] {\small $\lCO$} (1);
  %% \draw[mo,bend right=90] (02)  edge node[below] {\small $\lCO$} (2);
  \draw[fr] (12) edge node[above] {\small $\lFRE$} (1);
  \draw[deps,bend right=30] (1)  edge node[left] {\small $\lBOB^{+}$} (2);
  \draw[deps,bend left=30] (11) edge node[right] {\small $\lBOB^{+}$} (12);
\end{tikzpicture}
\]
В этом графе мы опустили инициализирующие записи и добавили отношение барьеров $\lBOB$ (barrier-ordered-before), заданное так:
\[
\lBOB \defeq \inarr{\lPO; [\lDMBSY] \cup [\lDMBSY]; \lPO  \cup [\lR]; \lPO; [\lDMBLD] \cup [\lDMBLD]; \lPO},
\]
где $[A] \defeq \{(a, a) \suchthat a \in A\}$.
Кроме того, мы заменили ребра отношений $\lRF$ и $\lFR$ ребрами отношений $\lRFE$ и $\lFRE$, где $\lmakeE{}$ (external) означает,
что соответствующее отношение связывает только события разных потоков.

В приведенном графе есть цикл из ребер $\lBOB$, $\lRFE$ и $\lFRE$, что противоречит одной из аксиом, которая используется
в модели ARMv8.3 для определения \ARM-согласованного исполнения (подробнее в разделе \ref{sec:armFormally}).
Таким образом граф не является \ARM-согласованным,
и поведение $a = 1$ и $b = 0$ запрещено для программы ${\rm MP\text{-}sy\text{-}ld}$ в рамках модели.

\section{Формальное определение модели ARMv8.3} \label{sec:armv83formally}
В этом разделе модель ARMv8.3 описывается  формально, в соответствии с \cite{Pulte-al:draft17}.

Мы не будем явным образом использовать язык \ARM-ассемблера
и будем считать, что он совпадает с исходным языком (см. рис. \ref{fig:syn-prog}) с точностью до
модификаторов барьера памяти:
\[\FtypeARM ::= \SY \mid \LD. \]
Также мы будем считать, что результатом компиляции любой программы $\Prog$ на исходном языке
является той же программой, в которой модификаторы $\rel$ заменены на $\SY$, а $\acq$ --- на $\LD$.

%% \label{subsec:arm-formally}
%% \url{https://github.com/herd/herdtools7/blob/master/herd/libdir/aarch64.cat}  \qquad (07-June-17)

%% \[\begin{array}{lccll}
%% \lL & = & STLR & \text{release(SC)} & \lW^\sco\\
%% \lA & = & LDAR & \text{acquire(SC)} & \lR^\sco\\
%% \lQ & = & ?    & \text{acquire(C11)} & \lR^\acq 
%% %% X & =      & atomic(RMW)
%% \end{array}\]

%% В нашей работе мы рассматриваем подмножество модели памяти ARMv8.3.

\begin{definition}
%% \begin{restatable}{mydefinition}{graphexdef}
\label{def:execution}
\emph{Исполнение} $G$ --- это граф, который состоит из следующих компонент.
\begin{enumerate}
\item Конечное множество \emph{событий} $\lE \suq \mathbb{N}$, которое включает
      выделенное множество начальных событий $\lE_0 = \{ a^x_0 \suchthat x \in \Loc \}$.
      Мы используем $a,b,\ldots$ как переменные для обозначения событий.

\item Функция $\lTID$, которая по событию из $\lE$  возвращает номер потока, породившего событие.
      При этом начальные события $a^x_0 \in \lE_0$ мы считаем относящимся к потоку с номером 0,
      $\lTID(a^x_0) = 0$.

\item Функция $\lLAB$, которая присваивает \emph{метку} каждому событию из $\lE$.
      Метки могут обозначать следующие операции:
\squishlist
\item \emph{чтение}, $\evlab{\lR}{o}{x}{v}$, где $x\in\Loc$ ---
  \emph{локация}, из которой событие читает \emph{значение} $v\in\Val$;
\item \emph{запись}, $\evlab{\lW}{o}{x}{v}$, где $x\in\Loc$ ---
  \emph{локация}, в которую событие записывает \emph{значение} $v\in\Val$;
\item \emph{барьер памяти}, $\flab{o}$, где $o\in \{\ld,\full\}$ --- \emph{тип барьера}, причем $\full$-барьеры строже, чем
  $\ld$, $\ld \sqsu \full$.
\squishend
Каждое начальное событие --- это инициализирующая запись в некоторую локацию:
\[\forall a^x_0 \in \lE_0. \; \lLAB(a^x_0) = \evlab{\lW}{\pln}{x}{0}.\]

Функция $\lLAB$ естественным образом определяет следующие частично определенные функции, которые
по событиям возвращают:
%% $\lTYP$, $\lMOD$, $\lLOC$, $\lVALR$ и $\lVALW$, такие что:
\begin{itemize}
  \item $\lTYP$ --- тип события ($\lR,\lW$ или $\lF$);
  \item $\lMOD$ --- тип барьера;
  \item $\lLOC$ --- целевую локацию;
  \item $\lVALR$ --- прочитанное значение;
  \item $\lVALW$ --- записанное значение.
\end{itemize}
Далее мы будем использовать $\lR, \lW$ и $\lF$ также и для обозначения соответствующих множеств
событий --- например, $\lR$ для обозначения $\{e\in \lE \suchthat \lTYP(e)=\lR\}$.
%% Далее $\lX$, элемент $\{\lR,\lW,\lF\}$, будет обозначать
%% множество $\{e\in \lE \suchthat \lTYP(e)=\lX\}$.
%% Мы пишем локацию в нижнем регистре для обозначения множества событий, оперирующих
%% над этой локацией и пишем обозначения множеств рядом, имея ввиду объединение множеств.
%% Например, $\lW_x = \{a \in \lW \mid \lLOC(a)=x\}$ и $\lR\lW= \lR\cup \lW$.

\item Строгий частичный порядок на событиях $\lPO \suq \lE \times \lE$, называемый \emph{программым порядком},
      который является объединением непересекающихся множеств $\{\lPO_i\}_{i\in \{0\} \cup \Tid}$,
      где $\lPO_0=\lE_0\times (\lE\setminus \lE_0)$ и для каждого потока 
      $i\in\Tid$ отношение $\lPO_i$ является полным порядоком на множестве событий этого потока
      $\{a\in \lE \suchthat \lTID(a)=i\}$.

\item Отношения $\lDATA,\lCTRL,\lADDR\suq \lPO\setminus \lPO_0$, которые удовлетворяют следующим ограничениям:
\vspace{-5pt}
\begin{multicols}{2}
\squishlist
\item $\lDATA \suq \lR \times \lW$;
\item $\lADDR\suq \lR \times (\lR \cup \lW)$;
\item $\lCTRL;\lPO \suq \lCTRL$. 
\squishend
\end{multicols}
Они представляют зависимости по данным, по потоку управления и по целевому адресу инструкции соответственно.

\item Отношение $\lRF \suq [\lW]; {=_\lLOC}; [\lR]$, которое удовлетворяет следующим ограничениям:
$(i)$ $\lVALW(a)=\lVALR(b)$ для любой пары $\tup{a,b}\in \lRF$;
$(ii)$ $a_1=a_2$, если $\tup{a_1,b},\tup{a_2,b}\in \lRF$. Мы также вводим функцию $\lRF^{-1}$, которая определена на
области отображения $\lRF$, $\codom{\lRF}$, и для любого $a$ из $\codom{\lRF}$ верно, что $\tup{\lRF^{-1}(a), a} \in \lRF$.
%% $\lRFI^{-1}$ и $\lRFE^{-1}$ are also partial functions such that for all $a \in \codom{\lRF}$,
%% $\{\lRFI^{-1}(a), \lRFE^{-1}(a)\} = \{\bot, \lRF^{-1}(a)\}$, $\lRFI^{-1}(a) \neq \bot$ if $\lTID(a) = \lTID(\lRF^{-1}(a))$,
%% and $\lRFE^{-1}(a) \neq \bot$ if $\lTID(a) \neq \lTID(\lRF^{-1}(a))$.

\item Строгий частичный порядок $\lCO$ на элементах $\lW$
      который является объединением отношений $\{\lCOx\}_{x\in\Loc}$,
      где $\lCOx$ --- полный порядок на элементах $\lW_x = \{ e \in \lW \suchthat \lLOC(e) = x\}$.
\end{enumerate}
%% \end{restatable}
\end{definition}

Мы также используем некоторые производные отношения. Так, $\lFR \defeq \lRF^{-1}; \lCO$ --- это отношение
связывает событие чтения с событием записи, которое $\lCO$-следует за прочитанным событием записи.
С помощью суффиксов $\mathtt{i}$ и $\mathtt{e}$ обозначаются подмножества отношений, которые связывают события одного
и разных потоков соответственно. Например, $\lCOI = \{ \tup{w, w'} \in \lCO \mid \lTID(w) = \lTID(w') \}$ и
$\lRFE = \{ \tup{w, r} \in \lRF \mid \lTID(w) \neq \lTID(r) \}$.

\begin{align*}
\lOBS &\defeq  \lRFE \cup \lFRE \cup \lCOE  \tag{\emph{observed-by}} \\
\lDOB &\defeq \inarr{(\lADDR \cup \lDATA); \lRFI^? \cup {} \\
	(\lCTRL \cup \lDATA); [\lW]; \lCOI^? \cup {} \\
	\lADDR; \lPO; [\lW]} \tag{\emph{dependency-ordered-before}} \\
\lBOB &\defeq \inarr{\lPO; [\lDMBSY] \cup [\lDMBSY]; \lPO  \cup {} \\
                    {} [\lR]; \lPO; [\lDMBLD] \cup [\lDMBLD]; \lPO} \tag{\emph{barrier-ordered-before}}
\end{align*}

%% \begin{definition}
\begin{restatable}{mydefinition}{armdef}
%% \label{def:model}
Исполнение $G$ является \ARM-согласованным, если выполняется следующее:
\begin{itemize}
\item $\lR = \codom{\lRF}$; \labelAxiom{completeness}{ax:comp}
\item отношение $\lPO\rst{\lLOC} \cup \lFR \cup \lCO \cup \lRF$ не имеет циклов; \labelAxiom{internal}{ax:internal}
\item отношение $\lOBS \cup \lDOB \cup \lBOB$ не имеет циклов. \labelAxiom{external}{ax:external}
\end{itemize}
\end{restatable}
%% \end{definition}
