\chapter{Корректность компиляции из обещающей модели в аксиоматическую модель ARMv8.3} \label{sec:armv83}
В этой главе описываются результаты, полученные диссертантом
в~\cite{Podkopaev-al:NTV17,Podkopaev-al:ISPRAS17}:
доказательство корректности эффективной схемы компиляции из
подмножества обещающей модели памяти \cite{Kang-al:POPL17} в аксиоматическую
модель памяти ARMv8.3 POP \cite{Pulte-al:POPL18}.
Рассмотренное подмножество обещающей модели состоит из расслабленных обращений памяти,
высвобождающего и приобретающего барьеров памяти без сертификации.

%% \section{Мотивировка доказательства корректности компиляции}
%% \label{sec:armv83:motive}
Как было описано в разделе \ref{sec:armpop:motive}, доказательство корректности
компиляции из обещающей модели памяти является важной задачей. 
В главе \ref{sec:armpop} было рассмотрено доказательство для модели ARMv8 POP \cite{Flur-al:POPL16},
однако задача для архитектуры ARM не полностью закрыта --- 
в апреле 2017 года была предложена новая модель памяти ARMv8.3 \cite{ARMv82,Pulte-al:POPL18}.

Модель ARMv8.3 является аксиоматической,
что существенно отличает ее от ARMv8 POP \cite{Flur-al:POPL16}.
Как следствие, невозможно напрямую показать симуляцию между обещающей и ARMv8.3 моделями,
поскольку симуляция требует от связываемых моделей, чтобы они были операционными.
Чтобы преодолеть данное ограничение, мы разработали способ обхода графов модели ARMv8.3
(раздел \ref{sec:traversal}),
который представлен в виде операционной семантики.
Этот обход и используется при доказательстве симуляции между обещающей и ARMv8.3 моделями
(раздел \ref{sec:simulation}).
%% Данный метод может быть использован для доказательства корректности компиляции из
%% обещающей в аксиоматические модели памяти, и является более общим, чем использованные ранее методы
%% (см. раздел \ref{sec:related}), базирующиеся на особых свойствах целевых аксиоматических моделей.

%% Глава структурирована следующим образом.
%% В начале приводится высокоуровневое описание обещающей и ARMv8 POP моделей и мотивировка для доказательства
%% корректности компиляции между ними (раздел \ref{sec:armpop:motive}).
%% В разделе \ref{sec:armpop:examples} обе модели иллюстрируются на наборе примеров.
%% Далее приводится описание идеи доказательства корректности компиляции между ними (раздел \ref{sec:armpop:highlevel}).
%% В разделах \ref{sec:armpop:armmodel}  и \ref{sec:armpop:promisemodel} приводятся формальные описания моделей.
%% \app{TODO}

\section{Модель ARMv8.3}
\label{sec:armv83examples}
\label{sec:armv83formally}
Модель ARMv8.3 \cite{Pulte-al:POPL18} является аксиоматической моделью памяти, и следовательно
представляет семантику программы как множество графов, каждый
из которых соответствует некоторому конкретному запуску программы.

Также, как и в модели C/C++11 \cite{Batty-al:POPL11},
используются отношения программного порядка $\lPO$, ``читает из'' $\lRF$, порядока памяти
$\lMO$.
Кроме того, используется производное отношение ``читает ранее'' $\lFR$
(reads before): \[ \lFR \defeq \lRF^{-1}; \lCO, \]
которое связывает событие чтения $a$ с событием записи $b$,
которое $\lCO$-следует за записью, из которой читает $a$.
%
%% Здесь и далее композиция отношений с помощью `$;$' задается так:
Здесь и далее композиция отношений `$;$' задается так:
\[A; B \defeq \{\tup{a, b} \mid \exists c. \; \tup{a, c} \in A \land \tup{c, b} \in B \}.\]

\begin{figure}
\[
\begin{tikzpicture}[yscale=1.5,xscale=3]
  %% \node (01) at (-1,3) {$\wlab{}{x}{0}$ };
  %% \node (02) at (0,3) {$\wlab{}{y}{0}$ };
  \node (1)  at (-1,2) {$\wlab{}{x}{1}$ };
  \node (b1) at (-1,1) {$\flab{\SY}$ };
  \node (2)  at (-1,0) {$\wlab{}{y}{1}$ };
  \node (11) at (0,2)  {$\rlab{}{y}{1}$ };
  \node (b2) at (0,1)  {$\flab{\LD}$ };
  \node (12) at (0,0)  {$\rlab{}{x}{0}$ };
  \draw[po] (1)  edge  (b1);
  \draw[po] (b1)  edge  (2);
  \draw[po] (11) edge (b2);
  \draw[po] (b2) edge (12);
  %% \draw[po] (01) edge (11);
  %% \draw[po] (02) edge (11);
  %% \draw[po] (01) edge (1);
  %% \draw[po] (02) edge  (1);
  %% \draw[deps,bend left=20] (11)  edge node[right] {\small $\lDEPS$} (12);
  %% \draw[rf,bend left=70] (01)  edge node[above] {\small $\lRF$} (12);
  \draw[rf] (2)  edge node[below] {$\lRFE$} (11);
  %% \draw[mo,bend right=20] (01)  edge node[below] {\small $\lCO$} (1);
  %% \draw[mo,bend right=90] (02)  edge node[below] {\small $\lCO$} (2);
  \draw[fr] (12) edge node[above] {$\lFRE$} (1);
  \draw[deps,bend right=30] (1)  edge node[left] {$\lBOB^{+}$} (2);
  \draw[deps,bend left=30] (11) edge node[right] {$\lBOB^{+}$} (12);
\end{tikzpicture}
\]
\caption{Сценарий поведения программы \textrm{MP-SY-LD}, запрещённый в модели ARMv8.3}
\label{fig:arm83:mpsyld}
\end{figure}

Как и в случае модели ARMv8 POP, добавление в программу \textrm{MP} барьеров памяти
запрещает результат $a = 1$ и $b = 0$ (см. рис. \ref{fig:arm83:mpsyld}):
\begin{equation*}
\tag{MP-sy-ld}\label{ex:MP-sy-ld}
\begin{tabular}{L || L}
  \writeInst{x}{1}; & \readInst{a}{y}; ~\valuecom{1} \\
  \syFence;         & \ldFence; \\
  \writeInst{y}{1}; & \readInst{b}{x}; ~\valuefail{0} \\
\end{tabular}
\end{equation*}
В этом графе мы опустили инициализирующие записи и добавили отношение барьеров $\lBOB$ (barrier-ordered-before), заданное так:
\[
\lBOB \defeq \inarr{\lPO; [\lDMBSY] \cup [\lDMBSY]; \lPO  \cup [\lR]; \lPO; [\lDMBLD] \cup [\lDMBLD]; \lPO},
\]
где $[A] \defeq \{(a, a) \suchthat a \in A\}$.
Кроме того, мы заменили ребра отношений $\lRF$ и $\lFR$ ребрами отношений $\lRFE$ и $\lFRE$, где $\lmakeE{}$ (external) означает,
что соответствующее отношение связывает только события разных потоков.

В приведенном графе есть цикл из ребер $\lBOB$, $\lRFE$ и $\lFRE$, что противоречит одной из аксиом, которая используется
в модели ARMv8.3 для определения \ARM-согласованного исполнения.
Таким образом граф не является \ARM-согласованным,
и поведение $a = 1$ и $b = 0$ запрещено для программы \textrm{MP-SY-LD} в рамках модели.

%% \section{Формальное определение модели ARMv8.3}
%% В этом разделе модель ARMv8.3 описывается  формально, в соответствии с \cite{Pulte-al:POPL18}.

Мы не будем явным образом использовать язык \ARM-ассемблера
и будем считать, что он совпадает с исходным языком (см. рис. \ref{fig:syn-prog}) с точностью до
модификаторов барьера памяти:
\[\FtypeARM ::= \SY \mid \LD. \]
Также мы будем считать, что результатом компиляции любой программы $\Prog$ на исходном языке
является той же программой, в которой модификаторы $\rel$ заменены на $\SY$, а $\acq$ --- на $\LD$.

%% \label{subsec:arm-formally}
%% \url{https://github.com/herd/herdtools7/blob/master/herd/libdir/aarch64.cat}  \qquad (07-June-17)

%% \[\begin{array}{lccll}
%% \lL & = & STLR & \text{release(SC)} & \lW^\sco\\
%% \lA & = & LDAR & \text{acquire(SC)} & \lR^\sco\\
%% \lQ & = & ?    & \text{acquire(C11)} & \lR^\acq 
%% %% X & =      & atomic(RMW)
%% \end{array}\]

%% В нашей работе мы рассматриваем подмножество модели памяти ARMv8.3.

\begin{definition}
%% \begin{restatable}{mydefinition}{graphexdef}
\label{def:execution}
\emph{Исполнение} $G$ --- это граф, который состоит из следующих компонент.
\begin{enumerate}
\item Конечное множество \emph{событий} $\lE \suq \mathbb{N}$, которое включает
      выделенное множество начальных событий $\lE_0 = \{ a^x_0 \suchthat x \in \Loc \}$.
      Мы используем $a,b,\ldots$ как переменные для обозначения событий.

\item Функция $\lTID$, которая по событию из $\lE$  возвращает номер потока, породившего событие.
      При этом начальные события $a^x_0 \in \lE_0$ мы считаем относящимся к потоку с номером 0,
      $\lTID(a^x_0) = 0$.

\item Функция $\lLAB$, которая присваивает \emph{метку} каждому событию из $\lE$.
      Метки могут обозначать следующие операции:
\squishlist
\item \emph{чтение}, $\evlab{\lR}{o}{x}{v}$, где $x\in\Loc$ ---
  \emph{локация}, из которой событие читает \emph{значение} $v\in\Val$;
\item \emph{запись}, $\evlab{\lW}{o}{x}{v}$, где $x\in\Loc$ ---
  \emph{локация}, в которую событие записывает \emph{значение} $v\in\Val$;
\item \emph{барьер памяти}, $\flab{o}$, где $o\in \{\ld,\full\}$ --- \emph{тип барьера}, причем $\full$-барьеры строже, чем
  $\ld$, $\ld \sqsu \full$.
\squishend
Каждое начальное событие --- это инициализирующая запись в некоторую локацию:
\[\forall a^x_0 \in \lE_0. \; \lLAB(a^x_0) = \evlab{\lW}{\pln}{x}{0}.\]

Функция $\lLAB$ естественным образом определяет следующие частично определенные функции, которые
по событиям возвращают:
%% $\lTYP$, $\lMOD$, $\lLOC$, $\lVALR$ и $\lVALW$, такие что:
\begin{itemize}
  \item $\lTYP$ --- тип события ($\lR,\lW$ или $\lF$);
  \item $\lMOD$ --- тип барьера;
  \item $\lLOC$ --- целевую локацию;
  \item $\lVALR$ --- прочитанное значение;
  \item $\lVALW$ --- записанное значение.
\end{itemize}
Далее мы будем использовать $\lR, \lW$ и $\lF$ также и для обозначения соответствующих множеств
событий --- например, $\lR$ для обозначения $\{e\in \lE \suchthat \lTYP(e)=\lR\}$.
%% Далее $\lX$, элемент $\{\lR,\lW,\lF\}$, будет обозначать
%% множество $\{e\in \lE \suchthat \lTYP(e)=\lX\}$.
%% Мы пишем локацию в нижнем регистре для обозначения множества событий, оперирующих
%% над этой локацией и пишем обозначения множеств рядом, имея ввиду объединение множеств.
%% Например, $\lW_x = \{a \in \lW \mid \lLOC(a)=x\}$ и $\lR\lW= \lR\cup \lW$.

\item Строгий частичный порядок на событиях $\lPO \suq \lE \times \lE$, называемый \emph{программым порядком},
      который является объединением непересекающихся множеств $\{\lPO_i\}_{i\in \{0\} \cup \Tid}$,
      где $\lPO_0=\lE_0\times (\lE\setminus \lE_0)$ и для каждого потока 
      $i\in\Tid$ отношение $\lPO_i$ является полным порядоком на множестве событий этого потока
      $\{a\in \lE \suchthat \lTID(a)=i\}$.

\item Отношения $\lDATA,\lCTRL,\lADDR\suq \lPO\setminus \lPO_0$, которые удовлетворяют следующим ограничениям:
\vspace{-5pt}
\begin{multicols}{2}
\squishlist
\item $\lDATA \suq \lR \times \lW$;
\item $\lADDR\suq \lR \times (\lR \cup \lW)$;
\item $\lCTRL;\lPO \suq \lCTRL$. 
\squishend
\end{multicols}
Они представляют зависимости по данным, по потоку управления и по целевому адресу инструкции соответственно.

\item Отношение $\lRF \suq [\lW]; {=_\lLOC}; [\lR]$, которое удовлетворяет следующим ограничениям:
$(i)$ $\lVALW(a)=\lVALR(b)$ для любой пары $\tup{a,b}\in \lRF$;
$(ii)$ $a_1=a_2$, если $\tup{a_1,b},\tup{a_2,b}\in \lRF$. Мы также вводим функцию $\lRF^{-1}$, которая определена на
области отображения $\lRF$, $\codom{\lRF}$, и для любого $a$ из $\codom{\lRF}$ верно, что $\tup{\lRF^{-1}(a), a} \in \lRF$.
%% $\lRFI^{-1}$ и $\lRFE^{-1}$ are also partial functions such that for all $a \in \codom{\lRF}$,
%% $\{\lRFI^{-1}(a), \lRFE^{-1}(a)\} = \{\bot, \lRF^{-1}(a)\}$, $\lRFI^{-1}(a) \neq \bot$ if $\lTID(a) = \lTID(\lRF^{-1}(a))$,
%% and $\lRFE^{-1}(a) \neq \bot$ if $\lTID(a) \neq \lTID(\lRF^{-1}(a))$.

\item Строгий частичный порядок $\lCO$ на элементах $\lW$
      который является объединением отношений $\{\lCOx\}_{x\in\Loc}$,
      где $\lCOx$ --- полный порядок на элементах $\lW_x = \{ e \in \lW \suchthat \lLOC(e) = x\}$.
\end{enumerate}
%% \end{restatable}
\end{definition}

Мы также используем некоторые производные отношения. Так, $\lFR \defeq \lRF^{-1}; \lCO$ --- это отношение
связывает событие чтения с событием записи, которое $\lCO$-следует за прочитанным событием записи.
С помощью суффиксов $\mathtt{i}$ и $\mathtt{e}$ обозначаются подмножества отношений, которые связывают события одного
и разных потоков соответственно. Например, $\lCOI = \{ \tup{w, w'} \in \lCO \mid \lTID(w) = \lTID(w') \}$ и
$\lRFE = \{ \tup{w, r} \in \lRF \mid \lTID(w) \neq \lTID(r) \}$.

\begin{align*}
\lOBS &\defeq  \lRFE \cup \lFRE \cup \lCOE  \tag{\emph{observed-by}} \\
\lDOB &\defeq \inarr{(\lADDR \cup \lDATA); \lRFI^? \cup {} \\
	(\lCTRL \cup \lDATA); [\lW]; \lCOI^? \cup {} \\
	\lADDR; \lPO; [\lW]} \tag{\emph{dependency-ordered-before}} \\
\lBOB &\defeq \inarr{\lPO; [\lDMBSY] \cup [\lDMBSY]; \lPO  \cup {} \\
                    {} [\lR]; \lPO; [\lDMBLD] \cup [\lDMBLD]; \lPO} \tag{\emph{barrier-ordered-before}}
\end{align*}

\begin{definition}
%% \label{def:model}
Исполнение $G$ является \ARM-согласованным, если выполняется следующее:
\begin{itemize}
\item $\lR = \codom{\lRF}$; \labelAxiom{completeness}{ax:comp}
\item отношение $\lPO\rst{\lLOC} \cup \lFR \cup \lCO \cup \lRF$ не имеет циклов; \labelAxiom{internal}{ax:internal}
\item отношение $\lOBS \cup \lDOB \cup \lBOB$ не имеет циклов. \labelAxiom{external}{ax:external}
\end{itemize}
\end{definition}


\section{Структура доказательства корректности компиляции}
\label{sec:highlevel}
Центральным результатом данной работы является доказательство следующей теоремы.
%% \begin{restatable}{thm}{mainthm}
\begin{theorem}
  \label{prop:compile-theorem}
  Для любых программы \Prog, результата ее компиляции \ProgARM и \ARM-согласованного исполнения $G$ программы
  \ProgARM, существует исполнение \Prog обещающей машиной, т.ч. 
  финальное состояние памяти машины совпадает с состоянием памяти $G$.
\end{theorem}
%% \end{restatable}
\noindent
Здесь под ``финальным состоянием памяти'' мы понимаем значение последних записей в локации, т.е. записей с наибольшими
метками времени, в случае обещающей семантики, и событий-максимумов в отношении частичного порядка $G.\lCO$, в случае ARMv8.3.

Обещающая и ARMv8.3 модели памяти заданы в существенно разных стилях и имеют множество концептуальных отличий.
Для доказательства теоремы \ref{prop:compile-theorem} необходимо преодолеть данные различия.

Главным отличием является то, что обещающая модель памяти представлена операционно, в терминах
шагов некоторой абстрактной машины, тогда как аксиоматическая модель памяти ARMv8.3 задает семантику конкретного
исполнения программы в виде графа, для которого выполняются определенные свойства. 
Для решения данной проблемы мы вводим операционную семантику обхода графа \ARM-согласованного исполнения,
которому обещающая машина может следовать (раздел \ref{sec:traversal}).

Другим существенным отличием является то, как модели запрещают ``плохие'' поведения программ, например,
такие как чтение потоком старой записи в $x$, если поток уже читал из более новой записи в $x$.
Для этого модель памяти ARMv8.3 использует аксиомы, которые проверяют отсутствие циклов в графе, тогда
как в обещающей модели для этого используются фронты потоков и сообщений.
Для того, чтобы обойти описанное различие между моделями,
мы вводим дополнительные отношения на вершинах \ARM-согласованного исполнения,
которые тесно связаны с фронтами обещающей модели (раздел \ref{sec:view}).

Используя описанные выше идеи, мы доказываем корректность компиляции между обещающей и ARMv8.3 моделями
с помощью симуляции (раздел \ref{sec:simulation}).

%% Как читатель мог убедиться после прочтения разделов \ref{sec:promise} и \ref{sec:arm}, обещающая и ARMv8.3 модели памяти
%% очень сильно отличаются по стилю представления. Для того, чтобы приодолеть это 

%семантики программы.

%% В данной работе мы исходим из двух предположений.
%% Во-первых, любая программа представляет собой вернеуровневую композицию потоков
%% и новые потоки не могут создаваться динамически. Такое ограничение принято в обоих моделях.
%% Во-вторых, мы считаем, что целевая программа и результат компиляции отличаются только инструкциями
%% обращения к памяти и, с точностью до семантики обращений к памяти, поведение программ в обоих моделях
%% совпадает. Это означает, что для любой программы \Prog, результата ее компиляции \ProgARM,
%% \ARM-согласованного исполнения $G$ программы \ProgARM и потока $tid$, существует цепочка в помеченной
%% системе переходов обещающей модели памяти, которая соответствуют множеству событий $\{e \in G \st \lTID(e) = tid\}$.
%% Последнее позволяет нам сформулировать основную теорему без упоминания конкретных программ.

\section{Обход \ARM-согласованных исполнений}
\label{sec:traversal}

В разделе \ref{sec:highlevel} мы обсудили, что наше доказательство корректности компиляции представляет
собой симуляцию обещающей машиной некоторого обхода \ARM-согласованных исполнений. В этом разделе
мы введем данный обход. Для этого мы сначала опеределим несколько вспомогательных понятий,
потом формально введем шаг обхода с требуемыми ограничениями, а потом докажем существование
последовательности шагов, которые полностью обходят любое \ARM-согласованное исполнение.

\begin{definition}
%% \begin{restatable}{mydefinition}{confdef}
\emph{Конфигурацией обхода} для \ARM-согласованного исполнения $G$ называется пара множеств $\tup{C, \IssuedSet}$, таких что:
\begin{itemize}
  \item $C \suq G.\lE$;
  \item $\dom{G.\lPO;[C]}\suq C$;
  \item $C \cap G.\lW \suq \IssuedSet \suq G.\lW$.
\end{itemize}
Элементы $C$ мы будем называть \emph{покрытыми} (covered), а $\IssuedSet$ --- \emph{выпущенными} (issued).
\end{definition}
%% \end{restatable}
Интуитивно, в рамках симуляции покрытые события будут соответствовать префиксу программы,
который исполнен обещающей семантикой, тогда как выпущенные --- записями, находящимся в памяти обещающей машины
в соответствующий момент исполнения.
%% \begin{restatable}{mydefinition}{nextsetdef}
\begin{definition}
  \emph{Множеством следующих событий} $\nextset(G, C)$ для исполнения $G$ и его покрытия $C \suq G.\lE$
  называется множество, состоящие из событий, все $\lPO$-предшествующие события которых уже покрыты:
  \[\nextset(G, C) \defeq \{b \in G.\lE \mid \dom{G.\lPO;[b]} \suq C\} \setminus C.\]
\end{definition}
%% \end{restatable}
В рамках симуляции данное множество будет содержать по одному событию для каждого еще не завершенного потока
в обещающей семантике, причем события будут соответствовать следующему переходу в потоке, который не является обещанием.
Так, если бы обещающая семантика была определена поверх некоторого синтаксиса, то множество
следующих событий соответствовало инструкциям, на которые указывают счетчики команд (program counter) потоков
в обещающей модели.

\begin{definition}
%% \begin{restatable}{mydefinition}{coverdef}
Событие $a$ является \emph{покрываемым} для исполнения $G$ в конфигурации обхода $\tup{C, \IssuedSet}$,
$a\in \coverable(G, C, \IssuedSet)$, если $a$ является:
  \begin{itemize}
    \item событием чтения и связанное событие записи является выпущенным ($a \in G.\lR$ и $\lRF^{-1}(a) \in \IssuedSet$),
    \item выпущенным событием ($a \in \IssuedSet$) или
    \item барьером памяти ($a \in G.\lF$).
  \end{itemize}
\end{definition}
%% \end{restatable}
В нашем обходе, заданному как операционная семантика, есть шаг, которое ``покрывает'' событие, т.е. добавляет
его во множество покрытых. Событие, покрываемое данным правилом, должно соответствовать приведенным выше ограничениям.
Они соответствуют ограничениям обещающей семантики. Например, обещающая семантика может исполнить
инструкцию чтения и прочитать из некоторого конкретного сообщения только в том случае, если данное сообщение есть в памяти,
т.е. соответствующее ему событие $w$ уже выпущено: $w \in \IssuedSet$.

\begin{definition}
%% \begin{restatable}{mydefinition}{issuedef}
Событие $w$ называется \emph{выпускаемым} для исполнения $G$ в конфигурации обхода $\tup{C, \IssuedSet}$,
$w\in\issuable(G, C, \IssuedSet)$, если выполняется следующее:
      \begin{itemize}
        \item $w$ является событием записи ($w\in G.\lW$);
        \item все $\lPO$-предшествующие барьеры покрыты
          ($\dom{[\lF];G.\lPO;[w]} \suq C$);
          \labelAxiom{write-bob}{req:write-bob}
        \item все записи других потоков, от которых зависит $w$, выпущены
          ($\dom{G.\lRFE;G.\lDOB^{+};[w]} \suq \IssuedSet$).
          \labelAxiom{write-dob}{req:write-dob}
        %% \item все $\lPO$-предшествующие записи в ту же локацию выпущены
        %%   ($\dom{G.\lCOI;[w]} \suq \IssuedSet$)
        %%   \labelAxiom{write-coi}{req:write-coi}
      \end{itemize}
\end{definition}
%% \end{restatable}
Шаг обхода, который ``выпускает'' событие записи, соответствует в симуляции обещанию, которое делает обещающая семантика.
Ограничение \ref{req:write-bob} является более строгим, чем ограничение из обещающей семантики ---
обещание может быть сделано ``через'' приобретающей барьер, который соответствует $\fenceInst{\LD}$ в ARMv8.3,
однако более строгое ограничение позволяет упростить симуляцию.
Ограничение \ref{req:write-dob} нужно для того, чтобы обещающая семантика могла сертифицировать обещание, которое она
делает.

Шаги обхода задаются следующим образом:
\begin{mathpar}
\inferrule*{
    a \in \nextset(G, C) \cap \coverable(G, C, \IssuedSet) 
}{
    G \vdash 
    \tup{C, \IssuedSet} \travConfigStep \tup{C \cup \{a\}, \IssuedSet}
} \and
\inferrule*{
    w \in \issuable(G, C, \IssuedSet) \setminus \IssuedSet 
    }{
    G \vdash
    \tup{C, \IssuedSet} \travConfigStep \tup{C, \IssuedSet \cup \{w\}}
}
\end{mathpar}
Здесь левое правило покрывает событие, если событие принадлежит множеству
следующих событий и при этом покрываемо в данной конфигурации.
Правое правило выпускает событие записи, если событие выпускаемо и при этом еще не выпущено.
%% Из определения конфигурации обхода очевидно, что правила обхода связывают конфиг

Поскольку каждое конкретное \ARM-согласованное исполнение является некоторым конечным графом,
а вышеприведенные шаги обхода наращивают конфигурации, то для доказательства наличия полного
обхода графа достаточно показать, что для каждой не конечной конфигурации существует шаг к новой конфигурации.
\begin{theorem}
%% \begin{restatable}{thm}{travthm}
  \label{prop:trav-step}
  Пусть $\tup{C, \IssuedSet}$ является конфигурацией \ARM-согласованного исполнения $G$,
  при этом конфигурация достижима из начальной
  ($G \vdash \tup{\emptyset, \emptyset} \travConfigStep^{*} \tup{C, \IssuedSet}$) и $C \neq G.\lE$.
  Тогда существуют $C'$ и $\IssuedSet'$, т.ч. 
  $G \vdash \tup{C, \IssuedSet} \travConfigStep \tup{C', \IssuedSet'}$.
\end{theorem}
%% \end{restatable}
Доказательство теоремы основано на следующих вспомогательных леммах:
\begin{lemma}
%% \begin{restatable}{lem}{travproplem}
  \label{prop:trav-prop-preserve}
  Пусть $G \vdash \tup{\emptyset, \emptyset} \travConfigStep^{*} \tup{C, \IssuedSet}$.
  %If $G$ is  $\ARM$-consistent, 
  Тогда $C \suq \coverable(G,C,\IssuedSet)$ и $\IssuedSet \suq \issuable(G,C,\IssuedSet)$.
\end{lemma}
%% \end{restatable}
\begin{proof}
  Следует из определений $\coverable$ и $\issuable$ и того, что множества покрытых и выпущенных событий растут в течение обхода $G$.
\end{proof}

\begin{proposition}
%% \begin{restatable}{lem}{nextwritelem}
  \label{prop:next-write}
  Пусть $G \vdash \tup{\emptyset, \emptyset} \travConfigStep^{*} \tup{C, \IssuedSet}$.
  %If $G$ is  $\ARM$-consistent, 
  Тогда $\lW \cap \nextset(G, C) \suq \issuable(G,C,\IssuedSet)$.
\end{proposition}
%% \end{restatable}
\begin{proof}
  Зафиксируем $w \in \lW \cap \nextset(G, C)$ и покажем, что $w \in \issuable(G, C, \IssuedSet)$.
  Т.к. $w \in \nextset(G, C)$, то все $\lPO$-предшествующие события являются покрытыми (т.е.
  находятся в $C$), из чего напрямую следует, что выполняется \ref{req:write-bob}. Кроме того, из леммы
  \ref{prop:trav-prop-preserve} следует, что все покрытые события являются покрываемыми, из чего следует
  \ref{req:write-dob}.
\end{proof}

\begin{proof}[Доказательство теоремы \ref{prop:trav-step}]
  Нам известно, что $\nextset(G, C) \neq \emptyset$, т.к. $C \neq G.\lE$.
  В доказательстве мы рассматриваем два варианта. Первым мы рассматриваем вариант, когда существует
  элемент $\nextset(G, C)$, который покрываем, или сначала выпускаем, а потом покрываем. 
  Вторым мы рассматриваем вариант, когда все элементы в $\nextset(G, C)$ не покрываемы и не выпускаемы.
  Для этой ситуации мы показываем, что в $G$ существует событие записи, которое выпускаемо в данной конфигурации.

  {\bf Первый вариант}.
  Зафиксируем элемент $a \in \nextset(G, C)$.
  Если $a \in \lR$ и $\lRF^{-1}(a) \in \IssuedSet$, или $a \in \lF$, или $a \in \lW \cap \IssuedSet$,
  тогда $a$ покрываем по определению.
  Если $a \in \lW \setminus \IssuedSet$, тогда $a$ --- выпускаемо по лемме \ref{prop:next-write}.

  {\bf Второй вариант}.
  В этом случае мы предполагаем, что нет события из $\nextset(G, C)$, которое покрываемо или выпускаемо.
  Таким образом $\nextset(G, C) \suq \lR$ является следствием леммы \ref{prop:next-write} и опеределения покрываемого события.
  Кроме того, для любого чтения события $r$ из $\nextset(G, C)$ мы знаем, что $\lRF^{-1}(r) \nin \IssuedSet$.
  Далее мы покажем, что существует событие записи, которое выпускаемо в данной конфигурации.
  Для этого введем вспомогательное отношение $\lEORD \defeq (\lOBS \cup \lDOB \cup \lBOB)^{+}$,
  которое антирефлексивно по определению \ARM-согласованности (\ref{ax:external}).
  
  Мы знаем, что есть как минимум одно событие (чтения) из $\nextset(G, C)$, которое при этом не покрываемо.
  Это означает, что существует событие записи, которое еще не выпущено.
  Выберем событие записи $w \in \lW \setminus \IssuedSet$, которое является минимальным по отношению $\lEORD$ среди записей,
  которые еще не выпущены, т.е. $\nexists w' \in \lW \setminus \IssuedSet. \; \lEORD(w', w)$.
  Осталось показать, что событие $w$ выпускаемо.
  
  Т.к. $w \nin \nextset(G, C)$, то существует событие чтения $r \in \nextset(G, C)$, т.ч. $\lPO(r, w)$
  и $\lRF^{-1}(r) \nin \IssuedSet$. При этом $\lRF^{-1}(r) = \lRFE^{-1}(r)$, т.к.
  $C \cap \lW \suq \IssuedSet$ и $\forall e \in C. \; \dom{\lPO; [e]} \in C$.

  Для доказательства того, что $w$ выпускаемо, нужно показать, что два утверждения выполняются.
  \begin{itemize}
    \item[\ref{req:write-bob}:] Пусть $f \in \lF$, т.ч. $\lPO(f, w)$.
      Предположим, что $f \nin C$. Тогда $\lPO(r, f)$ и $\tup{\lRFE^{-1}{(r)}, w} \in \lOBS; \lBOB^{+} \suq \lEORD$.
      Т.к. $\lRFE^{-1}(r) \nin \IssuedSet$, то существует $\lEORD$-предшествующее $w$ событие записи, которое не выпущено.
      Это противоречит выбору $w$.
    \item[\ref{req:write-dob}:] Пусть существует событие чтения $r'$, т.ч. $\lDOB^{+}(r', w)$.
      Если $\lRFE^{-1}(r') \neq \bot$, то
      $\tup{\lRFE^{-1}(r'), w} \in \lRFE; \lDOB^{+} \suq \lOBS; \lDOB^{+} \suq \lEORD$. По опеределению $w$ это означает,
      что $\lRFE^{-1}(r') \in \IssuedSet$.
    %% \item[\ref{req:write-coi}:]
      %% Let $w'$ such that $\lCOI(w', w)$. If $w' \nin \IssuedSet$, it contradicts $\lEORD$-minimality of $w$.
\qedhere
\end{itemize}  
\end{proof}

\section{Симуляция обхода обещающей машиной}
\label{sec:simulation}

В этом разделе мы приводим доказательство основной теоремы \ref{prop:compile-theorem}.
\app{TODO: добавить формулировку основной теоремы}
%% \mainthm*
\begin{proof}
  Зафиксируем \ARM-согласованное исполнение $G$. Далее мы покажем, что обещающая семантика может симулировать
  обход исполнения $G$. Для этого, как это обычно делается в доказательствах с помощью симуляции, мы введем
  отношение симуляции $\simrel$, которое будет связывать конфигурацию обхода $G$ с состоянием обещающей машины.
  Формально утверждение выглядит следующим образом.
\begin{lemma}
%% \begin{restatable}{lem}{lemsimulation}
  \label{lem:simulation}
  Существуют такие $\TSf$ и $M$, что $\simRel(G.\lE, G.\lW, \TSf, M)$ и
  $\tup{\TSf_{\rm init}, M_{\rm init}} \stepp^{*} \tup{\TSf, M}$.
%% \end{restatable}
\end{lemma}
%% \begin{proof}
%%   We define $T$ to be correct by construction.
%%   We show $(\tup{\emptyset, \emptyset}, \TSf_{\rm init}, M_{\rm init}) \in \simRel$ \app{TODO}.
%%   We choose a traversal $G, \lSC \vdash \tup{\emptyset, \emptyset} \travConfigStep^{*} \tup{G.\lE, G.\lW}$, which
%%   exists via \cref{prop:trav-step}. For each step of the traversal we apply \cref{prop:sim-step}.
%% \end{proof}
  При этом мы определим отношение симуляции $\simrel$ так, чтобы из него было очевидно, что финальное состояние памяти
  $M$ совпадает с состоянием памяти исполнения $G$, а также, что $\simRel(\emptyset, \emptyset, \TSf_{\rm init}, M_{\rm init})$
  выполняется. Тогда доказательство теоремы будет непосредственно следовать из доказательства леммы \ref{lem:simulation}.
  Сама же лемма доказывается индукцией с использованием леммы \ref{lem:sim-step}, которая показывает,
  что для любой не полной конфигурации обхода существует шаг, который обещающая машина может симулировать. 
\begin{lemma}
%% \begin{restatable}{lem}{lemsimstep}
  \label{lem:sim-step}
  Пусть для некоторых конфигураций обхода $\tup{C, \IssuedSet}$ и $\tup{C', \IssuedSet'}$ исполнения $G$,
  а также некоторого состояния обещающей машины $\tup{\TSf, M}$ выполняется
  $G \vdash \tup{C, \IssuedSet} \travConfigStep \tup{C', \IssuedSet'}$ и
  $\simRel(C, \IssuedSet, \TSf, M)$.
  Тогда существуют $\TSf'$, $M'$, т.ч. $\tup{\TSf, M} \stepp\!\!^{+} \tup{\TSf', M'}$ и
  $\simRel(C', \IssuedSet', \TSf', M')$.
%% \end{restatable}
\end{lemma}
  Доказательство леммы \ref{lem:sim-step} приведено в приложении \ref{sec:appendix}.
\end{proof}
  
  Далее в этом разделе мы опишем вспомогательные отношения на графах исполнения, которые будут нужны для выражения
  связи с фронтами обещащей модели в отношении симуляции, и само отношение симуляции.
  Как и в доказательстве теоремы \ref{prop:compile-theorem}, мы зафиксируем \ARM-согласованное исполнение $G$ и будем вводить
  все определения в контексте $G$.
  
\subsection{Аналоги фронтов для \ARM-согласованных исполнений}
\label{sec:view}
  %% Этот раздел посвящен данным вопросам.

  Введем вспомогательную функцию $T: \TimestampMap = \lW \rightarrow \mathbb{N}$,
  сопоставляющую событиям записи в $G$ их порядковые номера в отношении $\lCO$ так, чтобы $\correctTmap(G, T)$ выполнялось:
  \[\inarr{
    \correctTmap(G, T) \defeq \forall w, w'. \; \\
    %%, r \in \lE
    \quad (\tup{w, w'} \in \lCO \implies T(w) < T(w')) \land {} \\
    \quad (w \nin \codom{\lCO} \implies T(w) = 0).
    %% \land {} \\ \quad (\tup{w,r} \in \lRF \implies T(w) = T(r)). \\
    %% a compilation function $\compileF : \lE \rightarrow \TransSet$ s.t. $\compileReq(\compileF)$ holds.
  }\]
  Эта функция фактически вводит метки времени на событиях записи $G$.
  
  Далее введем вспомогательные отношения $\lSW$ (synchronized-with) и $\lHB$ (happens-before):
  \[\begin{array}{@{}r@{~}r@{~}l}
  \lSW & \defeq & [\lDMBSY]; \lPO; \lRF; \lPO; [\lDMBLD] \\
  \lHB & \defeq & (\lSW \cup \lPO)^{+}. \\
  \end{array}\]
  Здесь отношение $\lSW$ представляет пути в графе, соответствующие передачи информации о событиях
  записи с помощью \ARM-аналогов высвобождающего ($\lDMBSY$) и приобретающего ($\lDMBLD$) барьеров
  памяти. Отношение $\lHB$ мы далее используем, чтобы определить
  отношения $\curRel$, $\acqRel$ и $\relRel$. Они в паре с функцией $T$ будут использованы в симуляции
  как ограничения для базового, приобретающего и высвобождающего фронтов потока в обещающей модели памяти.
  \[\begin{array}{@{}r@{~}r@{~}l}
  \curRel & \defeq & \lRF^{?}; \lHB \\
  \acqRel & \defeq & \lRF^{?}; \lHB; ([\lDMBSY]; \lPO; \lRF; \lPO)^? \\
  \relRel & \defeq & \lRF^{?}; \lHB; [\lDMBSY]; \lPO \\
  \end{array}\]
  Аналогичным образом отношение $\msgRel \suq \lW \times \lW$ представляет ограничение на фронт сообщения
  из обещающей модели. Так, если $\tup{w, w'} \in \msgRel$ и события $w$ и $w'$ соответствуют
  сообщениям $m$ и $m'$ в памяти обещающей семантики, то $m.\tau = T(w)$, $m'.\tau = T(w')$ и
  $m'.\view(\lLOC(w)) \ge m.\tau$.
  \[\begin{array}{@{}r@{~}r@{~}l}
  \msgRel & \defeq & \lRF^{?}; \lHB; [\lDMBSY]; \lPO \cup [\lW] \\
  \end{array}\]
  
  \subsection{Отношение симуляции $\simrel$}
  Отношение симуляции мы определяем следующим образом:
  \[\inarr{
    \simRel(C, \IssuedSet, \TSf, M) \defeq \invMemOne(C, \IssuedSet, \TSf, M) \land  \invMemTwo(C, \IssuedSet, M) \land {} \\
    \quad \invView(C, \TSf) \land \invViewRel(\TSf) \land \invState(C, \TSf).
  }\]

  $\invMemOne(C, \IssuedSet, \TSf, M)$ утверждает, что все выпущенные
  события $\IssuedSet$ имеют аналоги в памяти обещающей машины, причем выполненые обещания соответствуют покрытым
  событиям записи:
  \[\inarr{
  \invMemOne(C, \IssuedSet, \TSf, M) \defeq \forall w \in \IssuedSet. \; \exists \view \le \domView(\msgRel; [w]). \; \\
  \quad \letdef{msg}{\msg{\lLOC(w)}{\lVALW(w)}{T(w)}{\view}} \\
  \quad \letdef{\PromSet}{\TSf(\lTID(w)).\PromSet} \\
  \quad (w \in  C \implies msg \in M \setminus \PromSet) \land (w \nin C \implies msg \in \PromSet). \\
  }\]
  Здесь $\domView$ является вспомогательной функцией, которая по множеству записей строит соответствующий множеству фронт:
  \[\begin{array}{@{}l@{~}l}
    \setView(S) & \defeq \lambda \loc. \; \max \{ T(w) \mid w \in S, \lLOC(w) = \loc\}. \\
    \domView(R) & \defeq \setView(\dom{R}). \\
  \end{array}\]
  
  $\invMemTwo(C, \IssuedSet, M)$ обозначает обратную связь: для каждого сообщения из $M$ существует
  соответствующее ему выпущенное событие в $\IssuedSet$:
  \[\inarr{
  \invMemTwo(C, \IssuedSet, M) \defeq \forall \msg{\loc}{\val}{\tau}{\view} \in M. \; \tau \neq 0 \Rightarrow
    \exists w \in \IssuedSet. \; \\
  \quad \loc = \lLOC(w) \land \val = \lVALW(w) \land \tau = T(w) \land \view \le \domView(\msgRel; [w]). \\
  }\]

  $\invView(C, \TSf)$ утверждает, что для любого элемента множества следующих событий ($\nextset(G, C)$)
  фронты, представляющие связанные с ним отношениями $\curRel$, $\acqRel$ и $\relRel$ события записи, больше, чем
  базовый, приобретающий и высвобождающие фронты соответствующего потока:
  \[\inarr{
  \invView(C, \TSf) \defeq
  \forall e \in \nextset(G, C). \\
  \quad \letdef{\tup{\viewCur, \viewAcq, \viewfRel}}{\TSf(\lTID(e)).\View} \\
  \quad
  \begin{array}{@{}r@{~}l@{~}l}
    \viewCur & \le \domView(\curRel; [e]) & \land {} \\
    \viewAcq & \le \domView(\acqRel; [e]) & \land {} \\
    \viewfRel & \le \domView(\relRel; [e]). \\
  \end{array}
  }\]

  $\invViewRel(\TSf)$ показывает, что все еще не выполненные обещания имеют специальную форму
  их фронтов --- значение высвобождающего фронта соответствующего потока плюс метка времени самого обещания:
  \[\inarr{
  \invViewRel(\TSf) \defeq \forall tid, \msg{\loc}{\_}{\tau}{view} \in \TSf(tid).\PromSet. \\
    \quad view = [\loc @ \tau] \sqcup \TSf(tid).\View.\viewfRel. \\
  }\]

  %% \app{TODO: добавить объяснение}
  $\invState(C, \TSf)$ утверждает, что для каждого потока $tid$ существует список переходов $\{t_i\}_{i \in [1..k]}$,
  который соответствует событиям в $tid$-подграфе исполнения $G$, и текущее состояние потока $\TSf(tid).\sigma$
  получено с помощью $p$ переходов из списка, где $p$ --- количество покрытых событий, $|\lEID \cap C|$.
  \[\inarr{
  \invState(C, \TSf) \defeq \forall tid, k = |\lEID|. \;
     \exists \{\pstate_i\}_{i \in [0 .. k]}, \{t_i\}_{i \in [1..k]}. \; \\
  \quad \letdef{p}{|\lEID \cap C|} \\
  \quad \TSf(tid).\pstate = \pstate_{p} \land 
    (\forall j \in [0..k-1]. \; \pstate_j \astep{\epsilon}\!\!^{*}\astep{t_j} \pstate_{j + 1})\land {} \\
  \quad \forall n \in [1..k], a \in \nthf \; ([\lEID]; \lPO; [\lEID]) \; (n - 1). \;
    t_{n + 1} \approx \lLAB(a).
  %% \quad \ltsReq(tid, \compileF, \{\pstate_i\}_{i \in [0 .. k]}, \{t_i\}_{i \in [1..k]}). \\
  }\]
  Здесь функция $\nthf \; porder \; n$ возвращает
  элементы с номером $n$ из из отношения частичного порядка $porder$, 
  a предикат $t \approx \lLAB(a)$ выполняется тогда и только тогда, когда метка перехода $t$
  соответствует метки события $a$.
  Формальные определения  $\nthf$ и $\approx$ приведены в приложении \ref{sec:appendixProg}.

  %% отношение, в частности, утверждает связь между выпущенными событиями записи
  %% (компонентой $\IssuedSet$ в конфигурации обхода $G$)
  %% и состоянием памяти обещающей машины.

  %% Отношение $\invMemOne(C, \IssuedSet, \TSf, M)$ утверждает, что для каждого выпущенного события существует соответствующая
  %% ему запись во памяти обещающей машины (с теми же локацией, значением и меткой времени).

\section{Выводы}
\app{TODO}
