%% \begin{figure*}[t]
\chapter{Каталог тестов для модели C/C++11}
\label{sec:litmusTests}

\newcommand{\UndefinedBeh}{\kw{undefined behavior}}

\newcommand{\litmusTestStart}[5]{
\begin{samepage}
{\bf \textrm{#1}}
\begin{center}
#5
\end{center}
%% \begin{minipage}[t]{0.2\linewidth}
%% Fully Supported: #2 \\
%% Requires: #3\\
%% \end{minipage}
%% \begin{minipage}[t]{0.3\linewidth}

#4
%% \end{minipage}
\end{samepage}
}

\newcommand{\codePrefix}{
%% \begin{minipage}[t]{0.3\linewidth}
%% \vspace{-.2cm}
%% \begin{equation*}
\begin{tabular}{c}
}

\newcommand{\codePostfix}{
\end{tabular}
%% \end{equation*}
%% \end{minipage}
}

\newcommand{\sbTemplate}[6]{
  \codePrefix
  $\writeInstParam{#1}{x}{0}; \writeInstParam{#2}{y}{0};$ \\
\begin{tabular}{L || L}
  \writeInstParam{#3}{x}{1}; & \writeInstParam{#5}{y}{1}; \\
  \readInstParam{#4}{a}{y} & \readInstParam{#6}{b}{x} \\
\end{tabular}
  \codePostfix
}

\newcommand{\lbTemplate}[6]{
  \codePrefix
  $\writeInstParam{#1}{x}{0}; \writeInstParam{#2}{y}{0};$ \\
\begin{tabular}{L || L}
  \readInstParam{#3}{a}{y} & \readInstParam{#5}{b}{x} \\
  \writeInstParam{#4}{x}{1}; & \writeInstParam{#6}{y}{1}; \\
\end{tabular}
  \codePostfix
}

\newcommand{\mpTemplate}[6]{
  \codePrefix
  $\writeInstParam{#1}{f}{0}; \writeInstParam{#2}{d}{0};$ \\
\begin{tabular}{L || L}
  \writeInstParam{#3}{d}{5}; & \repeatReadInst{#5}{f}; \\
  \writeInstParam{#4}{f}{1}  & \readInstParam{#6}{a}{d} \\
\end{tabular}
  \codePostfix
}

\newcommand{\lbJoinTemplate}[4]{
  \codePrefix
  $\writeInstParam{\rlx}{x}{0}; \writeInstParam{\rlx}{y}{0};$ \\
\begin{tabular}{L || L || L || L}
  \readInstParam{#1}{a}{y}; & \skipc & \readInstParam{#3}{b}{x}; & \skipc \\
  \writeInstParam{\rlx}{z1}{a} & & \writeInstParam{\rlx}{z2}{b} &  \\
  \multicolumn{2}{c ||}{$\writeInstParam{#2}{x}{1}$} &
  \multicolumn{2}{c}{$\writeInstParam{#4}{y}{1}$} \\
\end{tabular}
  \codePostfix
}

\newcommand{\iriwTemplate}[8]{
  \codePrefix
  $\writeInstParam{#1}{x}{0}; \writeInstParam{#2}{y}{0};$ \\
\begin{tabular}{L || L || L || L}
  \writeInstParam{#3}{x}{1} &
  \writeInstParam{#4}{y}{1} &
  \readInstParam{#5}{a}{x}; &
  \readInstParam{#7}{c}{y}; \\
  & &
  \readInstParam{#6}{b}{y} &
  \readInstParam{#8}{d}{x} \\
\end{tabular}
  \codePostfix
}

\newcommand{\wrTemplate}[8]{
\codePrefix
  $\writeInstParam{#1}{x}{0}; \writeInstParam{#2}{y}{0};$ \\
  \begin{tabular}{L || L}
    \writeInstParam{#3}{x}{1}; &
    \writeInstParam{#5}{y}{1}; \\

    \writeInstParam{#4}{y}{2} &
    \writeInstParam{#6}{x}{2} \\
  \end{tabular} \\
  $\readInstParam{#7}{a}{x};
   \readInstParam{#8}{b}{y}$
\codePostfix
}

\newcommand{\possibleOutcomes}{Результаты в C/C++11 MM:}
\newcommand{\midTests}{
  \vspace{.2cm} \hrule \vspace{.2cm}
}

\section{Буферизация записи, SB}
\label{app:sb}

\litmusTestStart{SB-rel-acq}{\tick}{History + Viewfronts}{
\possibleOutcomes
\[[a = 0, b = 0], [a = 0, b = 1], [a = 1, b = 0], [a = 1, b = 1].\] %% \[\begin{array}{l}
%% a = 0 \land b = 0\\
%% a = 0 \land b = 1\\
%% a = 1 \land b = 0\\
%% a = 1 \land b = 1\\
%% \end{array}\]
}{%
\sbTemplate{\rel}{\rel}{\rel}{\acq}{\rel}{\acq}
}

\midTests

\litmusTestStart{SB-sc}{\tick}{SC + History + Viewfronts}{
\possibleOutcomes
\[[a = 0, b = 1], [a = 1, b = 0], [a = 1, b = 1].\]
}{%
\sbTemplate{\sco}{\sco}{\sco}{\sco}{\sco}{\sco}
}

\midTests

\litmusTestStart{SB-sc-rel}{\tick}{SC + History + Viewfronts}{
\possibleOutcomes
\[[a = 0, b = 0], [a = 0, b = 1], [a = 1, b = 0], [a = 1, b = 1].\]
}{%
\sbTemplate{\sco}{\sco}{\rel}{\sco}{\sco}{\sco}
}

\midTests

\litmusTestStart{SB-sc-acq}{\tick}{SC + History + Viewfronts}{
\possibleOutcomes
\[[a = 0, b = 0], [a = 0, b = 1], [a = 1, b = 0], [a = 1, b = 1].\]
}{%
\sbTemplate{\sco}{\sco}{\sco}{\acq}{\sco}{\sco}
}

%\newpage

\section{Буферизация чтения, LB}
\label{app:lb}

\litmusTestStart{LB-rlx}{\tick}{Postponed Reads + History + Viewfronts}{
\possibleOutcomes
\[[a = 0, b = 0], [a = 0, b = 1], [a = 1, b = 0], [a = 1, b = 1].\]
}{%
\lbTemplate{\rlx}{\rlx}{\rlx}{\rlx}{\rlx}{\rlx}
}

\midTests

\litmusTestStart{LB-rel-rlx}{\tick}{Postponed Reads + History + Viewfronts}{
\possibleOutcomes
\[[a = 0, b = 0], [a = 0, b = 1], [a = 1, b = 0], [a = 1, b = 1].\]
}{%
\lbTemplate{\rlx}{\rlx}{\rlx}{\rel}{\rlx}{\rel}
}

\midTests

\litmusTestStart{LB-acq-rlx}{\fail}{Postponed Reads + History + Viewfronts}{
\possibleOutcomes
\[[a = 0, b = 0], [a = 0, b = 1], [a = 1, b = 0], [a = 1, b = 1].\]
}{%
\lbTemplate{\rlx}{\rlx}{\acq}{\rlx}{\acq}{\rlx}

%% Our semantics doesn't allow the $a = 1 \land b = 1$ outcome for the program.
%% It doesn't allow reordering of an acquire read with a subsequent write.
%% The known sound compilation schemes of acquire read to major platforms (x86, ARM, Power) don't
%% allow the behavior either. 
}

\midTests

\litmusTestStart{LB-rel-acq-rlx}{\tick}{Postponed Reads + History + Viewfronts}{
\possibleOutcomes
\[[a = 0, b = 0], [a = 0, b = 1], [a = 1, b = 0].\]
}{%
\lbTemplate{\rlx}{\rlx}{\acq}{\rlx}{\rlx}{\rel}
}

\midTests

\litmusTestStart{LB-rlx-use}{\tick}{Postponed Reads + History + Viewfronts}{
\possibleOutcomes
\[[a = 0, b = 0], [a = 0, b = 1], [a = 1, b = 0], [a = 1, b = 1].\]
}{%
\codePrefix
  $\writeInstParam{\rlx}{x}{0}; \writeInstParam{\rlx}{y}{0};$ \\
\begin{tabular}{L || L}
  \readInstParam{\rlx}{a}{y} & \readInstParam{\rlx}{b}{x} \\
  \writeInstParam{\rlx}{z1}{a}; & \writeInstParam{\rlx}{z2}{b}; \\
  \writeInstParam{\rlx}{x}{1}; & \writeInstParam{\rlx}{y}{1}; \\
\end{tabular}
\codePostfix
}

\midTests

\litmusTestStart{LB-rlx-let}{\tick}{Postponed Reads + History + Viewfronts}{
\possibleOutcomes
\[[a = 0, a' = 1, b = 0, b' = 1], [a = 0, a' = 1, b = 1, b' = 2],\]%
\[[a = 1, a' = 2, b = 0, b' = 1], [a = 1, a' = 2, b = 1, b' = 2].\]
}{%
%% Allowed outcome:\\
%% \[\begin{array}{l}
%% a = 1 \land a' = 2 \land b = 1 \land b' = 2 \\
%% \end{array}\]}{
\codePrefix
  $\writeInstParam{\rlx}{x}{0}; \writeInstParam{\rlx}{y}{0};$ \\
\begin{tabular}{L || L}
  \readInstParam{\rlx}{a}{y} & \readInstParam{\rlx}{b}{x} \\
  \assignInst{a'}{a + 1}; & \assignInst{b'}{b + 1}; \\
  \writeInstParam{\rlx}{x}{1}; & \writeInstParam{\rlx}{y}{1}; \\
\end{tabular}
\codePostfix
}

\midTests

\litmusTestStart{LB-rlx-join}{\tickPP}{Postponed Reads + History + Viewfronts + JN}{
\possibleOutcomes
\[[a = 0, b = 0], [a = 0, b = 1], [a = 1, b = 0], [a = 1, b = 1].\]
}{%
\lbJoinTemplate{\rlx}{\rlx}{\rlx}{\rlx}
}

\midTests

\litmusTestStart{LB-rel-rlx-join}{\tickPP}{Postponed Reads + History + Viewfronts + JN}{
\possibleOutcomes
\[[a = 0, b = 0], [a = 0, b = 1], [a = 1, b = 0], [a = 1, b = 1].\]
}{%
\lbJoinTemplate{\rlx}{\rel}{\rlx}{\rel}
}

\midTests

\litmusTestStart{LB-acq-rlx-join}{\fail}{Postponed Reads + History + Viewfronts + JN}{
\possibleOutcomes
\[[a = 0, b = 0], [a = 0, b = 1], [a = 1, b = 0], [a = 1, b = 1].\]
}{%
\lbJoinTemplate{\acq}{\rlx}{\acq}{\rlx}
}

\section{Передача сообщения, MP}
\label{app:mp}

\litmusTestStart{MP-rlx-na}{\tick}{NA + History + Viewfronts}{
\possibleOutcomes
\[ \UndefinedBeh. \]
}{%
\mpTemplate{\rlx}{\na}{\na}{\rlx}{\rlx}{\na}
}

\midTests

\litmusTestStart{MP-rel-rlx-na}{\tick}{NA + History + Viewfronts}{
\possibleOutcomes
\[ \UndefinedBeh. \]
}{%
\mpTemplate{\rlx}{\na}{\na}{\rel}{\rlx}{\na}
}

\midTests

\litmusTestStart{MP-rlx-acq-na}{\tick}{NA + History + Viewfronts}{
\possibleOutcomes
\[ \UndefinedBeh. \]
}{%
\mpTemplate{\rlx}{\na}{\na}{\rlx}{\acq}{\na}
}

\midTests

\litmusTestStart{MP-rel-acq-na}{\tick}{NA + History + Viewfronts}{
\possibleOutcomes
\[[a = 5].\]
}{%
\mpTemplate{\rlx}{\na}{\na}{\rel}{\acq}{\na}
}

\midTests

\litmusTestStart{MP-rel-acq-na-rlx}{\tick}{Write-fronts + NA + History + Viewfronts}{
\possibleOutcomes
\[[a = 5].\]
}{%
\codePrefix
  $\writeInstParam{\rel}{f}{0}; \writeInstParam{\na}{d}{0};$ \\
  \begin{tabular}{L || L}
    \writeInstParam{\na}{d}{5}; & \repeatInst{[f]_{\acq} == 2}; \\
    \writeInstParam{\rel}{f}{1}; & \readInstParam{\na}{a}{d}\\
    \writeInstParam{\rlx}{f}{2} & \\
  \end{tabular}
\codePostfix
}

\midTests

\litmusTestStart{MP-rel-acq-na-rlx\_2}{\tick}{Write-fronts + NA + History + Viewfronts}{
\possibleOutcomes
\[[a = 5, b = 0], [a = 5, b = 1].\]
}{%
\codePrefix
  $\writeInstParam{\na}{f}{0}; \writeInstParam{\na}{d}{0}; \writeInstParam{\na}{x}{0};$ \\
  \begin{tabular}{L || L}
    \writeInstParam{\na}{d}{5};  & \repeatInst{[f]_{\acq} == 2}; \\
    \writeInstParam{\rel}{f}{1}; & \readInstParam{\na}{a}{d}\\
    \writeInstParam{\rel}{x}{1}; & \readInstParam{\rlx}{b}{x}\\
    \writeInstParam{\rlx}{f}{2} & \\
  \end{tabular}
\codePostfix
}

\midTests

\litmusTestStart{MP-con-na}{\tick}{Consume + NA + History + Viewfronts}{
\possibleOutcomes
\[[a = \nullPtr, b = 0], [a = d, b = 5].\]
}{%
\codePrefix
  $\writeInstParam{\rlx}{f}{\nullPtr}; \writeInstParam{\na}{d}{0};$ \\
  \begin{tabular}{L || L}
    \writeInstParam{\na}{d}{5};  & \readInstParam{\con}{a}{f}; \\
    \writeInstParam{\rel}{f}{d} &
      \begin{array}{@{}l}
        \iteml{a \neq \nullPtr}
        {\readInstParam{\na}{b}{a}}
        {\assignInst{b}{0}} \\
      \end{array}
  \end{tabular}
\codePostfix
}

\midTests

\litmusTestStart{MP-con-na\_2}{\tick}{Consume + NA + History + Viewfronts}{
\possibleOutcomes
\[[a = \nullPtr, b = 0, c = 0], [a = d, b = 5, c = 0], [a = d, b = 5, c = 1].\]
}{%
\codePrefix
  $\writeInstParam{\na}{p}{\nullPtr}; \writeInstParam{\na}{d}{0};
   \writeInstParam{\na}{x}{0};$ \\
  \begin{tabular}{L || L}
    \begin{array}{@{}l}
      \writeInstParam{\rlx}{x}{1}; \\
      \writeInstParam{\na}{d}{1}; \\
      \writeInstParam{\rel}{p}{d} \\
    \end{array}
    &
    \begin{array}{@{}l}
     \readInstParam{\con}{a}{p}; \\
      \begin{array}{@{}l}
        \iteml{a \neq \nullPtr}
        {\readInstParam{\na}{b}{a}; \\
         \readInstParam{\rlx}{c}{x}}
        {\assignInst{b}{0}; \assignInst{c}{0}} \\
      \end{array}
    \end{array}

  \end{tabular}
\codePostfix
}

\midTests

\litmusTestStart{MP-cas-rel-acq-na}{\tick}{NA + History + Viewfronts}{
\possibleOutcomes
\[[a = 0, b = 1], [a = 1, b = 0].\]
}{%
\codePrefix
  $\writeInstParam{\rlx}{f}{1}; \writeInstParam{\na}{d}{0};$ \\
  \begin{tabular}{L || L || L}
    \begin{array}{@{}l@{}}
      \writeInstParam{\na}{d}{5}; \\
      \writeInstParam{\rel}{f}{0} \\
    \end{array}
    &
    \begin{array}{@{}l@{}}
      \casInstParam{\acq}{\rlx}{a}{f}{0}{1}; \\
      \iteml{a == 0}
      {\writeInstParam{\rlx}{d}{6}}
      {0}
    \end{array}
    &
    \begin{array}{@{}l@{}}
      \casInstParam{\acq}{\rlx}{b}{f}{0}{1}; \\
      \iteml{b == 0}
      {\writeInstParam{\rlx}{d}{7}}
      {0}
    \end{array}
  \end{tabular}
\codePostfix
}

\midTests

\litmusTestStart{MP-cas-rel-rlx-na}{\tick}{NA + History + Viewfronts}{
\possibleOutcomes
\[ \UndefinedBeh.\]
}{%
\codePrefix
  $\writeInstParam{\rlx}{f}{1}; \writeInstParam{\na}{d}{0};$ \\
  \begin{tabular}{L || L || L}
    \begin{array}{@{}l@{}}
      \writeInstParam{\na}{d}{5}; \\
      \writeInstParam{\rel}{f}{0} \\
    \end{array}
    &
    \begin{array}{@{}l@{}}
      \casInstParam{\rlx}{\rlx}{a}{f}{0}{1}; \\
      \iteml{a == 0}
      {\writeInstParam{\rlx}{d}{6}}
      {0}
    \end{array}
    &
    \begin{array}{@{}l@{}}
      \casInstParam{\rlx}{\rlx}{b}{f}{0}{1}; \\
      \iteml{b == 0}
      {\writeInstParam{\rlx}{d}{7}}
      {0}
    \end{array}
  \end{tabular}
\codePostfix
}

\section{Корректность повторного чтения, CoRR}
\label{app:corr}

\litmusTestStart{CoRR-rlx}{\tick}{History + Viewfronts}{
  В C/C++11 MM возможны все результаты, соответствующие
  $\{a, b, c, d\} \suq \{0, 1, 2\}$, кроме тех, в которых
  $a > b = 0$ или $c > d = 0$, а также
\[[a = 1, b = 2, c = 2, d = 1], [a = 2, b = 1, c = 1, d = 2].\]
}{%
\codePrefix
  $\writeInstParam{\rlx}{x}{0};$ \\
  \begin{tabular}{L || L || L || L}
    \begin{array}{@{}c@{}}
      \writeInstParam{\rlx}{x}{1}
    \end{array} & 
    \begin{array}{@{}c@{}}
      \writeInstParam{\rlx}{x}{2}
    \end{array} & 
    \begin{array}{@{}c@{}}
      \readInstParam{\rlx}{a}{x}; \\
      \readInstParam{\rlx}{b}{x}
    \end{array} & 
    \begin{array}{@{}c@{}}
      \readInstParam{\rlx}{c}{x}; \\
      \readInstParam{\rlx}{d}{x}
    \end{array} 
  \end{tabular}
\codePostfix
}

\midTests

\litmusTestStart{CoRR-rel-acq}{\tick}{History + Viewfronts}{
  В C/C++11 MM возможны все результаты, соответствующие
  $\{a, b, c, d\} \suq \{0, 1, 2\}$, кроме тех, в которых
  $a > b = 0$ или $c > d = 0$, а также
\[[a = 1, b = 2, c = 2, d = 1], [a = 2, b = 1, c = 1, d = 2].\]
}{%
\codePrefix
  $\writeInstParam{\rel}{x}{0};$ \\
  \begin{tabular}{L || L || L || L}
    \begin{array}{@{}c@{}}
      \writeInstParam{\rel}{x}{1}
    \end{array} & 
    \begin{array}{@{}c@{}}
      \writeInstParam{\rel}{x}{2}
    \end{array} & 
    \begin{array}{@{}c@{}}
      \readInstParam{\acq}{a}{x}; \\
      \readInstParam{\acq}{b}{x}
    \end{array} & 
    \begin{array}{@{}c@{}}
      \readInstParam{\acq}{c}{x}; \\
      \readInstParam{\acq}{d}{x}
    \end{array} 
  \end{tabular}
\codePostfix
}

\section{Независимые чтения независимых записей, IRIW}
\label{app:iriw}

\litmusTestStart{IRIW-rlx}{\tick}{History + Viewfronts}{
  В C/C++11 MM возможны все результаты, соответствующие
  $\{a, b, c, d\} \suq \{0, 1\}$.
}{%
\iriwTemplate{\rlx}{\rlx}{\rlx}{\rlx}{\rlx}{\rlx}{\rlx}{\rlx}
}

\litmusTestStart{IRIW-rel-acq}{\tick}{History + Viewfronts}{
  В C/C++11 MM возможны все результаты, соответствующие
  $\{a, b, c, d\} \suq \{0, 1\}$.
}{%
\iriwTemplate{\rel}{\rel}{\rel}{\rel}{\acq}{\acq}{\acq}{\acq}
}

\litmusTestStart{IRIW-sc}{\tick}{SC + History + Viewfronts}{
  В C/C++11 MM возможны все результаты, соответствующие
  $\{a, b, c, d\} \suq \{0, 1\}$, кроме $[a = 1, b = 0, c = 1, d = 0]$.
}{%
\iriwTemplate{\sc}{\sc}{\sc}{\sc}{\sc}{\sc}{\sc}{\sc}
}

\section{Зависимость запись-чтение, WRC}
\label{app:wrc}

\litmusTestStart{WRC-rel-acq}{\tick}{History + Viewfronts}{
\possibleOutcomes
\[[a = 0, b = 0, c = 0], [a = 1, b = 0, c = 0],\]
\[[a = 1, b = 0, c = 1], [a = 1, b = 1, c = 1].\]
}{%
\codePrefix
  $\writeInstParam{\rel}{x}{0}; \writeInstParam{\rel}{y}{0};$ \\
\begin{tabular}{L || L || L}
\writeInstParam{\rel}{x}{1} &
\readInstParam{\acq}{a}{x}; &
\readInstParam{\acq}{b}{y}; \\

&
\writeInstParam{\rel}{y}{a} &
\readInstParam{\acq}{c}{x} \\
\end{tabular}
\codePostfix
}

\midTests

\litmusTestStart{WRC-rlx}{\tick}{History + Viewfronts}{
\possibleOutcomes
\[[a = 0, b = 0, c = 0], [a = 1, b = 0, c = 0],\]
\[[a = 1, b = 0, c = 1], [a = 1, b = 1, c = 1],\]
\[[a = 1, b = 1, c = 0].\]
}{%
\codePrefix
  $\writeInstParam{\rlx}{x}{0}; \writeInstParam{\rlx}{y}{0};$ \\
\begin{tabular}{L || L || L}
\writeInstParam{\rlx}{x}{1} &
\readInstParam{\rlx}{a}{x}; &
\readInstParam{\rlx}{b}{y}; \\

&
\writeInstParam{\rlx}{y}{a} &
\readInstParam{\rlx}{c}{x} \\
\end{tabular}
\codePostfix
}

\midTests

\litmusTestStart{WRC-cas-rel}{\tick}{History + Viewfronts}{
\possibleOutcomes
\[[a = 0, b = 0, c = 0], [a = 1, b = 0, c = 0],\]
\[[a = 1, b = 0, c = 1], [a = 1, b = 0, c = 1],\]
\[[a = 1, b = 1, c = 1], [a = 1, b = 1, c = 1],\]
\[[a = 1, b = 2, c = 1].\]
}{%
\codePrefix
  $\writeInstParam{\rel}{x}{0}; \writeInstParam{\rel}{y}{0};$ \\
\begin{tabular}{L || L || L}
\writeInstParam{\rel}{x}{1}; &
\casInstParam{\rel}{\acq}{a}{y}{1}{2} &
\readInstParam{\acq}{b}{y}; \\

\writeInstParam{\rel}{y}{1} &
&
\readInstParam{\acq}{c}{x} \\
\end{tabular}
\codePostfix
}

\midTests

\litmusTestStart{WRC-cas-rlx}{\tick}{History + Viewfronts}{
\possibleOutcomes
\[[a = 0, b = 0, c = 0], [a = 1, b = 0, c = 0],\]
\[[a = 1, b = 0, c = 1], [a = 1, b = 0, c = 1],\]
\[[a = 1, b = 1, c = 1], [a = 1, b = 1, c = 1],\]
\[[a = 1, b = 2, c = 1].\]
}{%
\codePrefix
  $\writeInstParam{\rlx}{x}{0}; \writeInstParam{\rlx}{y}{0};$ \\
\begin{tabular}{L || L || L}
\writeInstParam{\rlx}{x}{1}; &
\casInstParam{\rlx}{\rlx}{a}{y}{1}{2} &
\readInstParam{\acq}{b}{y}; \\

\writeInstParam{\rel}{y}{1} &
&
\readInstParam{\rlx}{c}{x} \\
\end{tabular}
\codePostfix
}

\section{``Значения из воздуха'', OOTA}
\label{app:ota}

%% In our semantics it is not possible to get out-of-thin-air results,
%% unlike the C11 standard. But such reads are considered to be an
%% undesirable behavior by most of the standard's
%% clients~\cite{Batty-al:ESOP15}.

\litmusTestStart{OTA-lb}{\fail}{Postponed reads + History + Viewfronts}{
  C/C++11 MM разрешает для этой программы любой результат, в котором $a = b$.
}{%
\codePrefix
  $\writeInstParam{\rlx}{x}{0}; \writeInstParam{\rlx}{y}{0};$ \\
  \begin{tabular}{L || L}
    \readInstParam{\rlx}{a}{y}; &
    \readInstParam{\rlx}{b}{x} \\

    \writeInstParam{\rlx}{x}{a}; &
    \writeInstParam{\rlx}{y}{b} \\
  \end{tabular}
\codePostfix
%% Comment: According to the C11 standard \cite{C:11,CPP:11},
%% \lstinline{r1} and \lstinline{r2} can get arbitrary values.
}

\midTests

\litmusTestStart{OTA-if}{\fail}{Postponed reads + History + Viewfronts}{
\possibleOutcomes
\[[a = 0, b = 0], [a = 1, b = 1].\]
}{%
\codePrefix
  $\writeInstParam{\rlx}{x}{0}; \writeInstParam{\rlx}{y}{0};$ \\
  \begin{tabular}{L || L}
    \readInstParam{\rlx}{a}{y}; &
    \readInstParam{\rlx}{b}{x}; \\
    
    \begin{array}{@{}l@{}}
      \iteml{a}{\writeInstParam{\rlx}{x}{1}}{\assignInst{a}{0}}
    \end{array}
    &
    \begin{array}{@{}l@{}}
      \iteml{b}{\writeInstParam{\rlx}{y}{1}}{\assignInst{b}{0}}
    \end{array}
  \end{tabular}
\codePostfix
%% Comment: According to the C11 standard \cite{C:11,CPP:11},
%% \lstinline{r1} and \lstinline{r2} can be 1s at the end of execution.
}

\section{Независимые записи, WR}
\label{app:wr}

\litmusTestStart{WR-rlx}{\tick}{History + Viewfronts + Operational Buffers}{
\possibleOutcomes
\[[a = 1, b = 2], [a = 1, b = 2], [a = 1, b = 2], [a = 2, b = 2].\]
}{%
\wrTemplate{\rlx}{\rlx}{\rlx}{\rlx}{\rlx}{\rlx}{\rlx}{\rlx}
}

\midTests

\litmusTestStart{WR-rlx-rel}{\tick}{History + Viewfronts + Operational Buffers}{
\possibleOutcomes
\[[a = 1, b = 2], [a = 1, b = 2], [a = 1, b = 2], [a = 2, b = 2].\]
}{%
\wrTemplate{\rlx}{\rlx}{\rlx}{\rel}{\rlx}{\rel}{\rlx}{\rlx}
}

\midTests

\litmusTestStart{WR-rel}{\tick}{History + Viewfronts + Operational Buffers}{
\possibleOutcomes
\[[a = 1, b = 2], [a = 1, b = 2], [a = 1, b = 2], [a = 2, b = 2].\]
}{%
\wrTemplate{\rel}{\rel}{\rel}{\rel}{\rel}{\rel}{\acq}{\acq}
%% This is an example of the program from \cite{Lahav-al:POPL16}.
%% The weak behavior (\lstinline{r1 = r2 = 1}) is allowed in C11,
%% but never observable under any known sound compilation scheme
%% of the C11 release writes.
%% Our semantics doesn't allow such behaviour as well as SRA
%% \cite{Lahav-al:POPL16}. 
}

%% \section{Value Stealing}
%% \label{app:ss}

%% \litmusTestStart{VS-rlx}{\tick}{}
%% \begin{minipage}[t]{0.3\linewidth}
%% \possibleOutcomes\\
%% \lstinline{  r1 = 0}\\
%% \lstinline{  r1 = 1}\\
%% \end{minipage}
%% %
%% \begin{minipage}[t]{0.3\linewidth}
%% \vspace{-.2cm}
%%   \begin{tabular}{l@{\ \ \ }l}
%%     \begin{minipage}[l]{4.3cm} \small
%% \begin{lstlisting}
%%         |$[$|x|$]_{rlx}$| := 0; |$[$|y|$]_{rlx}$| := 0;
%% \end{lstlisting}
%% \vspace{-.2cm}
%% \begin{tabular}{l||l||l}
%% \begin{lstlisting}
%% r1 = |$[$|x|$]_{rlx}$|;
%% |$[$|x|$]_{rlx}$| := 1
%% \end{lstlisting}
%% \hspace{.6cm}
%% &
%% \begin{lstlisting}
%% r2 = |$[$|x|$]_{rlx}$|;
%% |$[$|y|$]_{rlx}$| := r2
%% \end{lstlisting}
%% \hspace{.6cm}
%% &
%% \begin{lstlisting}
%% r3 = |$[$|y|$]_{rlx}$|;
%% |$[$|x|$]_{rlx}$| := r3
%% \end{lstlisting}
%% \end{tabular}
%%     \end{minipage}
%% &
%%   \end{tabular}
%% \end{minipage}

%% \litmusTestEnd

\section{Спекулятивное исполнение, SE}
\label{app:se}

\litmusTestStart{SE-simple}{\tick}{}{
\possibleOutcomes
\[[a = 0, b = 0, c = 0], [a = 0, b = 1, c = 0],\]
\[[a = 1, b = 1, c = 1]. \]
}{%
\codePrefix
  $\writeInstParam{\rlx}{x}{0};
  \writeInstParam{\rlx}{y}{0};
  \writeInstParam{\rlx}{z}{0};$ \\
  \begin{tabular}{L || L}
    \begin{array}{@{}l@{}}
      \readInstParam{\rlx}{a}{x}; \\
      \iteml{a}{
        \writeInstParam{\rlx}{z}{1}; \\
        \writeInstParam{\rlx}{y}{1}
      }{\writeInstParam{\rlx}{y}{1}}
    \end{array} &

    \begin{array}{@{}l@{}}
      \readInstParam{\rlx}{b}{y}; \\
      \iteml{b}{
        \writeInstParam{\rlx}{x}{1}
      }{\skipc}
    \end{array}
  \end{tabular} \\
  $\readInstParam{\rlx}{c}{z}$
\codePostfix
}

\midTests

\litmusTestStart{SE-prop}{\tick}{}{
\possibleOutcomes
\[[a = 0, b = 0, c = 0], [a = 0, b = 1, c = 0],\]
\[[a = 1, b = 1, c = 1]. \]
}{%
\codePrefix
  $\writeInstParam{\rlx}{x}{0};
  \writeInstParam{\rlx}{y}{0};
  \writeInstParam{\rlx}{z}{0};$ \\
  \begin{tabular}{L || L}
    \begin{array}{@{}l@{}}
      \readInstParam{\rlx}{a}{x}; \\
      \iteml{a}{
        \writeInstParam{\rlx}{z}{1}; \\
        \readInstParam{\rlx}{a}{z}; \\
        \writeInstParam{\rlx}{y}{a}
      }{\writeInstParam{\rlx}{y}{1}}
    \end{array} &

    \begin{array}{@{}l@{}}
      \readInstParam{\rlx}{b}{y}; \\
      \iteml{b}{
        \writeInstParam{\rlx}{x}{1}
      }{\skipc}
    \end{array}
  \end{tabular} \\
  $\readInstParam{\rlx}{c}{z}$
\codePostfix
}

\midTests

\litmusTestStart{SE-nested}{\tick}{}{
\possibleOutcomes
\[[a = 0, b = 0, c = 0, d = \bot], [a = 0, b = 1, c = 0, d = \bot],\]
\[[a = 1, b = 1, c = 0, d = 0], [a = 1, b = 1, c = 1, d = 1]. \]
}{%
\codePrefix
  $\writeInstParam{\rlx}{x}{0};
  \writeInstParam{\rlx}{y}{0};
  \writeInstParam{\rlx}{z}{0};
  \writeInstParam{\rlx}{f}{0};$ \\
  \begin{tabular}{L || L}
    \begin{array}{@{}l@{}}
      \readInstParam{\rlx}{a}{x}; \\
      \iteml{a}{
        \readInstParam{\rlx}{d}{f}; \\
        \iteml{d}{
          \writeInstParam{\rlx}{z}{1}; \\
          \writeInstParam{\rlx}{y}{1}
        }{\writeInstParam{\rlx}{y}{1}}
      }{\writeInstParam{\rlx}{y}{1}}
    \end{array} &

    \begin{array}{@{}l@{}}
      \readInstParam{\rlx}{b}{y}; \\
      \iteml{a}{
        \writeInstParam{\rlx}{f}{1}; \\
        \writeInstParam{\rlx}{x}{1}
      }{\skipc}
    \end{array}
  \end{tabular} \\
  $\readInstParam{\rlx}{c}{z}$
\codePostfix
}

\section{\textrm{ARM-weak}}
\label{app:armweak}

\litmusTestStart{}{\tick}{}{
\possibleOutcomes
\[[a = 0, b = 0, c = 0], [a = 0, b = 1, c = 0], [a = 0, b = 1, c = 1],
  [a = 1, b = 1, c = 1].\]
}{%
\codePrefix
  $\writeInst{x}{0}; \writeInst{y}{0};$ \\
\begin{tabular}{L || L || L}
  \readInst{a}{x}; \; \valuecom{1} & \readInst{b}{x}; & \readInst{c}{y}; \\
  \writeInst{x}{1}                 & \writeInst{y}{b} & \writeInst{x}{c} \\
\end{tabular}
\codePostfix
}

\section{Блокировки}
\label{app:locks}

\litmusTestStart{Блокировка Деккера}{\tick}{}{
\possibleOutcomes
\[ \UndefinedBeh. \]
}{%
\codePrefix
$\writeInstParam{\rel}{x}{0}; \writeInstParam{\rel}{y}{0}; \writeInstParam{\na}{d}{0};$ \\
\begin{tabular}{L || L}
  \begin{array}{@{}l@{}}
    \writeInstParam{\rel}{x}{1}; \\
    \readInstParam{\acq}{a}{y}; \\
    \iteml{a == 0}{
      \writeInstParam{\na}{d}{5}
    }{\skipc}
  \end{array} &
  \begin{array}{@{}l@{}}
    \writeInstParam{\rel}{y}{1}; \\
    \readInstParam{\acq}{b}{x}; \\
    \iteml{b == 0}{
      \writeInstParam{\na}{d}{6}
    }{\skipc}
  \end{array}
\end{tabular}
\codePostfix
}

\midTests

\litmusTestStart{Блокировка Коэна \cite{Turon-al:OOPSLA14}}{\tick}{}{
\possibleOutcomes
\[[a = 1, b = 1, c = 1, d = 1], [a = 1, b = 2, c = 1, d = 2],\]
\[[a = 2, b = 1, c = 2, d = 1], [a = 2, b = 2, c = 2, d = 2].\]
}{%
\codePrefix
  $\writeInstParam{\rel}{x}{0};\writeInstParam{\rel}{y}{0};\writeInstParam{\na}{d}{0};$ \\
  \begin{tabular}{L || L}
    \begin{array}{@{}l@{}}
      \writeInstParam{\rel}{x}{\Choice{1}{2}}; \\
      \repeatReadInst{\acq}{y}; \\
      \readInstParam{\acq}{a}{x}; \\
      \readInstParam{\acq}{b}{y}; \\
      \iteml{a == b}{
        \writeInstParam{\na}{d}{5}
      }{\skipc}
    \end{array} &

    \begin{array}{@{}l@{}}
      \writeInstParam{\rel}{y}{\Choice{1}{2}}; \\
      \repeatReadInst{\acq}{x}; \\
      \readInstParam{\acq}{c}{x}; \\
      \readInstParam{\acq}{d}{y}; \\
      \iteml{c \neq d}{
        \writeInstParam{\na}{d}{6}
      }{\skipc}
    \end{array}
  \end{tabular}
\codePostfix
}
