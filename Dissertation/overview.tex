\chapter{Обзор предметной области} \label{sec:overview}

В данной главе вводится понятие модели памяти, слабой модели памяти,
приводится примеры слабых сценариев поведения программ. Описываются
классы моделей памяти: операционные, аксиоматические (декларативные),
денотационные.
Рассматриваются существующие модели памяти языков программирования и
процессорных архитектур, а также требования, предъявляемые к ним.
Приводится подробное описание модели памяти C/C++11 \cite{Batty-al:POPL11}.
Описывается проблема ``значений из воздуха'' (OOTA, out-of-thin-air values).
В конце главы приведены выводы о состоянии предметной области и о существующих
направлениях исследования в ней.

\section{Модели памяти, слабые сценарии поведения}
Под \emph{моделью памяти} мы будем понимать семантику системы с многопоточностью.
В рамках диссертационного исследования рассматриваются два типа таких систем:
языки программирования и процессорные архитектуры.

Модели памяти разделяются по принципу того, какие ограничения на сценарии поведения
программ, запущенных в системе опеределения модели, они предоставляют \cite{Kshemkalyani-Singhal:2011}.
Так, \emph{строгая консистентность} гарантирует, что любая запись в память становится мгновенно видна
всем потокам в системе. Эта модель требует наличия некоторого абсолютного времени, разделяемого между потоками системы,
что зачастую является недостижимым требованием. Менее строгая модель \emph{последовательной консистентности} \cite{Lamport:TC79}
(SC, sequential consistency)
предполагает, что любой сценарий исполнения может быть получен исполнением программных потоков на одном вычислительном
ядре с вытесняющей многозадачностью. Это означает, что все операции над памятью, совершаемые потоками в рамках сценария исполнения,
могут быть упорядочены, и полученный порядок согласуется с порядком инструкций в самих потоках.
Сценарии поведения программ, которые не могут быть получены в рамках модели SC, называются
\emph{слабыми}, а модели, допускающие слабые сценарии поведения, --- \emph{слабыми моделями памяти}.

Несмотря на то, что модель SC кажется наиболее естественной, а статья \cite{Lamport:TC79},
в которой модель описывается, называется ``How to make a multiprocessor computer that correctly executes multiprocess programs'',
современные процессорные архитектуры и языки программирования используют слабые модели памяти. Такое положение вещей
связано с тем, что слабые модели позволяют реализовать большее число оптимизаций как на уровне процессора, так и на уровне
компилятора, что увеличивает производительность программ.

Рассмотрим следующую программу ${\rm MP}$ (передача сообщения, message passing).
%% которая обладает слабым поведением на большинстве современных программных архитектур:
\begin{equation*}
\tag{MP}\label{ex:MP}
\begin{tabular}{L || L}
  \writeInst{x}{1}; & \readInst{a}{y}; ~\valuecom{1} \\
  \writeInst{y}{1}; & \readInst{b}{x}; ~\valuecom{0} \\
\end{tabular}
\end{equation*}
Эта программа является упрощенным вариантом шаблона, используемого для передачи
данных между потоками. Первый поток записывает данные в локацию $x$ и потом выставляет флаг (локация $y$),
что данные подготовлены; в свою очередь второй поток проверяет флаг, а потом читает данные.
Модель SC гарантирует, что если второй поток увидел, что
флаг выставлен ($a = 1$), то он увидит и подготовленные данные ($b = 1$).
Тем не менее, эта программа имеет слабый сценарий исполнения ($a = 1, b = 0$) на таких архитектурах как Power, ARM.

С чем связано то, что на упомянутых выше архитектурах возможен результат $a = 1, b = 0$?
Оптимизирующий процессор при исполнении программы может выполнить независимые инструкции не по порядку.
Поскольку первая и вторая инструкции в левом потоке являются обращениями к разным локациям, то процессор может выполнить
сначала вторую запись, а потом --- первую.
Аналогичное верно и для инструкций в правом потоке.
После исполения инструкций не по порядку хотя бы в одном потоке результат $a = 1, b = 0$ становится возможным.

Такой сценарий поведения также разрешается и моделями памяти некоторых языков программирования, например, стандартами языков
C11 \cite{C:11} и C++11 \cite{CPP:11}, поскольку оптимизирующий компилятор должен иметь возможность переупорядочить независимые обращения
к памяти.

\section{Существующие модели памяти}
На данный момент существует множество моделей памяти, как для процессорных архитектур
\cite{Sewell-al:CACM10,Alglave-al:TOPLAS14,Flur-al:POPL16,Pulte-al:POPL18,Sarkar-al:PLDI11}
так и для языков программирования
\cite{Crary-Sullivan:POPL15,Lamport:TC79,Boudol-al:EXPRESS12,Boudol-Petri:POPL09,PichonPharabod-Sewell:POPL16,Jeffrey-Riely:LICS16},
абсолютное большинство которых являются слабыми моделями.

Среди процессорных моделей стоит выделить модели x86-TSO \cite{Sewell-al:CACM10}, Power \cite{Alglave-al:TOPLAS14}
и ARM \cite{Flur-al:POPL16,Pulte-al:POPL18}.

%% В последние годы научное сообщество в сотрудничестве с индустрией разработало множество моделей памяти, как для процессорных архитектур
%% (x86-TSO \cite{Sewell-al:CACM10}, Power \cite{Alglave-al:TOPLAS14}, ARM \cite{Flur-al:POPL16,Pulte-al:POPL18}),
%% так и для языков программирования (Java \cite{Manson-al:POPL05}, C/C++11 \cite{Batty-al:POPL11}).
%% Все эти модели являются слабыми.

Упомянутые выше модели памяти процессорных архитектур являются 


\app{TODO: требования к PL MM} \\
\cite{Batty-al:ESOP15}
\app{TODO: табличка с требованиями к PL MM}

\begin{table}[t]
  \begin{center}
  \begin{tabular}{r || l | l | l | l | l}
    {\bf НМ}& {\bf ЭК} & {\bf КО} & {\bf Нет OOTA} & {\bf Реж. C/C++11} & {\bf ОИ}  \\
    \midrule
  \end{tabular}
  \end{center}
  \label{tbl:plmmrequirements}
  \caption{Соответствие существующих моделей памяти для языков программирования основным требованиям, где
    {\bf НМ} --- название модели,
    {\bf ЭК} --- наличие эффективной схемы компиляции в целевые платформы,
    {\bf КО} --- поддержка компиляторных оптимизаций,
    {\bf Нет OOTA} --- отсутствие OOTA,
    {\bf Реж. C/C++11} --- поддержка режимов C/C++11,
    {\bf ОИ} --- обладает операционной интуицией
  }
\end{table}

\section{Модель памяти C/C++11}

Данной модели памяти посвящено множество работ
\cite{Batty-al:POPL12,Batty-al:POPL13,Lahav-al:PLDI17,Chakraborty-Vafeiadis:CGO16,Vafeiadis-al:POPL15,Vafeiadis:CPP15}

В том числе были предложены логики для рассуждений о программах в этой модели
\cite{}

%% Данное заключение неверно для моделей, в том числе для обещающей и ARMv8.3
%% моделей. Рассмотрим, как слабое поведение $a = 1, b = 0$ достигается при исполнении ${\rm MP}$
%% в обещающей модели памяти.

%% План
%% \begin{itemize} 
%%   \item Определение. Модель памяти
%%   \item Определение. Модель последовательной консистентности
%%   \item Мотивировка. Пример слабого исполнения
%%   \item Определение. Слабый сценарий исполнения
%%   \item Определение. Слабая модель памяти
%%   \item Существующие модели
%%   \begin{itemize}
%%     \item Языки
%%       \begin{itemize}
%%         \item C/C++
%%         \item Java
%%         \item ?? LLVM ??
%%         \item ?? .Net ??
%%       \end{itemize}
%%     \item Процессоры
%%       \begin{itemize}
%%         \item x86
%%         \item Power
%%         \item ARM
%%         \item DEC Alpha (видимая спекуляция потоков)
%%       \end{itemize}
%%   \end{itemize}
%%   \begin{itemize}
%%     \item Модель памяти C/C++11. Недостатки
%%       \begin{itemize}
%%         \item OOTA (out-of-thin-air)
%%         \item Нет операционной интуиции
%%       \end{itemize}
%%     \item Модель памяти Java. Недостатки
%%       \begin{itemize}
%%         \item Оптимизации некорректны
%%         \item Нет операционной интуиции
%%       \end{itemize}
%%   \end{itemize}
%%   \item Определение. Операционная модель памяти
%%   \item Определение. Декларативная (аксиоматическая) модель памяти
%% \end{itemize}


%% \section{Модели памяти}
%% \subsection{Виды моделей памяти}
