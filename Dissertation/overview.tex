\chapter{Обзор предметной области} \label{sec:overview}
В данной главе вводится понятие модели памяти, слабой модели памяти,
приводится примеры слабых сценариев поведения программ. Описываются
классы моделей памяти: операционные, аксиоматические (декларативные),
денотационные.
Рассматриваются существующие модели памяти языков программирования и
процессорных архитектур, а также требования, предъявляемые к ним.
Приводится подробное описание модели памяти C/C++11 \cite{Batty-al:POPL11}.
Описывается проблема ``значений из воздуха'' (OOTA, out-of-thin-air values).
В конце главы приведены выводы о состоянии предметной области и о существующих
направлениях исследования в ней.

\section{Модели памяти, слабые сценарии поведения}
Под \emph{моделью памяти} мы будем понимать семантику системы с многопоточностью.
В рамках диссертационного исследования рассматриваются два типа таких систем:
языки программирования и процессорные архитектуры.

Модели памяти разделяются по принципу того, какие ограничения на сценарии поведения
программ, запущенных в системе определения модели, они предоставляют \cite{Kshemkalyani-Singhal:2011}.
Так, \emph{строгая консистентность} гарантирует, что любая запись в память становится мгновенно видна
всем потокам в системе. Эта модель требует наличия некоторого абсолютного времени, разделяемого между потоками системы,
что зачастую является недостижимым требованием. Менее строгая модель \emph{последовательной консистентности} \cite{Lamport:TC79}
(SC, sequential consistency)
предполагает, что любой сценарий исполнения может быть получен исполнением программных потоков на одном вычислительном
ядре с вытесняющей многозадачностью. Это означает, что все операции над памятью, совершаемые потоками в рамках сценария исполнения,
могут быть упорядочены, и полученный порядок согласуется с порядком инструкций в самих потоках.
Сценарии поведения программ, которые не могут быть получены в рамках модели SC, называются
\emph{слабыми}, а модели, допускающие слабые сценарии поведения, --- \emph{слабыми моделями памяти}.

Несмотря на то, что модель SC кажется наиболее естественной, а статья \cite{Lamport:TC79},
в которой модель описывается, называется ``How to make a multiprocessor computer that correctly executes multiprocess programs'',
современные процессорные архитектуры и языки программирования используют слабые модели памяти. Такое положение вещей
связано с тем, что слабые модели позволяют реализовать большее число оптимизаций как на уровне процессора, так и на уровне
компилятора, что увеличивает производительность программ.

Рассмотрим следующую программу ${\rm MP}$ (передача сообщения, message passing).
%% которая обладает слабым поведением на большинстве современных программных архитектур:
\begin{equation*}
\tag{MP}\label{ex:MP}
\begin{tabular}{L || L}
  \writeInst{x}{1}; & \readInst{a}{y}; ~\valuecom{1} \\
  \writeInst{y}{1}; & \readInst{b}{x}; ~\valuecom{0} \\
\end{tabular}
\end{equation*}
Эта программа является упрощенным вариантом шаблона, используемого для передачи
данных между потоками. Первый поток записывает данные в локацию $x$ и потом выставляет флаг (локация $y$),
что данные подготовлены; в свою очередь второй поток проверяет флаг, а потом читает данные.
Модель SC гарантирует, что если второй поток увидел, что
флаг выставлен ($a = 1$), то он увидит и подготовленные данные ($b = 1$).
Тем не менее, эта программа имеет слабый сценарий исполнения ($a = 1, b = 0$) на таких архитектурах как Power, ARM.

С чем связано то, что на упомянутых выше архитектурах возможен результат $a = 1, b = 0$?
Оптимизирующий процессор при исполнении программы может выполнить независимые инструкции не по порядку.
Поскольку первая и вторая инструкции в левом потоке являются обращениями к разным локациям, то процессор может выполнить
сначала вторую запись, а потом --- первую.
Аналогичное верно и для инструкций в правом потоке.
После исполнения инструкций не по порядку хотя бы в одном потоке результат $a = 1, b = 0$ становится возможным.

Такой сценарий поведения также разрешается и моделями памяти некоторых языков программирования, например, стандартами языков
C11 \cite{C:11} и C++11 \cite{CPP:11}, поскольку оптимизирующий компилятор должен иметь возможность переупорядочить независимые обращения
к памяти.

\section{Требования к моделям памяти}
На данный момент существует множество моделей памяти, как для процессорных архитектур
\cite{Sewell-al:CACM10,Alglave-al:TOPLAS14,Flur-al:POPL16,Pulte-al:POPL18,Sarkar-al:PLDI11},
так и для языков программирования
\cite{Crary-Sullivan:POPL15,Lamport:TC79,Boudol-al:EXPRESS12,Boudol-Petri:POPL09,PichonPharabod-Sewell:POPL16,Jeffrey-Riely:LICS16,
Nienhuis-al:OOPSLA16,Batty-al:POPL11,Manson-al:POPL05}.
Существенным отличием между этими группами моделей является то, какие требования к ним предъявляются.

Модели процессорных архитектур должны описывать поведения существующих процессоров, а также оставлять пространство
для возможных оптимизаций в будущем.
Кроме того такие модели зачастую либо заданы \emph{операционно}, т.е. в терминах некоторой
абстрактной машины \cite{Diehl-al:FGCS00}, либо имеют эквивалентное операционное представление.
Это позволяет определить модель в терминах, близких и понятных разработчикам самой архитектуры, а также предоставить
операционную интуицию разработчикам компиляторов в эту платформу.

Модель памяти языка программирования должна быть представлена таким образом, чтобы, с одной стороны,
разрешать манипуляции над кодом программы, совершаемые в рамках компиляторных оптимизаций, и давать возможность
эффективно компилировать программы в целевую процессорную архитектуру, а, с другой стороны, предоставлять
разумные гарантии для программиста, использующего данный язык.
Эти требования к модели языка программирования до некоторой степени противоречат друг другу, поэтому хорошая модель
соблюдает баланс между ними.
Для того, чтобы понять, в чём заключается противоречие данных требований, опишем их подробнее.

\subsection{Корректность компиляторных оптимизаций}
Пусть есть некоторый язык $\LL$ и его модель памяти $\MM$. Тогда под \emph{семантикой программы $\PP$ на языке $\LL$ в модели $\MM$}
мы будем понимать множество возможных сценариев поведения $\PP$ в $\MM$ и обозначать $\sem{\PP}_\MM$.
%% \begin{definition}
\emph{Оптимизацией над программами в языке $\LL$} мы будем называть функцию $\opt : \LL \rightarrow \LL$, действующую из
множества программ на языке $\LL$ в него же.
%% \end{definition}
\begin{definition}
  Оптимизация $\opt : \LL \rightarrow \LL$ называется \emph{корректной в модели $\MM$},
  $\correctOpt_\MM(\opt)$, если для любой программы $\PP$ на языке $\LL$
  семантика оптимизированной программы $\opt(\PP)$ является подмножеством семантики изначальной программы $\PP$.
  \[\forall \opt : \LL \rightarrow \LL. \; \correctOpt_\MM(\opt) \Leftrightarrow (\forall \PP \in \LL. \; \sem{\opt(\PP)}_\MM \subseteq \sem{\PP}_\MM). \]
\end{definition}

%% Если модель разрешает манипуляции над кодом, такие как перестановка инструкций, это означает, что семантика изначальной
%% программы в рамках модели должна включать себя 

%% , абсолютное большинство которых являются слабыми моделями.
%% Все эти модели являются слабыми.

%% Среди процессорных моделей стоит выделить модели архитектур x86 \cite{Sewell-al:CACM10,Owens-al:TPHOL09},
%% Power \cite{Alglave-al:TOPLAS14,Sarkar-al:PLDI11} и ARM \cite{Flur-al:POPL16,Pulte-al:POPL18}, т.к. данные архитектуры являются
%% наиболее распространенными на данный момент.

%% В последние годы научное сообщество в сотрудничестве с индустрией разработало множество моделей памяти, как для процессорных архитектур
%% (x86-TSO \cite{Sewell-al:CACM10}, Power \cite{Alglave-al:TOPLAS14}, ARM \cite{Flur-al:POPL16,Pulte-al:POPL18}),
%% так и для языков программирования (Java \cite{Manson-al:POPL05}, C/C++11 \cite{Batty-al:POPL11}).
%% Все эти модели являются слабыми.

Упомянутые выше модели памяти процессорных архитектур являются 


\app{TODO: требования к PL MM} \\
\cite{Batty-al:ESOP15}
\app{TODO: табличка с требованиями к PL MM}

\begin{table}[t]
  \begin{center}
  \begin{tabular}{r || l | l | l | l | l}
    {\bf НМ}& {\bf ЭК} & {\bf КО} & {\bf Нет OOTA} & {\bf Реж. C/C++11} & {\bf ОИ}  \\
    \midrule
  \end{tabular}
  \end{center}
  \label{tbl:plmmrequirements}
  \caption{Соответствие существующих моделей памяти для языков программирования основным требованиям, где
    {\bf НМ} --- название модели,
    {\bf ЭК} --- наличие эффективной схемы компиляции в целевые платформы,
    {\bf КО} --- поддержка компиляторных оптимизаций,
    {\bf Нет OOTA} --- отсутствие OOTA,
    {\bf Реж. C/C++11} --- поддержка режимов C/C++11,
    {\bf ОИ} --- обладает операционной интуицией
  }
\end{table}

\section{Модель памяти C/C++11}

Данной модели памяти посвящено множество работ
\cite{Batty-al:POPL12,Batty-al:POPL13,Lahav-al:PLDI17,Chakraborty-Vafeiadis:CGO16,Vafeiadis-al:POPL15,Vafeiadis:CPP15}

В том числе были предложены логики для рассуждений о программах в этой модели
\cite{Turon-al:OOPSLA14,Vafeiadis-Narayan:OOPSLA13,Lahav-Vafeiadis:ICALP15,Doko-Vafeiadis:VMCAI16}
и использованы для доказательства корректности
алгоритмов в рамках модели (например, RCU \cite{Tassarotti-al:PLDI15,Doko-Vafeiadis:ESOP17}).

%% Данное заключение неверно для моделей, в том числе для обещающей и ARMv8.3
%% моделей. Рассмотрим, как слабое поведение $a = 1, b = 0$ достигается при исполнении ${\rm MP}$
%% в обещающей модели памяти.

%% План
%% \begin{itemize} 
%%   \item Определение. Модель памяти
%%   \item Определение. Модель последовательной консистентности
%%   \item Мотивировка. Пример слабого исполнения
%%   \item Определение. Слабый сценарий исполнения
%%   \item Определение. Слабая модель памяти
%%   \item Существующие модели
%%   \begin{itemize}
%%     \item Языки
%%       \begin{itemize}
%%         \item C/C++
%%         \item Java
%%         \item ?? LLVM ??
%%         \item ?? .Net ??
%%       \end{itemize}
%%     \item Процессоры
%%       \begin{itemize}
%%         \item x86
%%         \item Power
%%         \item ARM
%%         \item DEC Alpha (видимая спекуляция потоков)
%%       \end{itemize}
%%   \end{itemize}
%%   \begin{itemize}
%%     \item Модель памяти C/C++11. Недостатки
%%       \begin{itemize}
%%         \item OOTA (out-of-thin-air)
%%         \item Нет операционной интуиции
%%       \end{itemize}
%%     \item Модель памяти Java. Недостатки
%%       \begin{itemize}
%%         \item Оптимизации некорректны
%%         \item Нет операционной интуиции
%%       \end{itemize}
%%   \end{itemize}
%%   \item Определение. Операционная модель памяти
%%   \item Определение. Декларативная (аксиоматическая) модель памяти
%% \end{itemize}


%% \section{Модели памяти}
%% \subsection{Виды моделей памяти}

Выводы из обзора области.
%% На основе ранее выполненного обзора делаются следующие выводы.
\begin{itemize}
  \item Модель памяти промышленного языка программирования должна удовлетворять, как минимум, трём критериям.
    Во-первых, должна существовать корректная схема компиляции в модель целевой процессорной
    архитектуры.
    Во-вторых, основные компиляторные оптимизации должны быть корректны в рамках модели.
    В-третьих, у модели должна отсутствовать проблема ``значений из воздуха''.
  \item При разработке новой модели памяти языка программирования нужно доказывать корректность эффективной компиляции
     в модели памяти целевых процессорных архитектур.
  \item Существующие модели памяти промышленных языков программирования не удовлетворяют всем приведённым выше
    критериям.
  \item Требуется разработать операционную модель памяти с синтаксисом модели C/C++11, которая
    не имеет проблемы ``значений из воздуха''.
  %% \item ``Обещающая'' модель памяти является перспективной альтернативой существующей модели памяти C/C++.
\end{itemize}
