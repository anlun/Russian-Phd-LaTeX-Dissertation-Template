\chapter{Обзор предметной области} \label{sec:overview}
В данной главе вводятся основные понятия, использующиеся в этом диссертационном исследовании: модель памяти, слабая модель памяти
и др. --- а также приводятся примеры.
Рассматриваются существующие модели памяти языков программирования и
процессорных архитектур, а также требования, предъявляемые к ним.
Приводится описание проблемы ``значений из воздуха''\label{acr:oota} (OOTA, out-of-thin-air values).
Подробно описывается модель памяти C/C++11~\cite{Batty-al:POPL11}.
В конце главы приведены выводы о состоянии предметной области и о существующих
открытых проблемах.

\section{Модели памяти и слабые сценарии поведения}
В диссертационном исследовании под \emph{моделью памяти} понимается семантика системы с многопоточностью,
и рассматриваются два типа таких систем: языки программирования и процессорные архитектуры.

Модели памяти разделяются по принципу того, какие ограничения на сценарии поведения
программ они накладывают~\cite{Kshemkalyani-Singhal:2011}.
Так, \emph{строгая консистентность} гарантирует, что любая запись в память становится мгновенно видна
всем потокам в системе. Эта модель требует наличия некоторого абсолютного счётчика времени, разделяемого
всеми потоками системы, что зачастую является недостижимым.
Менее строгая модель \emph{последовательной консистентности}~\cite{Lamport:TC79}
(SC, sequential consistency)\label{acr:sc}
предполагает, что любой сценарий поведения может быть получен исполнением потоков на одном вычислительном
ядре с вытесняющей многозадачностью. Это означает, что все операции над памятью, совершаемые потоками в рамках
одного сценария поведения,
могут быть упорядочены, и полученный порядок согласуется с порядком инструкций в самих потоках.
Сценарии поведения программ, которые не могут быть получены в рамках модели SC, называются
\emph{слабыми}, а модели, допускающие слабые сценарии поведения, --- \emph{слабыми моделями памяти}~\cite{Adve-Gharachorloo:IEEE96}.

Несмотря на то, что модель SC кажется наиболее естественной, а статья~\cite{Lamport:TC79},
в которой эта модель описывается, называется ``How to make a multiprocessor computer that correctly executes multiprocess programs'',
современные процессорные архитектуры и языки программирования активно используют слабые модели памяти. Это 
связано с тем, что такие модели позволяют реализовать большее число оптимизаций как на уровне процессора
\cite{Hennessy-Patterson:BOOK}, так и на уровне компилятора~\cite{Aho-al:BOOK86,Muchnick:BOOK97},
что увеличивает производительность программ.

Рассмотрим следующую программу ${\rm MP}$\label{acr:mp} (message passing, передача сообщения):
%% которая обладает слабым поведением на большинстве современных программных архитектур:
\begin{equation*}
\tag{MP}\label{ex:MP}
\begin{tabular}{c}
  $\writeInst{x}{0}; \writeInst{y}{0};$ \\
\begin{tabular}{L || L}
  \writeInst{x}{1}; & \readInst{a}{y}; ~\valuecom{1} \\
  \writeInst{y}{1} & \readInst{b}{x}~ ~\valuecom{0} \\
\end{tabular}
\end{tabular}
\end{equation*}
Эта программа является упрощенным примером передачи данных между потоками.
Первый поток записывает данные в локацию $x$ и потом выставляет флаг (локация $y$),
что данные подготовлены; в свою очередь второй поток проверяет этот флаг, а потом читает данные.
Модель SC гарантирует, что если второй поток увидел, что
флаг выставлен ($a = 1$), то он увидит и подготовленные данные ($b = 1$).
Тем не менее, эта программа имеет слабый сценарий поведения с результатом $[a = 1, b = 0]$ на таких архитектурах как Power и ARM.

С чем связано то, что на упомянутых выше архитектурах возможен результат $[a = 1, b = 0]$?
Оптимизирующий процессор при исполнении программы может выполнить независимые инструкции не по порядку.
Поскольку первая и вторая инструкции в левом потоке являются обращениями к разным локациям, то процессор может выполнить
сначала вторую запись, а потом первую.
То же самое верно и для инструкций в правом потоке.
После исполнения инструкций не по порядку хотя бы в одном потоке результат $[a = 1, b = 0]$ становится возможным.

Такой сценарий поведения также разрешается моделями памяти некоторых языков программирования, например, стандартами языков
C11~\cite{C:11} и C++11~\cite{CPP:11}, поскольку оптимизирующий компилятор должен иметь возможность переупорядочить независимые обращения
к памяти.

\subsubsection{О корректности программы ${\rm MP}$. Гонки по данным}
С точки зрения некоторых языков программирования программа ${\rm MP}$ может считаться некорректной,
т.к. в этой программе есть \emph{гонка по данным}~\cite{Unger:ITC95}.
\begin{definition}
  \label{def:datarace}
  В программе имеется \emph{гонка по данным} (data race), если в некотором её сценарии поведения существуют два неупорядоченных
  обращения к одной и той же ячейке памяти, причём, как минимум, одно из этих обращений является операцией записи.
\end{definition}
Данное определение не является формальным, т.к. здесь не определяется порядок на операциях над памятью.
Это связано с тем, что в разных моделях этот порядок определяется существенно по-разному.
По сути, два обращения неупорядочены, если порядок их исполнения определяется не логикой
программы, а внешними факторами, такими как, например, диспетчеризация потоков.

В отсутствии гонок по данным большинство слабых моделей памяти гарантируют, что все сценарии поведения
являются SC-поведениями. Для того, чтобы добиться отсутствия гонок даже при использовании общей памяти (shared memory),
применяют \emph{блокировки} (locks), которые упорядочивают обращения к разделяемому ресурсу.

Как следствие, один из способов задать модель памяти для языка программирования выглядит следующим образом:
если в программе нет гонок по данным, то её поведение определяется моделью SC, иначе программа является некорректной и
обладает неопределенным поведением (undefined behavior).
У такого способа есть, как минимум, два недостатка.
Во-первых, языки программирования  (например, Java), стремясь обеспечить
\emph{типобезопасность} (type safety), не могут использовать такой способ задания семантики,
т.к. гарантируют, что программа не может иметь неопределенное поведение, если она прошла проверку типов, а
наличие или отсутствие гонок по данным не может быть проверено статически.
Во-вторых, многие высокопроизводительные алгоритмы многопоточного программирования используют парадигму
\emph{неблокирующей синхронизации} (non-blocking synchronization), которая существенным образом опирается
на гонки по данным. Более того, в большинстве случаев реализация самих блокировок использует гонки по данным,
что делает невозможным рассуждения о ней в рамках приведенной выше упрощённой модели.

Из вышесказанного следует, что модель памяти промышленного языка программирования должна обеспечивать корректную семантику,
как минимум, для некоторого множества программ с гонками по данным.

\section{Требования к моделям памяти}
На данный момент имеется множество моделей памяти как для процессорных архитектур
\cite{Sewell-al:CACM10,Alglave-al:TOPLAS14,Flur-al:POPL16,Pulte-al:POPL18,Sarkar-al:PLDI11,Kavanagh-Brookes:CoRR17},
так и для языков программирования
\cite{Crary-Sullivan:POPL15,Lamport:TC79,Boudol-al:EXPRESS12,Boudol-Petri:POPL09,PichonPharabod-Sewell:POPL16,Jeffrey-Riely:LICS16,
Nienhuis-al:OOPSLA16,Batty-al:POPL11,Manson-al:POPL05}.
Существенным отличием между этими группами моделей являются предъявляемые к ним требования.

Модели процессорных архитектур должны описывать сценарии поведения существующих процессоров, а также оставлять пространство
для возможных оптимизаций для следующих версий процессоров.
Кроме того, такие модели зачастую либо заданы \emph{операционно}, т.е. в терминах некоторой
абстрактной машины~\cite{Diehl-al:FGCS00}, либо имеют эквивалентное операционное представление.
Это позволяет определить модель в терминах, близких и понятных разработчикам архитектуры,
а также дать разработчикам компиляторов интуитивно понятное представление
об исполнении программы.

Модель памяти языка программирования должна быть представлена таким образом, чтобы, с одной стороны,
она разрешала манипуляции над кодом программы, совершаемые в рамках компиляторных оптимизаций, и давала возможность
эффективно компилировать программы в целевую процессорную архитектуру, а, с другой стороны, предоставляла
разумные гарантии для программиста.
Эти требования до некоторой степени противоречат друг другу, поэтому хорошая модель
соблюдает баланс между ними.
Для того, чтобы понять, в чём заключается противоречие данных требований, остановимся на них подробнее.

\subsection{Корректность компиляторных оптимизаций}
Пусть есть некоторый язык программирования $\LL$%
\footnote{Здесь язык программирования рассматривается как множество высказываний
(в нашем случае --- программ) на этом языке.}
и его модель памяти $\MM$\label{acr:mm} (memory model).
Тогда под \emph{семантикой программы $\PP$ на языке $\LL$ в модели $\MM$}
будет пониматься множество возможных сценариев поведения $\PP$ в $\MM$.
Это множество будет обозначаться $\sem{\PP}_\MM$.
%% \begin{definition}
\emph{Оптимизацией над программами в языке $\LL$} мы будем называть функцию $\opt$, действующую из
множества программ на языке $\LL$ в него же.
%% \end{definition}
\begin{definition}
  Оптимизация $\opt : \LL \rightarrow \LL$ называется \emph{корректной в модели $\MM$},
  $\correctOpt_\MM(\opt)$, если для любой программы $\PP$ на языке $\LL$
  семантика оптимизированной программы $\opt(\PP)$ является подмножеством семантики изначальной программы $\PP$:
  \[\forall \opt : \LL \rightarrow \LL. \; \correctOpt_\MM(\opt) \Leftrightarrow (\forall \PP \in \LL. \; \sem{\opt(\PP)}_\MM \subseteq \sem{\PP}_\MM). \]
\end{definition}

Какие компиляторные оптимизации должны быть корректны в рамках модели памяти языка программирования?
К сожалению, на данный момент не существует полного списка таких оптимизаций, однако из работ
\cite{Vafeiadis-al:POPL15,Morisset-al:PLDI13,Sevcik-Aspinall:ECOOP08} можно выделить пять основных групп.
\begin{enumerate}
  \item Локальные оптимизации, не меняющие обращения к памяти.
    Например, удаление условных переходов, зависимых от заведомо ложного условия:
    \[
      \begin{array}{l c l}
        \begin{array}{l}
        \assignInst{a}{0}; \\
        \iteml{a}{\readInst{b}{x}}{\skipc}; \\
        \readInst{c}{y} \\
        \end{array}
        & \optarrow &
        \begin{array}{l}
          \assignInst{a}{0}; \\
          \skipc; \\
          \readInst{c}{y}
        \end{array}
      \end{array}
    \]
  \item Перестановка независимых обращений к памяти.
    Например, перестановка инструкций чтения из разных локаций:
    \[
      \begin{array}{l c l}
        \begin{array}{l}
        \readInst{a}{x}; \\
        \readInst{b}{y}
        \end{array}
        & \optarrow &
        \begin{array}{l}
        \readInst{b}{y}; \\
        \readInst{a}{x}
        \end{array}
      \end{array}
    \]
  \item Устранение избыточных обращений к памяти.
    Например, устранение инструкции чтения, следующей за инструкциями чтения или записи в ту же локацию:
    \[
    \begin{array}{c c c}
      \begin{array}{l c l}
        \begin{array}{l}
        \readInst{a}{x}; \\
        \readInst{b}{x}
        \end{array}
        & \optarrow &
        \begin{array}{l}
        \readInst{a}{x}; \\
        \assignInst{b}{a}
        \end{array}
      \end{array}
      & \qquad &
      \begin{array}{l c l}
        \begin{array}{l}
        \writeInst{x}{a}; \\
        \readInst{b}{x}
        \end{array}
        & \optarrow &
        \begin{array}{l}
        \writeInst{x}{a}; \\
        \assignInst{b}{a}
        \end{array}
      \end{array}
    \end{array}
    \]
  \item Вставка избыточных обращений к памяти. Например, вставка инструкции чтения в переменную,
    значение которой далее нигде не используется.
  \item Глобальные оптимизации. Например, \emph{секвенциализация} (sequentialization),
    которая заменяет параллельную композицию потоков на последовательную:
    \[
      \begin{array}{l c l}
      C_1\;||\;C_2 & \optarrow & C_1;\;C_2
      \end{array}
    \]
\end{enumerate}

Желательно, чтобы упомянутые классы оптимизаций были корректными,
возможно, с некоторыми оговорками
в модели памяти языка программирования.
Для этого модель должна быть достаточно слабой, т.е. позволять сценарии поведения, которые
возможны для программы после оптимизации.

\subsection{Наличие эффективной схемы компиляции}
\label{sec:overview:effcompl}
Модель памяти языка программирования должна учитывать модель памяти целевой платформы,
т.е. должна существовать корректная схема компиляции из одной модели в другую.

\begin{definition}
  \label{def:complCorrectness}
Пусть есть некоторые языки $\LL$ и $\LowLL$ и соответствующие модели памяти $\MM$ и $\LowMM$.
%% причём $\LL$ является исходным языком, а $\LowLL$ --- целевым для некоторой схемы компиляции $\complScheme : \LL \rightarrow \LowLL$.
Функция $\complScheme : \LL \rightarrow \LowLL$ является \emph{корректной схемой компиляции из модели $\MM$ в модель $\LowMM$},
если для любой программы $\PP$ на языке $\LL$ семантика программы $\complScheme(\PP)$ в модели $\LowMM$ является подмножеством
семантики $\PP$ в модели $\MM$.
\end{definition}

Из этого определения следует, что чем слабее модель целевой платформы, т.е. чем больше существует сценариев поведения на целевой платформе,
тем больше ограничений накладывается на корректную схему компиляции.

Рассмотрим то, как должна быть устроена корректная схема компиляции из более строгой модели памяти в более слабую на примере
компиляции ранее приведенной программы ${\rm MP}$ из модели SC~\cite{Lamport:TC79} в модель архитектуры Power~\cite{Alglave-al:TOPLAS14}.
В рамках модели SC программа ${\rm MP}$ не имеет сценария поведения $[a=1, b=0]$, тогда как в модели Power такой сценарий возможен.
Для того, чтобы получить корректную компиляцию, в скомпилированную программу нужно вставить специальные инструкции --- т.н. \emph{барьеры памяти}.
Эти барьеры вносят дополнительные ограничения на сценарии поведения программ.
Достигается это за счёт того, что барьеры запрещают некоторые компиляторные и процессорные оптимизации.
В архитектуре Power есть барьер $\hwsync$, который запрещает переупорядочивание любых инструкций вокруг него.
Вставка такого барьера между инструкций в программе ${\rm MP}$ гарантирует отсутствие сценария поведения $[a=1, b=0]$ в модели
Power\footnote{Здесь и далее в
  диссертации используется один и тот же синтаксис для описания как исходных, так и скомпилированных программ с точностью до барьеров и модификаторов чтения и записи.
%% Мы могли бы использовать ассемблероподобный синтаксис для последних, но в этом нет необходимости ввиду того, что .
}:
\begin{equation*}
\tag{MP-hwsync}\label{ex:MP-hwsync}
\begin{tabular}{c}
  $\writeInst{x}{0}; \writeInst{y}{0};$ \\
\begin{tabular}{L || L}
  \writeInst{x}{1}; & \readInst{a}{y}; \\
  \hwsync;          &  \hwsync;        \\
  \writeInst{y}{1}  & \readInst{b}{x} \\
\end{tabular}
\end{tabular}
\end{equation*}
На ряду с $\hwsync$ архитектура Power также предоставляет более слабый барьер $\lwsync$,
который запрещает только перестановки пар инструкций чтение-чтение, чтение-запись и запись-запись.
Такого барьера также достаточно, чтобы запретить сценарий $[a=1, b=0]$:
\begin{equation*}
\tag{MP-lwsync}\label{ex:MP-lwsync}
\begin{tabular}{c}
  $\writeInst{x}{0}; \writeInst{y}{0};$ \\
\begin{tabular}{L || L}
  \writeInst{x}{1}; & \readInst{a}{y}; \\
  \lwsync;          &  \lwsync;        \\
  \writeInst{y}{1}  & \readInst{b}{x} \\
\end{tabular}
\end{tabular}
\end{equation*}
В данном случае схема компиляции, использующая барьер $\lwsync$, является более предпочтительной по сравнению
со $\hwsync$-схемой, т.к. барьер $\lwsync$ на реальных процессорах исполняется быстрее
(или, как минимум, не медленнее), чем $\hwsync$.

Если рассмотреть модель памяти языка программирования, которая разрешает сценарий поведения 
с результатом $[a=1,b=0]$
(на ряду со всеми остальными сценариями, возможными в рамках модели SC), то для компиляции программы
${\rm MP}$ из такой модели в модель Power не будет необходимости вставлять барьеры памяти.
Это хорошо, т.к. скомпилированная программа может быть эффективно исполнена на целевом процессоре.
Так, модели C/C++11~\cite{Batty-al:POPL11} и Java~\cite{Manson-al:POPL05} разработаны таким образом, чтобы
обычные операции чтения и записи\footnote{В разделе \ref{sec:cppmodel} будут рассмотрены различные модификаторы, которыми могут
быть помечены инструкции работы с памятью в модели C/C++11, и ``обычные операции чтения и записи'' будут соответствовать
атомарным расслабленным и неатомарным инструкциям.
Все инструкции работы с памятью из примеров программ, приведённых к этому моменту, были ``обычными''.}
могли быть скомпилированы без вставки барьеров памяти в случае компиляции в платформы x86, Power и ARM.

Подобные схемы компиляции будут называться \emph{эффективными} в рамках данного исследования.
Соответственно, как было видно из рассмотренных схем компиляции из модели SC в модель Power,
для этих моделей не существует эффективной компиляции.
Очевидно, что для того, чтобы существовала эффективная схема компиляции из модели языка программирования в модель
целевой платформы, должно выполняться следующее утверждение:
модель исходного языка должна позволять все сценарии поведения для программы без барьеров,
которые позволяет целевая модель памяти для скомпилированной версии программы, в которой также не используются барьеры.
Аналогично требованию на корректность оптимизаций, наличие эффективной схемы компиляции
увеличивает число слабых поведений, допускаемых моделью языка программирования.

%% Поскольку барьеры памяти запрещают определенные оптимизации, их присутствие замедляет исполнение программ.
%% Для того, чтобы уменьшить такой эффект, но при этом сохранить корректность компиляции, 

%% [13] D. Marino, A. Singh, T. Millstein, M. Musuvathi, and
%%      S. Narayanasamy. A case for an SC-preserving compiler. In

\subsection{Гарантии программисту} %Отсутствие ``значений из воздуха''}
Требование о том, что модель памяти языка программирования должна предоставлять разумные
гарантии программисту звучит крайне неформально.
Попробуем сформулировать его более конкретно.

Очевидно, что программист должен иметь представление о том, как ведется себя программа, над
которой он работает, а поведение программы как раз определяется моделью памяти.
Как следствие, желательно, чтобы модель памяти была максимально простой и понятной,
а также существовал формальный инструментарий для рассуждения о программах в рамках модели.
Простота --- это очень субъективный критерий, особенно при сравнении слабых моделей памяти,
тогда как наличие и выразительная сила инструментов анализа может быть
использована для более точного сопоставления моделей.

Существуют различные методы для анализа программ.
Среди них стоит отметить методы \emph{проверки моделей} (model checking)~\cite{Peled-al:BOOK08,Clarke-al:BOOK99} и
\emph{верификации по Хоару} (Hoare logic)~\cite{Hoare:CACM69}.
Оба метода хорошо зарекомендовали себя в приложении к модели SC
\cite{Owicki-Gries:AI76,Owicki-Gries:CACM76,OHearn:CONCUR04,Bornat-al:POPL05,Hobor-al:ESOP08,Dockins-al:ENTCS08,
Hobor-Gherghina:ESOP11,Gotsman-al:APLAS07,Jacobs-Piessens:POPL11,Svendsen-Birkedal:ESOP14,DinsdaleYoung-al:ECOOP10,Jung-al:POPL15,
LeyWild-Nanevski:POPL13,Sergey-al:PLDI15,Vechev-al:STTT13,Raychev-al:SAS13}.
Существуют также работы, посвященные слабым моделям памяти
\cite{Kaiser-al:ECOOP17,Vafeiadis-Narayan:OOPSLA13,Turon-al:OOPSLA14,Lahav-Vafeiadis:ICALP15,Meshman-al:FMCAD15,Dan-al:SAS13}.
В последних отмечается, что если модель памяти разрешает сценарии поведения программ с т.н.
\emph{``значениями из воздуха''} (out-of-thin-air values, OOTA),
то класс свойств, которые могут быть проверены или доказаны для программ в
рамках таких моделей, существенным образом ограничивается.
В частности, модель памяти C/C++11 разрешает такие сценарии.

Что же такое ``значения из воздуха''? К сожалению, на данный момент не существует точного определения~\cite{Boehm-Demsky:MSPC14},
однако существует набор примеров таких поведений, а также следующий признак наличия ``значений из воздуха''.
Если в сценарии поведения программы, в которой нет арифметических выражений,
появляется некоторое значение (например, это значение присваивается переменной или записывается в память), причём это
значение явным образом не фигурирует в тексте программы, то такой сценарий обладает ``значениями из воздуха''.

Рассмотрим следующую программу \textrm{LB-OOTA}\label{acr:lb} (load buffering, буферизация чтения):
\begin{equation*}
\tag{LB-OOTA}\label{ex:LBoota}
\begin{tabular}{c}
  $\writeInst{x}{0}; \writeInst{y}{0};$ \\
\begin{tabular}{L || L}
  \readInst{a}{x};  & \readInst{b}{y}; \\
  \writeInst{y}{a} & \writeInst{x}{b} \\
\end{tabular}
\end{tabular}
\end{equation*}
В этой программе нет арифметических операций и $0$ является единственным значением,
которое явным образом встречается в тексте программы.
По приведенному выше признаку любой сценарий поведения этой программы,
в результате которого значение переменной $a$ или $b$ отличается от $0$,
обладает ``значением из воздуха''. Такие сценарии разрешаются для этой программы
в рамках модели C/C++11~\cite{Batty-al:POPL11}.

Рассмотрим другую программу, некоторые сценарии поведения которой в рамках
модели C/C++11 также считаются~\cite{Boehm-Demsky:MSPC14} обладающими
``значениями из воздуха'', но не подпадающую под сформулированный выше признак:
\begin{equation*}
\tag{IF-OOTA}\label{ex:IFoota}
\begin{tabular}{c}
  $\writeInst{x}{0}; \writeInst{y}{0};$ \\
\begin{tabular}{L || L}
  \readInst{a}{x}; & \readInst{b}{y}; \\
  \begin{array}{@{}l@{}}
  \iteml{a}{\writeInst{y}{1}}{\skipc}
  \end{array} &
  \begin{array}{@{}l@{}}
  \iteml{b}{\writeInst{x}{1}}{\skipc}
  \end{array} \\
\end{tabular}
\end{tabular}
\end{equation*}
Казалось бы, что единственным результатом исполнения этой программы может быть
$[a = 0, b = 0]$, но модель C/C++11 также разрешает $[a = 1, b = 1]$.

Сценарии поведения со ``значениями из воздуха'' всегда имеют некоторую
циклическую зависимость между встречаюшимися в них значениями.
Как следствие, они не проявляются на современных
процессорах\footnote{Сценарии поведения со ``значениями из воздуха''
проявляются на процессорах семейства DEC Alpha~\cite{DecAlpha},
но данная архитектура снята с производства.}
и не могут быть получены как результат разумной оптимизации.
То, что некоторые модели разрешают такие сценарии, обычно является
результатом того, что в рамках подхода, выбранного для задания модели,
тяжело или невозможно запретить ``значения из воздуха''
и, при этом, не запретить нужные оптимизации~\cite{Batty-al:ESOP15}.

%% Таким образом, критерий предоставления разумных гарантий программисту
%% со стороны модели памяти 


%% Если модель разрешает манипуляции над кодом, такие как перестановка инструкций, это означает, что семантика изначальной
%% программы в рамках модели должна включать себя 

%% , абсолютное большинство которых являются слабыми моделями.
%% Все эти модели являются слабыми.

%% Среди процессорных моделей стоит выделить модели архитектур x86~\cite{Sewell-al:CACM10,Owens-al:TPHOL09},
%% Power~\cite{Alglave-al:TOPLAS14,Sarkar-al:PLDI11} и ARM~\cite{Flur-al:POPL16,Pulte-al:POPL18}, т.к. данные архитектуры являются
%% наиболее распространенными на данный момент.

%% В последние годы научное сообщество в сотрудничестве с индустрией разработало множество моделей памяти, как для процессорных архитектур
%% (x86-TSO~\cite{Sewell-al:CACM10}, Power~\cite{Alglave-al:TOPLAS14}, ARM~\cite{Flur-al:POPL16,Pulte-al:POPL18}),
%% так и для языков программирования (Java~\cite{Manson-al:POPL05}, C/C++11~\cite{Batty-al:POPL11}).
%% Все эти модели являются слабыми.

\section{Существующие модели памяти языков программирования}
Среди моделей памяти, разработанных для языков программирования, есть как используемые на практике,
т.е. являющиеся частями стандартов языков~\cite{Gosling-al:BOOK96,JavaStandard,C:11,CPP:11}, так и теоретические~%
\cite{Crary-Sullivan:POPL15,Lamport:TC79,Boudol-al:EXPRESS12,Boudol-Petri:POPL09,PichonPharabod-Sewell:POPL16,Jeffrey-Riely:LICS16}.
Далее в этом разделе обсуждаются модели памяти языков Javа~\cite{JavaStandard} и C/C++~\cite{C:11,CPP:11},
выделяются их достоинства и недостатки, а также рассматривается, как упомянутые недостатки решаются в существующих
теоретических моделях.

\subsection{Виды моделей памяти}
На данный момент существует два основных подхода к описанию моделей памяти ---
\emph{аксиоматический} (декларативный) и \emph{операционный}, которые в некоторых работах смешиваются.
Аксиоматические модели памяти представляют сценарии поведения программ в виде графов, которые
должны соответствовать определенным аксиомам.
Модели памяти Java и C/C++, описанные ниже, являются примерами аксиоматических моделей.
Преимуществами аксиоматических моделей является относительная простота для задания глобальных
свойств сценария поведения программы,
таких как наличие некоторого тотального порядка над подмножестве событий (вершин графа)
определенного вида.
Также аксиоматические модели проще для представления в логических языках,
таких как Alloy~\cite{Jackson:Book06} и Rosette
\cite{Torlak-Bodik:Onward13,Torlak-Bodik:PLDI14}, что используется
для автоматического сравнения моделей~\cite{Wickerson-al:POPL17}
и генерации моделей по набору примеров~\cite{Bornholt-Torlak:PLDI17}.

Сценарий поведения в рамках операционных моделей представляется как
серия переходов некоторой абстрактной машины.
Преимуществом таких моделей является то, что они дают представление об исполнении программы.
Как следствие, между моделью памяти, которая обычно определяет поведение только подмножества языка, связанное с его многопоточной
компонентой, и описанием остальных конструкций языка имеется прослеживаемая связь, которую нужно дополнительно
устанавливать для аксиоматических моделей~\cite{Memarian-al:PLDI16}.
Также для большинства операционных моделей возможно разработать интерпретатор, что позволяет пошагово
отлаживать многопоточные алгоритмы.


\subsection{Модель памяти Java}
Впервые модель памяти для языка Java была представлена в стандарте 1996 года~\cite{Gosling-al:BOOK96}.
Эта модель обладала рядом фундаментальных недостатков~\cite{Pugh:JAVA99,Pugh:CPE00} и была заменена на
новую модель~\cite{Manson-al:POPL05}, которая дальше будет упоминаться как модель памяти Java, или
JMM\label{acr:jmm} (Java memory model).
Основной задачей при разработке JMM было разработать модель без ``значения из воздуха'',
но разрешить базовые компиляторные оптимизации.
К сожалению, JMM не удовлетворяет последнему требованию~\cite{Sevcik-Aspinall:ECOOP08}:
в рамках JMM некорректными являются оптимизации удаление чтения после чтения (redundant read after read elimination),
удаление чтения после записи (redundant read after write elimination),
удаление записи после чтения (redundant write after read elimination),
добавление неиспользуемого чтения (irrelevant read introduction) и другие.
%% Далее в этом разделе мы рассмотрим ключевые понятия модели.

Сценарий поведения программы в JMM представляется как граф, в котором вершинами
являются \emph{события} (actions, events), происходящие в памяти, а помеченными ребрами ---
отношения на событиях.
События бывают нескольких типов, из которых основными являются:
чтение, запись, захват замка (lock), высвобождение замка (unlock).
События чтения и записи, в свою очередь, бывают обычные (non-volatile) и \emph{синхронизирующие} (volatile).
Первые действуют на обычных локациях в памяти (переменных), тогда как синхронизирующие -- на
\emph{изменчивых} (volatile) локациях.
Изменчивые локации выделены как локации, посредством которых происходит синхронизация.

Отметим пять отношений, используемых в сценариях поведения JMM.
Первое отношение, \emph{программный порядок} (program order, $\lPO$),
для каждого потока является тотальным порядком на событиях, относящихся к этому потоку.
Второе отношение, \emph{``читает из''} (reads from, $\lRF$),
связывает событие записи с читающими из него событиями.
Третье отношение, \emph{синхронизационный порядок} (synchronization order, $\lSO$),
является тотальным порядком на синхронизирующих событиях
и событиях захвата и высвобождения замков; оно должно быть
согласовано с отношениями $\lPO$ и $\lRF$ на синхронизирующих событиях.
Четвёртое отношение, \emph{``синхронизируется с''} (synchronizes-with, $\lSW$),
связывает события $a$ и $b$, если $\lRF$ связывает $a$ и $b$ и эти события
действуют над изменчивой локацией, или если они связаны с помощью $\lSO$ и $a$
является высвобождением некоторого замка, а $b$ --- захватом этого же замка.
Пятое отношение, \emph{``предшествует''} (happens-before, $\lHB$),
является транзитивным замыканием объединения отношений $\lPO$ и $\lSW$;
именно это отношение определяет порядок
на событиях из определения \ref{def:datarace} для JMM.

Сценарий поведения в JMM считается корректным, если для него выполняются \emph{аксиомы} модели.
Одной из аксиом является то, что событие чтения не может читать из события записи,
если они связаны отношением $\lHB$ и существует событие записи в ту же локацию,
которое находится между ними в отношении $\lHB$.
Формально это можно выразить следующим образом:
$$
\begin{array}{l}
\forall r, w. \; \lRF(w, r) \land \lHB(w, r) \Rightarrow \\
\quad \not \exists w'. \; \lLOC(w) = \lLOC(w') \land \lHB(w, w') \land \lHB(w', r),
\end{array}$$
где $\lLOC$ --- это функция, которая по событию возвращает локацию, над которой событие оперирует.
В силу этой аксиомы JMM запрещает результат $[a = 1, b = 0]$ для версии программы ${\rm MP}$, в которой локация
$y$ помечена как изменчивая:
\begin{equation*}
\tag{MP-volatile}\label{ex:MPvolatile}
\begin{tabular}{c}
  $\writeInst{x}{0}; \writeInst{y}{0};$ \\
\begin{tabular}{L || L L}
  \writeInst{x}{1}; & \readInstVolatile{a}{y}; & \valuefail{1} \\
  \writeInstVolatile{y}{1} & \readInst{b}{x} & \valuefail{0} \\
\end{tabular}
\end{tabular}
\end{equation*}

\begin{figure}
\[
\begin{tikzpicture}[yscale=1,xscale=1.8]
  \node (01)  at (-2.5,2) {$p: \wlab{}{x}{0}$ };
  \node (02)  at (0,2) {$q: \wlab{volatile}{y}{0}$ };
  \node (1)  at (-2.5,1) {$r: \wlab{}{x}{1}$ };
  \node (2)  at (-2.5,0) {$s: \wlab{volatile}{y}{1}$ };
  \node (11) at (0,1)  {$t: \rlab{volatile}{y}{1}$ };
  \node (12) at (0,0)  {$u: \rlab{}{x}{0}$ };

  \draw[po] (1)  edge  (2);
  \draw[po] (11) edge (12);
  \draw[po] (01) edge (11);
  \draw[po] (02) edge (11);
  %% \draw[hb] (01) edge node[left] {\small $\lHB$} (1);
  \draw[po] (01) edge (1);
  \draw[po] (02) edge  (1);
  %% \draw[deps,bend left=20] (11)  edge node[right] {\small $\lDEPS$} (12);
  \draw[rf] (01)  edge node[above] {\small $\lRF$} (12);
  \draw[sw] (2)  edge node[below] {\small $\lSW$} (11);
  %% \draw[hb] (1) edge node[above] {\small $\lHB$} (12);
  %% \draw[mo,bend right=20] (01)  edge node[left] {\small $\lCO$} (1);
  %% \draw[mo,bend right=90] (02)  edge node[above] {} (2); %{\small $\lCO$} (2);
\end{tikzpicture}
\]
\caption{Сценарий программы ${\rm MP\text{-}volatile}$, который не соответствует
аксиомам модели JMM}
\label{fig:overview:jmmvolatile}
\end{figure}
Для того, чтобы проверить предыдущее утверждение, рассмотрим соответствующий
сценарий поведения
(см. рис. \ref{fig:overview:jmmvolatile}).
В его графе имеется шесть событий.
События $p$ и $q$ являются инициализирующим записям в локации $x$ и $y$,
а остальные --- инструкциям из ${\rm MP\text{-}volatile}$.
Недописанные дуги --- это дуги отношения $\lPO$.
На рис. \ref{fig:overview:jmmvolatile} опущены дуги отношения $\lHB$,
связывающие $p$ и $r$ ($\lPO \suq \lHB$), а также $r$ и $u$ (т.к. $\lPO(r, s)$, $\lSW(s, t)$, $\lPO(t,u)$ и
$\lHB = (\lPO \cup \lSW)^{+}$).
Таким образом, данный граф противоречит приведенной выше аксиоме и не является корректным в JMM.

Отметим, что если бы локация $y$ не была бы помечена как изменчивая, то события $s$ и $t$ имели бы
обычный тип и между ними бы не было ребра $\lSW$, следовательно аксиома бы выполнялась и результат $[a = 1, b = 0]$
был бы возможен.

%% Сценарий поведения программы в JMM представляется как кортеж следующего вида:
%% $$
%% \tup{P, A, \xrightarrow{po}, \xrightarrow{so}, W, V, \xrightarrow{sw}, \xrightarrow{hb}},
%% $$
%% где $P$ --- программа, $A$ --- множество событий (actions, events), $\xrightarrow{}$

%% В JMM локации в памяти (или переменные) разделяются на два типа: \emph{обычные} (normal) и \emph{изменчивые} (volatile).

Для того, чтобы запретить ``значения из воздуха'', в JMM используется процесс
валидации сценариев.
В рамках этого процесса строится серия сценариев, каждый из которых является корректным с точки зрения аксиом JMM,
при этом последним в серии является валидируемый сценарий.
Также каждому сценарию в серии присваивается множество добавленных (committed) событий.
Эти множества монотонно растут, а последнее является множеством всех событий в графе валидируемого сценария.
При этом на каждом шаге трансформации в серии сохраняется подмножество отношения $\lHB$, заданное на добавленных
событиях.

В~\cite{Sevcik-Aspinall:ECOOP08} показывается, что именно из-за процесса валидации упомянутые выше оптимизации
некорректны в JMM.

\subsection{Модель памяти C/C++}
\label{sec:cppmodel}
В последние годы научное сообщество уделяет особое внимание модели памяти C/C++,
которая появилась в стандартах языков в 2011 году~\cite{C:11,CPP:11}.
Она не претерпела существенных изменений в последующих стандартах 2014~\cite{CPP:14} и 2017~\cite{CPP:17} годов,
и поэтому в литературе обычно не различают понятия ``модель памяти C/C++'' и ``модель памяти C/C++11''.
Далее в работе используется ``модель памяти C/C++11'' или ``C/C++11 MM''\label{acr:cppmm}.

Базовым результатом о свойствах этой модели является её формализация, представленная 
в~\cite{Batty-al:POPL11}; далее под C/C++11 MM будет подразумеваться именно эта формализация.
Существуют работы, посвященные корректности компиляции и оптимизаций
\cite{Batty-al:POPL12,Vafeiadis-al:POPL15,Chakraborty-Vafeiadis:CGO16,Lahav-al:PLDI17,Batty-al:POPL16},
логикам для формальных рассуждений о программах
\cite{Turon-al:OOPSLA14,Vafeiadis-Narayan:OOPSLA13,Lahav-Vafeiadis:ICALP15,Doko-Vafeiadis:VMCAI16,Vafeiadis:CPP15}
и другим свойствам этой модели
\cite{Batty-al:POPL13,Batty-al:ESOP15,Lidbury-Donaldson:POPL17, Tassarotti-al:PLDI15,Doko-Vafeiadis:ESOP17}.
Как следствие, C/C++11 MM является одной из самых проработанных моделей памяти для языков программирования.
Тем не менее, она не лишена недостатков, в том числе ``значений из воздуха''.

\subsubsection{Виды обращений к памяти}
В C/C++11 MM локации бывают двух типов --- неатомарные (non-atomic) и атомарные (atomic).
В отличие от языка Java, разделение между ними менее строгое,
т.к. языки C/C++ разрешают преобразование типов, следовательно
на один и тот же адрес в памяти может ссылаться две переменных в программе, одна из которых будет
иметь атомарный тип, а другая --- неатомарный.
Поэтому в C/C++11 MM обращения к одной и той же локации могут быть как неатомарными, так и атомарными.
Последние, в свою очередь, также подразделяются на несколько категорий в зависимости от типа обращения ---
чтение, запись или одновременное чтение-запись (RMW, read-modify-write)\label{acr:rmw}.
Описание RMW опущено для краткости.

Событие чтения может быть неатомарным, \emph{расслабленным} (relaxed, $\rlx$),
\emph{потребляющим} (consume, $\con$), \emph{приобретающим} (acquire, $\acq$)
или \emph{последовательно-консистентным} (sequentially-consistent, $\sco$).
Событие записи может быть неатомарным, расслабленным,
\emph{высвобождающим} (release, $\rel$)
или последовательно-консистентным.
В обоих случаях виды обращений упорядочены по величине предоставляемых гарантий.
Так, расслабленные обращения похожи на обычные обращения в модели JMM, тогда как
последовательно-консистентные --- на синхронизирующие.
Неатомарные обращения предоставляют наименьшие гарантии: если неатомарное обращение
является частью гонки по данным, то в C/C++11 MM программа имеет неопределенное поведение.
Приобретающее чтение и высвобождающая запись могут быть использованы для того,
чтобы запретить результат $[a = 1, b = 0]$ (аналогично синхронизирующим
обращениям в случае JMM): %(см. рис. \ref{fig:MPrelAcq}).
%% \begin{figure}
\begin{equation*}
\label{ex:MPrelAcq}
\begin{tabular}{c}
  $\writeInstParam{\rlx}{x}{0}; \writeInstParam{\rlx}{y}{0};$ \\
\begin{tabular}{L || L L}
  \writeInstParam{\rlx}{x}{1}; & \readInstParam{\acq}{a}{y}; & \valuefail{1} \\
  \writeInstParam{\rel}{y}{1} & \readInstParam{\rlx}{b}{x} & \valuefail{0} \\
\end{tabular}
\end{tabular}
\end{equation*}
%% \caption{Программа ${\rm MP\text{-}rel\text{-}acq}$}
%% \label{fig:MPrelAcq}
%% \end{figure}
При этом в отличие от синхронизирующих обращений JMM и $\sco$-обращений C/C++11 MM
на высвобождающих и приобретающих событиях не существует тотального порядка,
учитывающего программный порядок, и, как следствие, следующая программа,
использующая высвобождающие записи, имеет сценарий поведения с результатом $[a = 1, b = 1]$:
\begin{equation*}
\tag{2W-rel}\label{ex:WWrel}
\begin{array}{c}
\begin{tabular}{L || L}
  \writeInstParam{\rel}{x}{1}; & \writeInstParam{\rel}{y}{1}; \\
  \writeInstParam{\rel}{y}{2} & \writeInstParam{\rel}{x}{2} \\
\end{tabular} \\
\readInstParam{\sco}{a}{x}; \valuecom{1} \\
\readInstParam{\sco}{b}{y}~ \valuecom{1}
\end{array}
\end{equation*}
В то же время эта программа с $\sco$-записями такого сценария не имеет:
\begin{equation*}
\tag{2W-sc}\label{ex:WWsc}
\begin{array}{c}
\begin{tabular}{L || L}
  \writeInstParam{\sco}{x}{1}; & \writeInstParam{\sco}{y}{1}; \\
  \writeInstParam{\sco}{y}{2} & \writeInstParam{\sco}{x}{2} \\
\end{tabular} \\
\readInstParam{\sco}{a}{x}; \valuefail{1} \\
\readInstParam{\sco}{b}{y}~ \valuefail{1}
\end{array}
\end{equation*}

Инструкция высвобождающей записи не может быть переставлена инструкциями записями, предшествующими ей
в программном порядке, ни на этапе компиляции, ни во время исполнения программ.
Как следствие, гарантируется, что поток, который с помощью инструкции приобретающего чтения
прочитает из высвобождающей записи, будет осведомлён о предшествующих ей записях.
Аналогично, инструкция приобретающего чтения не может быть переставлена
с последующими чтениями.

Инструкция потребляющего (consume, $\con$) чтения является
ослабленной версией инструкции приобретающего чтения и предоставляет те же гарантии,
но  только для последующих чтений, которые зависят по данным от потребляющего.
Так, потребляющего чтени будет недостаточно,
чтобы гарантировать отсутствие сценария поведения $[a = 1, b = 0]$ в версии программы
${\rm MP\text{-}rel\text{-}acq}$, в которой $\acq$-чтение заменено на $\con$-чтение.
Тем не менее, $\con$-чтения будет достаточно,
чтобы гарантировать отсутствие сценария поведения $[a = y, b = 0]$ в следующей программе:
\begin{equation*}
\tag{MP-addr-con}\label{ex:MPaddrCon}
\begin{array}{c}
\writeInst{x}{0};
\writeInst{y}{0};
\writeInst{z}{x}; \\
\begin{tabular}{L || L L}
  \writeInstParam{\rlx}{y}{1}; & \readInstParam{\con}{a}{z}; & \valuefail{y} \\
  \writeInstParam{\rel}{z}{y} & \readInstParam{\rlx}{b}{a} & \valuefail{0} \\
\end{tabular}
\end{array}
\end{equation*}

%% В целом, модель С/C++11 предоставляет большую по сравнению с JMM вариативность в смысле обращений

\subsubsection{Сценарии поведения}
Аналогично модели JMM, в C/C++11 MM сценарий поведения программы представляется в виде графа,
вершинами которого являются события над памятью.
%% Каждое событие обладает соответствующей пометкой.
%% Так, например, для события чтения указывается его вид, целевая локация и прочитанное значение.
%% В сценариях поведения, также как и в JMM, фигурируют
Также в сценариях поведения фигурируют
отношения программного порядка $\lPO$, ``читает из'' $\lRF$, ``синхронизируется с'' $\lSW$
и ``предшествует'' $\lHB$.
При этом $\lSW$ и $\lHB$ определяются по-другому.
Так, в частности, $\lSW$ включает в себя подмножество $\lRF$,
связывающее высвобождающие записи с приобретающими чтениями, а $\lHB$ является транзитивным замыканием объединения
$\lPO$ и $\lSW$ в отсутствии $\con$-чтений (с ними определение становится сложнее).
Дополнительно в модели используются два важных отношения --- $\lMO$ и $\lSC$.
Отношение $\lMO$ (\emph{порядок памяти}, memory order, coherence order)
для каждой локации является полным порядком на событиях записи в неё.
Отношение $\lSC$ (sequential consistency order) является полным порядком
на всех $\sco$-событиях в сценарии поведения.

Также, как и в случае JMM, для C/C++11 MM определяются аксиомы, которые ограничивают пространство возможных сценариев поведения.
Полный список аксиом представлен в~\cite{Batty-al:POPL11, Vafeiadis-Narayan:OOPSLA13}.
Отличием от JMM является то, что в C/C++11 MM не используется процесс верификации исполнения.
В итоге, с одной стороны, C/C++11 MM допускает поведения со ``значениями из воздуха'',
но, с другой стороны, поддерживает большее число компиляторных оптимизаций.

\subsubsection{Построение сценариев поведения по программе}
Построение сценариев поведения в C/C++11 MM состоит из трёх следующих этапов.
На первом этапе для программы строится множество т.н. \emph{предзапусков} (preexecutions) --- частичных графов сценариев
поведения, в которых присутствует только отношение $\lPO$
(аналогичный процесс для аксиоматической модели ARMv8.3~\cite{Pulte-al:POPL18} представлен в приложении \ref{app:comptopreexec}).
При этом, поскольку события чтения не связываются с событиями записи, для каждого события чтения
прочитанное значение выбирается недетерминировано.
В частности, среди предзапусков программы ${\rm MP\text{-}rel\text{-}acq}$
присутствует граф, изображенный на рис. \ref{fig:overview:predex}.
\begin{figure}
\[
\begin{tikzpicture}[yscale=1,xscale=1.8]
  \node (01)  at (-2,2) {$p: \wlab{\rlx}{x}{0}$ };
  \node (02)  at (0,2) {$q: \wlab{\rlx}{y}{0}$ };
  \node (1)  at (-2,1) {$r: \wlab{\rlx}{x}{1}$ };
  \node (2)  at (-2,0) {$s: \wlab{\rel}{y}{1}$ };
  \node (11) at (0,1)  {$t: \rlab{\acq}{y}{5}$ };
  \node (12) at (0,0)  {$u: \rlab{\rlx}{x}{9}$ };

  \draw[po] (1)  edge  (2);
  \draw[po] (11) edge (12);
  \draw[po] (01) edge (11);
  \draw[po] (02) edge (11);
  %% \draw[hb] (01) edge node[left] {\small $\lHB$} (1);
  \draw[po] (01) edge (1);
  \draw[po] (02) edge  (1);
  %% \draw[deps,bend left=20] (11)  edge node[right] {\small $\lDEPS$} (12);
  %% \draw[hb] (1) edge node[above] {\small $\lHB$} (12);
  %% \draw[mo,bend right=20] (01)  edge node[left] {\small $\lCO$} (1);
  %% \draw[mo,bend right=90] (02)  edge node[above] {} (2); %{\small $\lCO$} (2);
\end{tikzpicture}
\]
\caption{Предзапуск программы ${\rm MP\text{-}rel\text{-}acq}$}
\label{fig:overview:predex}
\end{figure}

На втором этапе в каждый предзапуск недетерминировано добавляются дуги отношений $\lRF$, $\lSC$ и $\lMO$, по
которым также вычисляются производные отношения, такие как $\lSW$ и $\lHB$.
Полученные графы проверяются на базовую корректность.
В частности, проверяется, что если из события $e$ идёт $\lRF$-дуга в $f$,
то $e$ является событием записи, $f$ --- чтения, они оперируют над одной и той же локацией,
и прочитанное значение равняется записанному.
После второго этапа во множестве полученных сценариев поведения для программы ${\rm MP\text{-}rel\text{-}acq}$
появляется сценарий поведения, изображенный на рис. \ref{fig:overview:mprelacqexec}
(некоторые ребра в нём опущены).
\begin{figure}
\[
\begin{tikzpicture}[yscale=1,xscale=1.8]
  \node (01)  at (-2,3) {$p: \wlab{\rlx}{x}{0}$ };
  \node (02)  at (0,3) {$q: \wlab{\rlx}{y}{0}$ };
  \node (1)  at (-2,1.5) {$r: \wlab{\rlx}{x}{1}$ };
  \node (2)  at (-2,0) {$s: \wlab{\rel}{y}{1}$ };
  \node (11) at (0,1.5)  {$t: \rlab{\acq}{y}{1}$ };
  \node (12) at (0,0)  {$u: \rlab{\rlx}{x}{0}$ };

  \draw[po] (1)  edge  (2);
  \draw[po] (11) edge (12);
  \draw[po] (01) edge (11);
  \draw[po] (02) edge (11);
  \draw[hb] (01) edge node[right] {\small $\lHB$} (1);
  %% \draw[po] (01) edge (1);
  \draw[po] (02) edge  (1);
  %% \draw[deps,bend left=20] (11)  edge node[right] {\small $\lDEPS$} (12);
  \draw[sw] (2) edge node[above] {\small $\lSW$} (11);
  \draw[hb] (1) edge node[below] {\small $\lHB$} (12);
  \draw[mo,bend right=20] (01)  edge node[left] {\small $\lMO$} (1);
  \draw[mo,bend right=90] (02)  edge node[above] {} (2); %{\small $\lCO$} (2);
\end{tikzpicture}
\]
\caption{Сценарий поведения программы ${\rm MP\text{-}rel\text{-}acq}$,
прошедший базовую проверку на корректность}
\label{fig:overview:mprelacqexec}
\end{figure}

На третьем этапе полученные сценарии поведения проверяются на соответствие аксиомам C/C++11 MM.
Одна из таких аксиом аналогична приведённой выше для JMM:
$$
\begin{array}{l}
\forall r, w. \; \lRF(w, r) \land \lHB(w, r) \Rightarrow \\
\quad \not \exists w'. \; \lCO(w,w') \land \lHB(w, w') \land \lHB(w', r).
\end{array}
$$
Данная аксиома не выполняется для последнего приведенного сценария,
и, как следствие, программа ${\rm MP\text{-}rel\text{-}acq}$ имеет только три корректных
сценария поведения в рамках C/C++11 MM (см. рис. \ref{fig:MPrelAcqSem}),
соответствующих результатам $[a=0, b = 0]$, $[a = 0, b = 1]$ и $[a = 1, b = 1]$.

\newcommand{\smallLabelFont}{\scriptsize}

\begin{figure}
  \begin{tabular}{c c c}
\begin{tikzpicture}[yscale=1,xscale=1]
  \node (01)  at (-2.5,3) {\smallLabelFont $p: \wlab{\rlx}{x}{0}$ };
  \node (02)  at (0,3) {\smallLabelFont$q: \wlab{\rlx}{y}{0}$ };
  \node (1)  at (-2.5,1.5) {\smallLabelFont$r: \wlab{\rlx}{x}{1}$ };
  \node (2)  at (-2.5,0) {\smallLabelFont$s: \wlab{\rel}{y}{1}$ };
  \node (11) at (0,1.5)  {\smallLabelFont$t: \rlab{\acq}{y}{0}$ };
  \node (12) at (0,0)  {\smallLabelFont$u: \rlab{\rlx}{x}{0}$ };

  \draw[po] (1)  edge  (2);
  \draw[po] (11) edge (12);
  \draw[po] (01) edge (11);
  \draw[po] (02) edge (11);
  %% \draw[hb] (01) edge node[right] {\smallLabelFont $\lHB$} (1);
  \draw[po] (01) edge (1);
  \draw[po] (02) edge  (1);
  %% \draw[deps,bend left=20] (11)  edge node[right] {\small $\lDEPS$} (12);
  %% \draw[sw] (2) edge node[above] {\smallLabelFont $\lSW$} (11);
  %% \draw[hb] (1) edge node[below] {\smallLabelFont $\lHB$} (12);
  \draw[rf,bend left=20] (02) edge node[right] {\smallLabelFont $\lRF$} (11);
  \draw[rf] (01) edge node[below] {\smallLabelFont $\lRF$} (12);
  \draw[mo,bend right=20] (01)  edge node[left] {\smallLabelFont $\lMO$} (1);
  \draw[mo,bend right=90] (02)  edge node[above] {} (2); %{\small $\lCO$} (2);
\end{tikzpicture}
 &
\begin{tikzpicture}[yscale=1,xscale=1]
  \node (01)  at (-2.5,3) {\smallLabelFont $p: \wlab{\rlx}{x}{0}$ };
  \node (02)  at (0,3) {\smallLabelFont$q: \wlab{\rlx}{y}{0}$ };
  \node (1)  at (-2.5,1.5) {\smallLabelFont$r: \wlab{\rlx}{x}{1}$ };
  \node (2)  at (-2.5,0) {\smallLabelFont$s: \wlab{\rel}{y}{1}$ };
  \node (11) at (0,1.5)  {\smallLabelFont$t: \rlab{\acq}{y}{0}$ };
  \node (12) at (0,0)  {\smallLabelFont$u: \rlab{\rlx}{x}{1}$ };

  \draw[po] (1)  edge  (2);
  \draw[po] (11) edge (12);
  \draw[po] (01) edge (11);
  \draw[po] (02) edge (11);
  \draw[po] (01) edge (1);
  \draw[po] (02) edge  (1);
  %% \draw[deps,bend left=20] (11)  edge node[right] {\small $\lDEPS$} (12);
  \draw[rf,bend left=20] (02) edge node[right] {\smallLabelFont $\lRF$} (11);
  \draw[rf] (1)  edge node[below] {\smallLabelFont $\lRF$} (12);
  \draw[mo,bend right=20] (01)  edge node[left] {\smallLabelFont $\lMO$} (1);
  \draw[mo,bend right=90] (02)  edge node[above] {} (2); %{\small $\lCO$} (2);
\end{tikzpicture}
 &
\begin{tikzpicture}[yscale=1,xscale=1]
  \node (01)  at (-2.5,3) {\smallLabelFont $p: \wlab{\rlx}{x}{0}$ };
  \node (02)  at (0,3) {\smallLabelFont$q: \wlab{\rlx}{y}{0}$ };
  \node (1)  at (-2.5,1.5) {\smallLabelFont$r: \wlab{\rlx}{x}{1}$ };
  \node (2)  at (-2.5,0) {\smallLabelFont$s: \wlab{\rel}{y}{1}$ };
  \node (11) at (0,1.5)  {\smallLabelFont$t: \rlab{\acq}{y}{1}$ };
  \node (12) at (0,0)  {\smallLabelFont$u: \rlab{\rlx}{x}{1}$ };

  \draw[po] (1)  edge  (2);
  \draw[po] (11) edge (12);
  \draw[po] (01) edge (11);
  \draw[po] (02) edge (11);
  %% \draw[hb] (01) edge node[right] {\smallLabelFont $\lHB$} (1);
  \draw[po] (01) edge (1);
  \draw[po] (02) edge  (1);
  %% \draw[deps,bend left=20] (11)  edge node[right] {\small $\lDEPS$} (12);
  \draw[rf] (2) edge node[right] {} (11);
  \draw[rf] (1) edge node[below] {\smallLabelFont $\lRF$} (12);
  \draw[mo,bend right=20] (01)  edge node[left] {\smallLabelFont $\lMO$} (1);
  \draw[mo,bend right=90] (02)  edge node[above] {} (2); %{\small $\lCO$} (2);
\end{tikzpicture}
  \end{tabular}
  \caption{Сценарии поведения программы ${\rm MP\text{-}rel\text{-}acq}$ в C/C++11 MM}
  \label{fig:MPrelAcqSem}
\end{figure}

\subsubsection{Проблема ``значений из воздуха''}
Для того, чтобы понять, откуда берется проблема ``значений из воздуха'' в C/C++11 MM,
рассмотрим программу, которая уже была обсуждена ранее:
\begin{equation*}
\tag{IF-OOTA-rlx}
\begin{tabular}{c}
  $\writeInstParam{\rlx}{x}{0}; \writeInstParam{\rlx}{y}{0};$ \\
\begin{tabular}{L || L}
  \readInstParam{\rlx}{a}{x}; & \readInstParam{\rlx}{b}{y}; \\
  \begin{array}{@{}l@{}}
  \iteml{a}{\writeInstParam{\rlx}{y}{1}}{\skipc}
  \end{array} &
  \begin{array}{@{}l@{}}
  \iteml{b}{\writeInstParam{\rlx}{x}{1}}{\skipc}
  \end{array} \\
\end{tabular}
\end{tabular}
\end{equation*}

\begin{figure}
\[
\begin{tikzpicture}[yscale=1,xscale=1]
  \node (01)  at (-3.5,3) {$p: \wlab{\rlx}{x}{0}$ };
  \node (02)  at (0,3) {$q: \wlab{\rlx}{y}{0}$ };
  \node (1)  at (-3.5,1.5) {$r: \rlab{\rlx}{x}{1}$ };
  \node (2)  at (-3.5,0) {$s: \wlab{\rlx}{y}{1}$ };
  \node (11) at (0,1.5)  {$t: \rlab{\rlx}{y}{1}$ };
  \node (12) at (0,0)  {$u: \wlab{\rlx}{x}{1}$ };

  \draw[po] (1)  edge  (2);
  \draw[po] (11) edge (12);
  \draw[po] (01) edge (11);
  \draw[po] (02) edge (11);
  %% \draw[hb] (01) edge node[right] {\smallLabelFont $\lHB$} (1);
  \draw[po] (01) edge (1);
  \draw[po] (02) edge  (1);
  %% \draw[deps,bend left=20] (11)  edge node[right] {\small $\lDEPS$} (12);
  %% \draw[sw] (2) edge node[above] {\smallLabelFont $\lSW$} (11);
  %% \draw[hb] (1) edge node[below] {\smallLabelFont $\lHB$} (12);
  \draw[rf] (2) edge node[below] {\small $\lRF$} (11);
  \draw[rf] (12) edge node[left] {} (1);
  %% \draw[rf] (01) edge node[below] {\smallLabelFont $\lRF$} (12);
  %% \draw[mo,bend right=20] (01)  edge node[left] {\smallLabelFont $\lMO$} (1);
  %% \draw[mo,bend right=90] (02)  edge node[above] {} (2); %{\small $\lCO$} (2);
\end{tikzpicture}
\]
\caption{Сценарий поведения программы ${\rm IF\text{-}OOTA\text{-}rlx}$}
\label{fig:overview:ootaexec}
\end{figure}

Одним из корректных сценариев поведения этой программы в C/C++ MM является граф,
изображённый на рис. \ref{fig:overview:ootaexec}.
Он обладает ``значениями из воздуха'', т.к. соответствует результату $[a = 1, b = 1]$.
В данном случае очевидно, что у события $r$ есть циклическая зависимость
от себя самого --- для того, чтобы событие $r$ прочитало $1$, событие $u$ должно записать $1$,
и это возможно только если событие $t$ прочитало значение $1$, которое должно была быть записано событием $s$,
которое случается только если $r$ прочитало $1$!

Мы могли бы попробовать решить данную проблему, добавив в граф отношение зависимости по управлению $\lCTRL$
с рёбрами $(r, s)$ и $(t, u)$, а также дополнительную аксиому, которая требовала бы ацикличности
объединения отношений $\lCTRL$ и $\lRF$.
Тогда в приведенном графе был бы цикл $[r, s, t, u, r]$, и сценарий считался бы некорректным с точки
зрения модифицированной модели.

К сожалению, такое решение является неудовлетворительным с точки зрения задач C/C++11 MM.
Рассмотрим следующую программу:
\begin{equation*}
\tag{IF-notOOTA-rlx}
\begin{tabular}{c}
  $\writeInstParam{\rlx}{x}{0}; \writeInstParam{\rlx}{y}{0};$ \\
\begin{tabular}{L || L}
  \readInstParam{\rlx}{a}{x}; & \readInstParam{\rlx}{b}{y}; \\
  \begin{array}{@{}l@{}}
  \iteml{a}{\writeInstParam{\rlx}{y}{1}}{\writeInstParam{\rlx}{y}{1}}
  \end{array} &
  \begin{array}{@{}l@{}}
  \iteml{b}{\writeInstParam{\rlx}{x}{1}}{\skipc}
  \end{array} \\
\end{tabular}
\end{tabular}
\end{equation*}
Она отличается от ${\rm IF\text{-}OOTA\text{-}rlx}$ тем, что
ветка $\kw{else}$ в первом потоке содержит инструкцию записи $\writeInstParam{\rlx}{y}{1}$.
Наличие этой инструкции позволяет компилятору сделать вывод о том,
что инструкция $\writeInstParam{\rlx}{y}{1}$ не зависит от условия конструкции $\kw{if}$,
следовательно может быть вынесена из этой конструкции.
Далее вынесенная операция может быть переупорядочена с независимым чтением $\readInstParam{\rlx}{a}{x}$:
%% {\small
\begin{equation*}
\tag{IF-notOOTA-optimized}
\begin{tabular}{c}
  $\writeInstParam{\rlx}{x}{0}; \writeInstParam{\rlx}{y}{0};$ \\
\begin{tabular}{L || L}
  \writeInstParam{\rlx}{y}{1}; & \readInstParam{\rlx}{b}{y}; \\
  \readInstParam{\rlx}{a}{x}
  &
      \begin{array}{@{}l@{}}
      \iteml{b}{\writeInstParam{\rlx}{x}{1}}{\skipc}
      \end{array}
  \\
\end{tabular}
\end{tabular}
\end{equation*}
%% }
Для получившейся программы результат $[a = 1, b = 1]$ возможен также и в модели SC.

Таким образом для того, чтобы разрешить использованные трансформации,
C/C++11 MM должна разрешать результат $[a = 1, b = 1]$ для программы
${\rm IF\text{-}notOOTA\text{-}rlx}$.
Это означает, что предложенное ранее ``исправление'' модели не может быть напрямую использовано, т.к.
добавление зависимостей по управлению в граф и дополнительной аксиомы в модель сделает результат
$[a = 1, b = 1]$ некорректным для ${\rm IF\text{-}notOOTA\text{-}rlx}$.

Рассмотрим, в чём заключается разница между зависимостями по управлению в левых потоках программ 
${\rm IF\text{-}OOTA\text{-}rlx}$ и ${\rm IF\text{-}notOOTA\text{-}rlx}$.
В обоих случаях присутствует синтаксическая зависимость инструкции $\writeInstParam{\rlx}{y}{1}$ от
$\readInstParam{\rlx}{a}{x}$, но семантическая зависимость имеется
только в программе ${\rm IF\text{-}OOTA\text{-}rlx}$.
Соответственно, проблема могла бы быть решена, если бы в граф сценария поведения была добавлена
семантическая зависимость по управлению~\cite{Batty-Sewell:WNote14}.
%% К сожалению, в для более сложных программ наличие семантической зависимости по управлению
%% требует детального анализа.
В следующем разделе рассмотрены существующие на данный момент способы представления семантической зависимости.

%% Как следствие, эта программа имеет три корректных сценария поведения (см. Рис. \ref{fig:ifOOTASem}).
%% \begin{figure}
%% \begin{center}
%% \begin{tabular}{c c c}
%% \begin{tikzpicture}[yscale=1,xscale=1]
%%   \node (01)  at (-2.5,3) {\smallLabelFont $p: \wlab{\rlx}{x}{0}$ };
%%   \node (02)  at (0,3) {\smallLabelFont$q: \wlab{\rlx}{y}{0}$ };
%%   \node (1)  at (-2.5,1.5) {\smallLabelFont$r: \rlab{\rlx}{x}{0}$ };
%%   \node (2)  at (-2.5,0) {\smallLabelFont$s: \wlab{\rlx}{y}{1}$ };
%%   \node (11) at (0,1.5)  {\smallLabelFont$t: \rlab{\rlx}{y}{0}$ };
%%   %% \node (12) at (0,0)  {\smallLabelFont$u: \wlab{\rlx}{x}{1}$ };

%%   \draw[po] (1)  edge  (2);
%%   %% \draw[po] (11) edge (12);
%%   \draw[po] (01) edge (11);
%%   \draw[po] (02) edge (11);
%%   %% \draw[hb] (01) edge node[right] {\smallLabelFont $\lHB$} (1);
%%   \draw[po] (01) edge (1);
%%   \draw[po] (02) edge  (1);
%%   %% \draw[deps,bend left=20] (11)  edge node[right] {\small $\lDEPS$} (12);
%%   %% \draw[sw] (2) edge node[above] {\smallLabelFont $\lSW$} (11);
%%   %% \draw[hb] (1) edge node[below] {\smallLabelFont $\lHB$} (12);
%%   \draw[rf,bend left=20] (02) edge node[right] {\smallLabelFont $\lRF$} (11);
%%   \draw[rf,bend right=20] (01) edge node[left] {\smallLabelFont $\lRF$} (1);
%%   %% \draw[rf] (01) edge node[below] {\smallLabelFont $\lRF$} (12);
%%   %% \draw[mo,bend right=20] (01)  edge node[left] {\smallLabelFont $\lMO$} (1);
%%   %% \draw[mo,bend right=90] (02)  edge node[above] {} (2); %{\small $\lCO$} (2);
%% \end{tikzpicture}
%%  &
%% \begin{tikzpicture}[yscale=1,xscale=1]
%%   \node (01)  at (-2.5,3) {\smallLabelFont $p: \wlab{\rlx}{x}{0}$ };
%%   \node (02)  at (0,3) {\smallLabelFont$q: \wlab{\rlx}{y}{0}$ };
%%   \node (1)  at (-2.5,1.5) {\smallLabelFont$r: \rlab{\rlx}{x}{0}$ };
%%   \node (2)  at (-2.5,0) {\smallLabelFont$s: \wlab{\rlx}{y}{1}$ };
%%   \node (11) at (0,1.5)  {\smallLabelFont$t: \rlab{\rlx}{y}{1}$ };
%%   \node (12) at (0,0)  {\smallLabelFont$u: \wlab{\rlx}{x}{1}$ };

%%   \draw[po] (1)  edge  (2);
%%   \draw[po] (11) edge (12);
%%   \draw[po] (01) edge (11);
%%   \draw[po] (02) edge (11);
%%   %% \draw[hb] (01) edge node[right] {\smallLabelFont $\lHB$} (1);
%%   \draw[po] (01) edge (1);
%%   \draw[po] (02) edge  (1);
%%   %% \draw[deps,bend left=20] (11)  edge node[right] {\small $\lDEPS$} (12);
%%   %% \draw[sw] (2) edge node[above] {\smallLabelFont $\lSW$} (11);
%%   %% \draw[hb] (1) edge node[below] {\smallLabelFont $\lHB$} (12);
%%   \draw[rf,bend right=20] (01) edge node[left] {\smallLabelFont $\lRF$} (1);
%%   \draw[rf] (2) edge node[below] {\smallLabelFont $\lRF$} (11);
%%   %% \draw[rf] (12) edge node[left] {} (1);
%%   %% \draw[rf] (01) edge node[below] {\smallLabelFont $\lRF$} (12);
%%   %% \draw[mo,bend right=20] (01)  edge node[left] {\smallLabelFont $\lMO$} (1);
%%   %% \draw[mo,bend right=90] (02)  edge node[above] {} (2); %{\small $\lCO$} (2);
%% \end{tikzpicture}
%%  &
%% \begin{tikzpicture}[yscale=1,xscale=1]
%%   \node (01)  at (-2.5,3) {\smallLabelFont $p: \wlab{\rlx}{x}{0}$ };
%%   \node (02)  at (0,3) {\smallLabelFont$q: \wlab{\rlx}{y}{0}$ };
%%   \node (1)  at (-2.5,1.5) {\smallLabelFont$r: \rlab{\rlx}{x}{1}$ };
%%   \node (2)  at (-2.5,0) {\smallLabelFont$s: \wlab{\rlx}{y}{1}$ };
%%   \node (11) at (0,1.5)  {\smallLabelFont$t: \rlab{\rlx}{y}{1}$ };
%%   \node (12) at (0,0)  {\smallLabelFont$u: \wlab{\rlx}{x}{1}$ };

%%   \draw[po] (1)  edge  (2);
%%   \draw[po] (11) edge (12);
%%   \draw[po] (01) edge (11);
%%   \draw[po] (02) edge (11);
%%   %% \draw[hb] (01) edge node[right] {\smallLabelFont $\lHB$} (1);
%%   \draw[po] (01) edge (1);
%%   \draw[po] (02) edge  (1);
%%   %% \draw[deps,bend left=20] (11)  edge node[right] {\small $\lDEPS$} (12);
%%   %% \draw[sw] (2) edge node[above] {\smallLabelFont $\lSW$} (11);
%%   %% \draw[hb] (1) edge node[below] {\smallLabelFont $\lHB$} (12);
%%   \draw[rf] (2) edge node[below] {\smallLabelFont $\lRF$} (11);
%%   \draw[rf] (12) edge node[left] {} (1);
%%   %% \draw[rf] (01) edge node[below] {\smallLabelFont $\lRF$} (12);
%%   %% \draw[mo,bend right=20] (01)  edge node[left] {\smallLabelFont $\lMO$} (1);
%%   %% \draw[mo,bend right=90] (02)  edge node[above] {} (2); %{\small $\lCO$} (2);
%% \end{tikzpicture}
%% \end{tabular}
%% \end{center}
%%   \caption{Сценарии поведения программы ${\rm IF\text{-}notOOTA}$ в модели C/C++11}
%% \label{fig:ifOOTASem}
%% \end{figure}

%% Заметим, что мы можем получить третий граф с Рис. \ref{fig:ifOOTASem} по программе ${\rm IF\text{-}OOTA}$, используя
%% приведенный выше алгоритм построения сценариев поведения в модели C/C++11.
%% При этом для ${\rm IF\text{-}OOTA}$ результат $a = 1, b = 1$, представляемый этим графом,
%% имеет ``значения из воздуха'' и нежелателен.
%% К сожалению, в рамках текущего подхода построения сценариев поведения, запрет
%% таких сценариев для некоторых программ  не представляется возможным,
%% т.к. после построения предзапусков (первый шаг алгоритма) программа более не участвует
%% в процессе, хотя наличие или отсутствие ``значений из воздуха'' в некотором сценарий
%% является характеристикой программы.

Стоит отметить, что в стандартах C~\cite{C:11} и C++~\cite{CPP:11, CPP:14} упомянутую проблему пытаются решить
путём прямого запрета сценариев поведения со ``значениями из воздуха''.
Данный запрет является неформальным, поскольку в стандарте отсутствует формальное определение
``значений из воздуха''.
Но в~\cite{Boehm-Demsky:MSPC14} отмечается, что такое решение проблемы
является неудовлетворительным, поскольку не даёт возможности строго рассуждать
о программах.

\subsection{Теоретические модели памяти}
В этом разделе коротко рассматриваются альтернативные теоретические модели памяти для языков программирования.

В~\cite{Nienhuis-al:OOPSLA16} определяется операционная семантика на базе C/C++11 MM.
Эта семантика по предзапуску программы инкрементально строит полный сценарий поведения.
Данный подход решает проблему интеграции C/C++11 MM c
остальной частью стандарта~\cite{Memarian-al:PLDI16},
однако оставляет проблему ``значений из воздуха'', а также не предоставляет операционной интуиции
о поведении программы.

В~\cite{Crary-Sullivan:POPL15} предлагается альтернативный подход к аннотированию инструкций обращений к памяти:
вместо того, чтобы помечать часть инструкций ``строгими'' модификаторами, такими как $\acq$, $\rel$ и $\sco$,
и значит неявно запрещать переупорядочивание инструкций вокруг них,
авторы~\cite{Crary-Sullivan:POPL15} предлагают
явно указывать то, порядок между какими инструкциями должен быть сохранён.
Такой подход позволяет эффективнее компилировать программы в целевую платформу.
Сама модель памяти в данной работе представлена в операционном виде.
К её недостаткам стоит отнести то, что в ней позволяются сценарии поведения со ``значениями из воздуха''.

В~\cite{PichonPharabod-Sewell:POPL16} представлена модели памяти на основе \emph{структур событий}
(event structures)~\cite{Winskel:AC86, Winskel:LTBT88}.
Семантика программы представляется не как множество несвязанных графов,
а как один общий граф, в котором присутствует \emph{отношение конфликта}.
Последнее позволяет разделять вершины, относящиеся к разным сценарием поведения --- каждый максимальный подграф,
в котором нет конфликтующих событий, является одним сценарием поведения в аксиоматическом смысле.
Поскольку в структуре событий все сценарии представляются согласованно,
данная семантика может проверять наличие семантической зависимости между событиями.
В частности, для программы ${\rm IF\text{-}notOOTA\text{-}rlx}$ семантика может проверить,
что вне зависимости от того, какое значение читается в регистр $a$ левым потоком,
он исполняет запись $\writeInstParam{\rlx}{y}{1}$,
следовательно между соответствующими чтением и записью нет зависимости.
Аналогично, для программы ${\rm IF\text{-}OOTA\text{-}rlx}$ семантика может определить наличие зависимости.
Данная модель обладает следующими недостатками.
Во-первых, она поддерживает только фиксированное множество компиляторных оптимизаций,
которые явным образом представлены как переходы в модели.
Во-вторых, модель определена для подмножества языка C/C++, содержащего только
неатомарные и расслабленные операции чтения и записи, а также захват и высвобождение замков.
И, в-третьих, модель не поддерживает эффективную компиляцию в модель
ARMv8 POP~\cite{Flur-al:POPL16}\footnote{В главе \ref{sec:armpop} рассматривается программа ${\rm ARM\text{-}weak}$.
Эта программа обладает слабым поведением, которое не проявляется в модели~\cite{PichonPharabod-Sewell:POPL16}.}.

Близкий подход к заданию модели памяти без ``значений из воздуха'' представлен в~\cite{Jeffrey-Riely:LICS16}.
В этой модели, в отличие от использования явных переписываний структуры событий с помощью фиксированного
набора оптимизаций, задан процесс валидации корректных сценариев поведения, похожий на аналогичный механизм в JMM.
Процесс валидации основан на идее \emph{игры} двух игроков.
Первый игрок пытается обойти подграф структуры событий,
соответствующий проверяемому сценарию; второй игрок вмешивается в этот обход,
добавляя в конфигурацию обхода произвольные вершины и пытаясь помешать первому.
При наличии выигрышной стратегии у первого игрока считается, что сценарий поведения корректен с точки зрения
модели.
Эта игра является представлением недетерминированного переключения контекстов со стороны процессора.
Для модели формально доказано утверждение, косвенно подтверждающие отсутствие проблемы ``значений из воздуха''.
К недостаткам подхода стоит отнести то, что он не поддерживает некоторые
базовые оптимизации, в частности, перестановку независимых чтений.

%% \begin{table}[t]
%%   \begin{center}
%%   \begin{tabular}{r || c | c | c | c | c}
%%     {\bf НМ}& {\bf ЭК} & {\bf КО} & {\bf Нет OOTA} & {\bf Реж. C/C++11} & {\bf ОИ}  \\
%%     \midrule
%%     SC        \cite{Lamport:TC79}                 & \fail & \fail & \tick & -- & \tick \\
%%     C/C++11   \cite{Batty-al:POPL11}              & \tick & \tick$^{*}$ & \fail & \tick & \fail \\
%%     OpC/C++11 \cite{Nienhuis-al:OOPSLA16}         & \tick & \tick$^{*}$ & \fail & \tick & \fail \\
%%     Java      \cite{Manson-al:POPL05}             & \tick & \fail & \fail & -- & \fail \\
%%     EventOp   \cite{PichonPharabod-Sewell:POPL16} & \fail & \tick & \tick & \fail & \fail \\
%%     EventGame \cite{Jeffrey-Riely:LICS16}         & \fail & \fail & \tick & \fail & \fail \\
%%     RMC \cite{Crary-Sullivan:POPL15} & ? & \tick
%%   \end{tabular}
%%   \end{center}
%%   \label{tbl:plmmrequirements}
%%   \caption[Соответствие существующих моделей памяти для языков программирования основным требованиям]
%%     {Соответствие существующих моделей памяти для языков программирования основным требованиям, где
%%      {\bf НМ} --- название модели,
%%      {\bf ЭК} --- наличие эффективной схемы компиляции в целевые платформы,
%%      {\bf КО} --- поддержка компиляторных оптимизаций,
%%      {\bf Нет OOTA} --- отсутствие OOTA,
%%      {\bf Реж. C/C++11} --- поддержка режимов C/C++11,
%%      {\bf ОИ} --- обладает операционной интуицией;
%%      \tick --- выполняется,
%%      \fail --- не выполняется,
%%      \tick$^{*}$ --- выполняется для локально модифицированной модели,
%%      `--' --- критерий не применим
%%   }
%% \end{table}

%% \section{Различные подходы к заданию моделей памяти}

%% \subsection{Операционные модели}
%% \subsection{Аксиоматические (декларативные) модели}
%% \subsection{Денотационные модели}

%% Данное заключение неверно для моделей, в том числе для обещающей и ARMv8.3
%% моделей. Рассмотрим, как слабое поведение $a = 1, b = 0$ достигается при исполнении ${\rm MP}$
%% в обещающей модели памяти.

%% План
%% \begin{itemize} 
%%   \item Определение. Модель памяти
%%   \item Определение. Модель последовательной консистентности
%%   \item Мотивировка. Пример слабого исполнения
%%   \item Определение. Слабый сценарий поведения
%%   \item Определение. Слабая модель памяти
%%   \item Существующие модели
%%   \begin{itemize}
%%     \item Языки
%%       \begin{itemize}
%%         \item C/C++
%%         \item Java
%%         \item ?? LLVM ??
%%         \item ?? .Net ??
%%       \end{itemize}
%%     \item Процессоры
%%       \begin{itemize}
%%         \item x86
%%         \item Power
%%         \item ARM
%%         \item DEC Alpha (видимая спекуляция потоков)
%%       \end{itemize}
%%   \end{itemize}
%%   \begin{itemize}
%%     \item Модель памяти C/C++11. Недостатки
%%       \begin{itemize}
%%         \item OOTA (out-of-thin-air)
%%         \item Нет операционной интуиции
%%       \end{itemize}
%%     \item Модель памяти Java. Недостатки
%%       \begin{itemize}
%%         \item Оптимизации некорректны
%%         \item Нет операционной интуиции
%%       \end{itemize}
%%   \end{itemize}
%%   \item Определение. Операционная модель памяти
%%   \item Определение. Декларативная (аксиоматическая) модель памяти
%% \end{itemize}


%% \section{Модели памяти}
%% \subsection{Виды моделей памяти}

\section{Выводы}
На основе проделанного обзора сделаны следующие выводы.
\begin{itemize}
  \item Модель памяти промышленного языка программирования должна удовлетворять, как минимум, трём критериям.
    Во-первых, должна существовать корректная схема компиляции в модель целевой процессорной
    архитектуры.
    Во-вторых, основные компиляторные оптимизации должны быть корректны в рамках модели.
    В-третьих, у модели должна отсутствовать проблема ``значений из воздуха''.
  \item При разработке новой модели памяти языка программирования нужно доказывать корректность эффективной компиляции
     в модели памяти целевых процессорных архитектур.
  \item Существующие модели памяти промышленных языков программирования не удовлетворяют
    приведённым выше критериям.
  \item Требуется разработать операционную модель памяти с синтаксисом C/C++11 MM, которая
    не имеет проблемы ``значений из воздуха''.
  %% \item Обещающая модель памяти является перспективной альтернативой существующей модели памяти C/C++.
\end{itemize}
