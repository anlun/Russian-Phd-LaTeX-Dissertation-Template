\chapter{Обзор предметной области} \label{sec:overview}
В данной главе вводятся основные понятия этого диссертационного исследования: модель памяти, слабая модель памяти;
приводится примеры.
Рассматриваются существующие модели памяти языков программирования и
процессорных архитектур, а также требования, предъявляемые к ним.
Приводится описание проблемы ``значений из воздуха'' (OOTA, out-of-thin-air values).
Подробно описывается модель памяти C/C++11 \cite{Batty-al:POPL11}.
В конце главы приведены выводы о состоянии предметной области и о существующих
направлениях исследования.

\section{Модели памяти, слабые сценарии поведения}
Под \emph{моделью памяти} мы будем понимать семантику системы с многопоточностью.
В рамках диссертационного исследования рассматриваются два типа таких систем:
языки программирования и процессорные архитектуры.

Модели памяти разделяются по принципу того, какие ограничения на сценарии поведения
программ они предоставляют \cite{Kshemkalyani-Singhal:2011}.
Так, \emph{строгая консистентность} гарантирует, что любая запись в память становится мгновенно видна
всем потокам в системе. Эта модель требует наличия некоторого абсолютного счётчика времени, разделяемого
между всеми потоками системы,
что зачастую является недостижимым требованием. Менее строгая модель \emph{последовательной консистентности} \cite{Lamport:TC79}
(SC, sequential consistency)
предполагает, что любой сценарий поведения может быть получен исполнением потоков на одном вычислительном
ядре с вытесняющей многозадачностью. Это означает, что все операции над памятью, совершаемые потоками в рамках
одного сценария поведения,
могут быть упорядочены, и полученный порядок согласуется с порядком инструкций в самих потоках.
Сценарии поведения программ, которые не могут быть получены в рамках модели SC, называются
\emph{слабыми}, а модели, допускающие слабые сценарии поведения, --- \emph{слабыми моделями памяти} \cite{Adve-Gharachorloo:IEEE96}.

Несмотря на то, что модель SC кажется наиболее естественной, а статья \cite{Lamport:TC79},
в которой эта модель описывается, называется ``How to make a multiprocessor computer that correctly executes multiprocess programs'',
современные процессорные архитектуры и языки программирования активно используют слабые модели памяти. Это 
связано с тем, что слабые модели позволяют реализовать большее число оптимизаций как на уровне процессора
\cite{Hennessy-Patterson:BOOK}, так и на уровне компилятора \cite{Aho-al:BOOK86,Muchnick:BOOK97},
что увеличивает производительность программ.

Рассмотрим следующую программу ${\rm MP}$ (message passing, передача сообщения).
%% которая обладает слабым поведением на большинстве современных программных архитектур:
\begin{equation*}
\tag{MP}\label{ex:MP}
\begin{tabular}{c}
  $\writeInst{x}{0}; \writeInst{y}{0};$ \\
\begin{tabular}{L || L}
  \writeInst{x}{1}; & \readInst{a}{y}; ~\valuecom{1} \\
  \writeInst{y}{1} & \readInst{b}{x}~ ~\valuecom{0} \\
\end{tabular}
\end{tabular}
\end{equation*}
Эта программа является упрощенным примером передачи данных между потоками.
Первый поток записывает данные в локацию $x$ и потом выставляет флаг, которым является локация $y$,
что данные подготовлены; в свою очередь второй поток проверяет флаг, а потом читает данные.
Модель SC гарантирует, что если второй поток увидел, что
флаг выставлен ($a = 1$), то он увидит и подготовленные данные ($b = 1$).
Тем не менее, эта программа имеет слабый сценарий поведения ($a = 1, b = 0$) на таких архитектурах как Power и ARM.

С чем связано то, что на упомянутых выше архитектурах возможен результат $a = 1, b = 0$?
Оптимизирующий процессор при исполнении программы может выполнить независимые инструкции не по порядку.
Поскольку первая и вторая инструкции в левом потоке являются обращениями к разным локациям, то процессор может выполнить
сначала вторую запись, а потом первую.
То же самое верно и для инструкций в правом потоке.
После исполнения инструкций не по порядку хотя бы в одном потоке результат $a = 1, b = 0$ становится возможным.

Такой сценарий поведения также разрешается моделями памяти некоторых языков программирования, например, стандартами языков
C11 \cite{C:11} и C++11 \cite{CPP:11}, поскольку оптимизирующий компилятор должен иметь возможность переупорядочить независимые обращения
к памяти.

\subsubsection{О корректности программы ${\rm MP}$. Гонки по данным}
Стоит отметить, что с точки зрения некоторых языков программирования программа ${\rm MP}$ может считаться некорректной,
т.к. в этой программе есть \emph{гонка по данным} \cite{Unger:ITC95}.
\begin{definition}
  \label{def:datarace}
  В программе есть \emph{гонка по данным}, если в некотором её сценарии поведения существуют два неупорядоченных
  обращения к одной и той же ячейке памяти, причём как минимум одно из этих обращений является операцией записи.
\end{definition}
Данное определение не является формальным, т.к. мы не определяем порядок на операциях над памятью.
Это связано с тем, что в разных моделях этот порядок определяется существенно по-разному.
По сути, два обращения неупорядочены, если порядок их исполнения определяется не логикой
программы, а внешними факторами, такими как, например, диспетчеризация потоков.

В отсутствии гонок по данным большинство слабых моделей памяти гарантируют, что все сценарии поведения программы
являются SC-поведениями. Для того, чтобы добиться отсутствия гонок даже при использовании общей памяти (shared memory),
применяют \emph{блокировки} (locks), которые упорядочивают обращения к разделяемому ресурсу.

Как следствие, один из способов задать модель памяти для языка программирования выглядит следующим образом:
если в программе нет гонок по данным, то её поведение определяется моделью SC, иначе программа является некорректной и
обладает неопределенным поведением (undefined behavior).
У такого способа есть, как минимум, два недостатка.
Во-первых, языки программирования  (например, Java), стремясь обеспечить
\emph{типобезопасность} (type safety), не могут использовать такой способ задания семантики,
т.к. гарантируют, что программа не может иметь неопределенное поведение, если она прошла проверку типов, а
наличие или отсутствие гонок по данным не может быть проверено статически.
Во-вторых, многие высокопроизводительные алгоритмы многопоточного программирования используют парадигму
\emph{неблокирующей синхронизации} (non-blocking synchronization), которая существенным образом опирается
на гонки по данным. Более того, в большинстве случаев реализация самих блокировок использует гонки по данным,
что делает невозможным рассуждения о ней в рамках приведенной выше упрощённой модели.

Из вышесказанного следует, что модель памяти промышленного языка программирования должна обеспечивать корректную семантику,
как минимум, для некоторого множества программ с гонками по данным.

\section{Требования к моделям памяти}
На данный момент существует множество моделей памяти как для процессорных архитектур
\cite{Sewell-al:CACM10,Alglave-al:TOPLAS14,Flur-al:POPL16,Pulte-al:POPL18,Sarkar-al:PLDI11,Kavanagh-Brookes:CoRR17},
так и для языков программирования
\cite{Crary-Sullivan:POPL15,Lamport:TC79,Boudol-al:EXPRESS12,Boudol-Petri:POPL09,PichonPharabod-Sewell:POPL16,Jeffrey-Riely:LICS16,
Nienhuis-al:OOPSLA16,Batty-al:POPL11,Manson-al:POPL05}.
Существенным отличием между этими группами моделей являются предъявляемые к ним требования .

Модели процессорных архитектур должны описывать сценарии поведения существующих процессоров, а также оставлять пространство
для возможных оптимизаций в будущем.
Кроме того такие модели зачастую либо заданы \emph{операционно}, т.е. в терминах некоторой
абстрактной машины \cite{Diehl-al:FGCS00}, либо имеют эквивалентное операционное представление.
Это позволяет определить модель в терминах, близких и понятных разработчикам архитектуры, а также предоставить
операционную интуицию разработчикам компиляторов.

Модель памяти языка программирования должна быть представлена таким образом, чтобы, с одной стороны,
она разрешала манипуляции над кодом программы, совершаемые в рамках компиляторных оптимизаций, и давала возможность
эффективно компилировать программы в целевую процессорную архитектуру, а, с другой стороны, предоставляла
разумные гарантии для программиста.
Эти требования до некоторой степени противоречат друг другу, поэтому хорошая модель
соблюдает баланс между ними.
Для того, чтобы понять, в чём заключается противоречие данных требований, остановимся на них подробнее.

\subsection{Корректность компиляторных оптимизаций}
Пусть есть некоторый язык программирования $\LL$ и его модель памяти $\MM$.
Тогда под \emph{семантикой программы $\PP$ на языке $\LL$ в модели $\MM$}
мы будем понимать множество возможных сценариев поведения $\PP$ в $\MM$ и обозначать $\sem{\PP}_\MM$.
%% \begin{definition}
\emph{Оптимизацией над программами в языке $\LL$} мы будем называть функцию $\opt : \LL \rightarrow \LL$, действующую из
множества программ на языке $\LL$ в него же.
%% \end{definition}
\begin{definition}
  Оптимизация $\opt : \LL \rightarrow \LL$ называется \emph{корректной в модели $\MM$},
  $\correctOpt_\MM(\opt)$, если для любой программы $\PP$ на языке $\LL$
  семантика оптимизированной программы $\opt(\PP)$ является подмножеством семантики изначальной программы $\PP$.
  \[\forall \opt : \LL \rightarrow \LL. \; \correctOpt_\MM(\opt) \Leftrightarrow (\forall \PP \in \LL. \; \sem{\opt(\PP)}_\MM \subseteq \sem{\PP}_\MM). \]
\end{definition}

Какие компиляторные оптимизации должны быть корректны в рамках модели памяти языка программирования?
К сожалению, на данный момент научное сообщество не выработало полный список, однако из работ
\cite{Vafeiadis-al:POPL15,Morisset-al:PLDI13,Sevcik-Aspinall:ECOOP08} можно выделить пять основных групп таких оптимизаций.
\begin{enumerate}
  \item Локальные оптимизации, не меняющие обращения к памяти в возможных сценариях поведения.
    Например, удаление условных переходов, зависимых от заведомо ложного условия:
    \[
      \begin{array}{l c l}
        \begin{array}{l}
        \assignInst{a}{0}; \\
        \iteml{a}{\readInst{b}{x}}{\skipc}; \\
        \readInst{c}{y} \\
        \end{array}
        & \optarrow &
        \begin{array}{l}
          \assignInst{a}{0}; \\
          \skipc; \\
          \readInst{c}{y}
        \end{array}
      \end{array}
    \]
  \item Перестановка обращений к памяти.
    Например, перестановка инструкций чтения из разных локаций:
    \[
      \begin{array}{l c l}
        \begin{array}{l}
        \readInst{a}{x}; \\
        \readInst{b}{y}
        \end{array}
        & \optarrow &
        \begin{array}{l}
        \readInst{b}{y}; \\
        \readInst{a}{x}
        \end{array}
      \end{array}
    \]
  \item Устранение избыточных обращений к памяти.
    Например, устранение инструкции чтения, следующей за инструкциями чтения или записи в ту же локацию:
    \[
    \begin{array}{c c c}
      \begin{array}{l c l}
        \begin{array}{l}
        \readInst{a}{x}; \\
        \readInst{b}{x}
        \end{array}
        & \optarrow &
        \begin{array}{l}
        \readInst{a}{x}; \\
        \assignInst{b}{a}
        \end{array}
      \end{array}
      & \qquad &
      \begin{array}{l c l}
        \begin{array}{l}
        \writeInst{x}{a}; \\
        \readInst{b}{x}
        \end{array}
        & \optarrow &
        \begin{array}{l}
        \writeInst{x}{a}; \\
        \assignInst{b}{a}
        \end{array}
      \end{array}
    \end{array}
    \]
  \item Вставка избыточных обращений к памяти. Например, вставка инструкции чтения в переменную,
    значение которой далее нигде не используется.
  \item Глобальные оптимизации. Например, \emph{секвенциализация} (sequentialization),
    которая заменяет параллельную композицию потоков на последовательную:
    \[
      \begin{array}{l c l}
      C_1\;||\;C_2 & \optarrow & C_1;\;C_2
      \end{array}
    \]
\end{enumerate}

Желательно, чтобы оптимизаций, относящиеся к упомянутыми группам, были корректными, возможно, с некоторыми оговорками
в модели памяти языка программирования.
Для этого модель должна быть достаточно слабой, т.е. позволять для изначальной программы сценарии поведения, которые
возможны для программы после оптимизации.

\subsection{Наличие эффективной схемы компиляции}
Модель памяти языка программирования должна учитывать модель памяти целевой платформы.
Так, должна существовать корректная схема компиляции между моделями, позволять корректно компилировать программы.

\begin{definition}
Пусть есть некоторые языки $\LL$ и $\LowLL$ и соответствующие модели памяти $\MM$ и $\LowMM$.
%% причём $\LL$ является исходным языком, а $\LowLL$ --- целевым для некоторой схемы компиляции $\complScheme : \LL \rightarrow \LowLL$.
Функция $\complScheme : \LL \rightarrow \LowLL$ является \emph{корректной схемой компиляции из модели $\MM$ в модель $\LowMM$},
если для любой программы $\PP$ на языке $\LL$ семантика программы $\complScheme(\PP)$ в модели $\LowMM$ является подмножеством
семантики $\PP$ в модели $\MM$.
\end{definition}

Из определения следует, что чем слабее модель целевой платформы, т.е. чем больше существует сценариев поведения на целевой платформе,
тем больше ограничений накладывается на корректную схему компиляции.

Рассмотрим то, как должна быть устроена корректная схема компиляции из более строгой модели памяти в более слабую на примере
компиляции ранее приведенной программы ${\rm MP}$ из модели SC \cite{Lamport:TC79} в модель архитектуры Power \cite{Alglave-al:TOPLAS14}.
В рамках модели SC программа ${\rm MP}$ не имеет сценария поведения $a=1, b=0$, тогда как в модели Power такой сценарий возможен.
Для того, чтобы получить корректную компиляцию, в скомпилированную программу нужно вставить специальные инструкции, т.н. \emph{барьеры памяти}.
Барьеры вносят дополнительные ограничения на сценарии поведения программ.
Достигается это за счёт того, что барьеры запрещают некоторые компиляторные и процессорные оптимизации.
В архитектуре Power есть барьер $\hwsync$, который запрещает процессору переупорядочивать любые обращения к памяти,
Вставка такого барьера между инструкций в программе ${\rm MP}$ гарантирует отсутствие сценария поведения $a=1, b=0$ в модели
Power\footnote{Здесь и далее в
  диссертации мы используем один и тот же с точностью до барьеров и модификаторов чтения и записи синтаксис
  для описания как исходных, так и скомпилированных программ.
%% Мы могли бы использовать ассемблероподобный синтаксис для последних, но в этом нет необходимости ввиду того, что .
}.
\begin{equation*}
\tag{MP-hwsync}\label{ex:MP-hwsync}
\begin{tabular}{c}
  $\writeInst{x}{0}; \writeInst{y}{0};$ \\
\begin{tabular}{L || L}
  \writeInst{x}{1}; & \readInst{a}{y}; \\
  \hwsync;          &  \hwsync;        \\
  \writeInst{y}{1}  & \readInst{b}{x} \\
\end{tabular}
\end{tabular}
\end{equation*}
На ряду с $\hwsync$ архитектура Power также предоставляет более слабый барьер $\lwsync$,
который запрещает только перестановки пар инструкций чтение-чтение, чтение-запись и запись-запись.
Такого барьера также достаточно, чтобы запретить сценарий $a=1, b=0$.
\begin{equation*}
\tag{MP-lwsync}\label{ex:MP-hwsync}
\begin{tabular}{c}
  $\writeInst{x}{0}; \writeInst{y}{0};$ \\
\begin{tabular}{L || L}
  \writeInst{x}{1}; & \readInst{a}{y}; \\
  \lwsync;          &  \lwsync;        \\
  \writeInst{y}{1}  & \readInst{b}{x} \\
\end{tabular}
\end{tabular}
\end{equation*}
В данном случае схема компиляции, использующая барьер $\lwsync$, является более предпочтительной по сравнению
со $\hwsync$-схемой, т.к. барьер $\lwsync$ исполняется быстрее (или, как минимум, не медленнее), чем $\hwsync$
на реальных процессорах.

Если рассмотреть модель памяти языка программирования, которая разрешает сценарий поведения $a=1,b=0$
(на ряду со всеми остальными сценариями, возможными в рамках модели SC), то для компиляции программы
${\rm MP}$ из такой модели в модель Power не будет необходимости вставлять барьеры памяти.
Например, модели C/C++11 \cite{Batty-al:POPL11} и Java \cite{Manson-al:POPL05} разработаны таким образом, чтобы
обычные операции чтения и записи\footnote{В разделе \ref{sec:cppmodel} мы рассмотрим различные модификаторы, которыми могут
быть помечены инструкции работы с памятью в модели C/C++11, и ``обычные операции чтения и записи'' будут соответствовать
атомарным расслабленным и неатомарным инструкциям.
Все инструкции работы с памятью из примеров программ, приведённых к этому моменту, были ``обычными''.}
могли быть скомпилированы без вставки барьеров памяти в случае компиляции в платформы x86, Power и ARM.

Именно подобные схемы компиляции мы будем называть \emph{эффективными}.
Соответственно, как было видно из рассмотренных схем компиляции из модели SC в модель Power, между моделями
не существует эффективной компиляции.
Очевидно, что для того, чтобы существовала эффективная схема компиляции из модели языка программирования в модель
целевой платформы, должно выполняться следующее утверждение:
модель исходного языка должна позволять все сценарии поведения для программы без барьеров,
которые позволяет целевая модель памяти для скомпилированной версии программы, в которой также не используются барьеры.
Аналогично требованию на корректность оптимизаций, наличие эффективной схемы компиляции ``увеличивает'' число
слабых поведений, дозволяемых в рамках модели.

%% Поскольку барьеры памяти запрещают определенные оптимизации, их присутствие замедляет исполнение программ.
%% Для того, чтобы уменьшить такой эффект, но при этом сохранить корректность компиляции, 

%% \app{TODO: Описать цену сохранения SC.}
%% [13] D. Marino, A. Singh, T. Millstein, M. Musuvathi, and
%%      S. Narayanasamy. A case for an SC-preserving compiler. In

\subsection{Гарантии программисту} %Отсутствие ``значений из воздуха''}
Требование о том, что модель памяти языка программирования должна предоставлять разумные
гарантии программисту звучит крайне неформально.
Попробуем сформулировать его более конкретно.

Очевидно, что программист должен иметь представление о том, как ведется себя программа, над
которой он работает, а поведение программы как раз определяется моделью памяти.
Как следствие, желательно, чтобы модель памяти была как можно более простой и понятной,
а также существовал формальный инструментарий для рассуждения о программах в рамках модели.
Простота это очень субъективный критерий, особенно при сравнении слабых моделей памяти,
тогда как наличие и выразительная сила инструментов анализа программ может быть
использована для более точного сопоставления моделей.

Существуют различные методологии для анализа программ.
Среди них стоит выделить \emph{методы проверки моделей} (model checking) \cite{Peled-al:BOOK08,Clarke-al:BOOK99} и
\emph{верификации по Хоару} (Hoare logic) \cite{Hoare:CACM69}.
Оба метода зарекомендовали себя в приложении к модели SC
\cite{Owicki-Gries:AI76,Owicki-Gries:CACM76,OHearn:CONCUR04,Bornat-al:POPL05,Hobor-al:ESOP08,Dockins-al:ENTCS08,
Hobor-Gherghina:ESOP11,Gotsman-al:APLAS07,Jacobs-Piessens:POPL11,Svendsen-Birkedal:ESOP14,DinsdaleYoung-al:ECOOP10,Jung-al:POPL15,
LeyWild-Nanevski:POPL13,Sergey-al:PLDI15,Vechev-al:STTT13,Raychev-al:SAS13}.
Существуют также и работы, посвященные слабым моделям памяти
\cite{Kaiser-al:ECOOP17,Vafeiadis-Narayan:OOPSLA13,Turon-al:OOPSLA14,Lahav-Vafeiadis:ICALP15,Meshman-al:FMCAD15,Dan-al:SAS13}.
В последних отмечается, что если модель памяти разрешает сценарии поведения программ с т.н.
\emph{``значениями из воздуха''} (out-of-thin-air values, OOTA),
то класс свойств, которые могут быть проверены или доказаны для программ в рамках модели, существенным образом ограничивается.
В частности, модель памяти C/C++11 разрешает такие сценарии.

Что же такое ``значения из воздуха''? К сожалению, на данный момент не существует точного определения \cite{Boehm-Demsky:MSPC14},
однако существует набор примеров таких поведений, а также признак наличия ``значений из воздуха''.
Последний звучит следующим образом: если в сценарии поведения программы, в которой нет арифметических выражений,
появляется некоторое значение (например, это значение присваивается переменной или записывается в память), при чём это
значение явным образом не фигурирует в тексте программы, то такой сценарий обладает ``значениями из воздуха''.

Рассмотрим следующую программу:
\begin{equation*}
\tag{LB-OOTA}\label{ex:LBoota}
\begin{tabular}{c}
  $\writeInst{x}{0}; \writeInst{y}{0};$ \\
\begin{tabular}{L || L}
  \readInst{a}{x};  & \readInst{b}{y}; \\
  \writeInst{y}{a} & \writeInst{x}{b} \\
\end{tabular}
\end{tabular}
\end{equation*}
В этой программе нет арифметических операций и $0$ является единственным значением,
которое явным образом встречается в тексте программы.
По приведенному выше признаку любой сценарий поведения этой программы,
в результате которого значение переменной $a$ или $b$ отличается от $0$,
обладает ``значением из воздуха''. Такие сценарии разрешаются для этой программы
в рамках модели C/C++11 \cite{Batty-al:POPL11}.

Рассмотрим другую программу, некоторые сценарии поведения которой в рамках
модели C/C++11 также считаются \cite{Boehm-Demsky:MSPC14} обладающими
``значениями из воздуха'', но не подпадающую под признак:
\begin{equation*}
\tag{IF-OOTA}\label{ex:IFoota}
\begin{tabular}{c}
  $\writeInst{x}{0}; \writeInst{y}{0};$ \\
\begin{tabular}{L || L}
  \readInst{a}{x}; & \readInst{b}{y}; \\
  \begin{array}{@{}l@{}}
  \iteml{a}{\writeInst{y}{1}}{\skipc}
  \end{array} &
  \begin{array}{@{}l@{}}
  \iteml{b}{\writeInst{x}{1}}{\skipc}
  \end{array} \\
\end{tabular}
\end{tabular}
\end{equation*}
Казалось бы, что единственным результатом исполнения этой программы может быть
$a = b = 0$, но модель C/C++11 также разрешает $a = b = 1$.

Сценарии поведения со ``значениями из воздуха'' всегда имеют некоторую
циклическую зависимость между встречаюшимися в них значениями.
Как следствие, они не проявляются на современных
процессорах\footnote{Сценарии поведения со ``значениями из воздуха''
проявляются на процессорах семейства DEC Alpha \cite{DecAlpha},
но данная архитектура снята с производства.}
и не могут быть получены как результат разумной оптимизации.
То, что некоторые модели разрешают такие сценарии обычно является
результатом того, что в рамках подхода, выбранного для задания модели,
тяжело или невозможно запретить ``значения из воздуха''
и, при этом, не запретить нужные оптимизации \cite{Batty-al:ESOP15}.

%% Таким образом, критерий предоставления разумных гарантий программисту
%% со стороны модели памяти 


%% Если модель разрешает манипуляции над кодом, такие как перестановка инструкций, это означает, что семантика изначальной
%% программы в рамках модели должна включать себя 

%% , абсолютное большинство которых являются слабыми моделями.
%% Все эти модели являются слабыми.

%% Среди процессорных моделей стоит выделить модели архитектур x86 \cite{Sewell-al:CACM10,Owens-al:TPHOL09},
%% Power \cite{Alglave-al:TOPLAS14,Sarkar-al:PLDI11} и ARM \cite{Flur-al:POPL16,Pulte-al:POPL18}, т.к. данные архитектуры являются
%% наиболее распространенными на данный момент.

%% В последние годы научное сообщество в сотрудничестве с индустрией разработало множество моделей памяти, как для процессорных архитектур
%% (x86-TSO \cite{Sewell-al:CACM10}, Power \cite{Alglave-al:TOPLAS14}, ARM \cite{Flur-al:POPL16,Pulte-al:POPL18}),
%% так и для языков программирования (Java \cite{Manson-al:POPL05}, C/C++11 \cite{Batty-al:POPL11}).
%% Все эти модели являются слабыми.

\section{Существующие модели памяти ЯП}
Среди моделей памяти, разработанных для языков программирования, есть как используемые на практике,
т.е. являющиеся частями стандартов языков \cite{Gosling-al:BOOK96,JavaStandard,C:11,CPP:11}, так и теоретические работы
\cite{Crary-Sullivan:POPL15,Lamport:TC79,Boudol-al:EXPRESS12,Boudol-Petri:POPL09,PichonPharabod-Sewell:POPL16,Jeffrey-Riely:LICS16}.
Далее в этом разделе мы обсудим модели памяти языков Javа \cite{JavaStandard} и C/C++ \cite{C:11,CPP:11},
выделим их достоинства и недостатки, а также рассмотрим, как упомянутые недостатки решаются в существующих
теоретических моделях.

\subsection{Виды моделей памяти}
На данный момент существует два основных подхода к определению моделей памяти ---
\emph{аксиоматический} (декларативный) и \emph{операционный}, которые в некоторых работах смешиваются.
Аксиоматические модели памяти представляют сценарии поведения программ в виде графов, которые
должны соответствовать определенным аксиомам.
Модели памяти Java и C/C++, описанные ниже, являются примерами аксиоматических моделей.
Преимуществами аксиоматических моделей является относительная простота задания глобальных
свойств сценария поведения, таких как наличие некоторого тотального порядка над подмножестве событий (вершин графа)
определенного типа.
Также аксиоматические модели проще для представления в логических языках \cite{Wickerson-al:POPL17,Bornholt-Torlak:PLDI17},
таких как Alloy \cite{Jackson:Book06} и Rosette \cite{Torlak-Bodik:Onward13,Torlak-Bodik:PLDI14}.

Сценарий поведения в рамках операционных моделей представляется как
серия переходов некоторой абстрактной машины.
Преимуществом таких моделей является то, что они дают операционную интуицию о том, как исполняется программа.
Как следствие, между моделью памяти, которая обычно определяет поведение только подмножества языка, связанного с его многопоточной
компонентой, и описанием остальных конструкций языка есть прослеживаемая связь, которую нужно дополнительно
устанавливать для аксиоматических моделей \cite{Memarian-al:PLDI16}.
Также для большинства операционных моделей возможно написание интерпретатора, что позволяет пошагово
отлаживать многопоточные алгоритмы.


\subsection{Модель памяти Java}
Впервые модель памяти для языка Java была представлена в стандарте 1996 года \cite{Gosling-al:BOOK96}.
Эта модель обладала рядом фундаментальных недостатков \cite{Pugh:JAVA99,Pugh:CPE00} и была заменена на
новую модель \cite{Manson-al:POPL05}, которую дальше мы будем называть моделью памяти Java, или JMM (Java memory model).
JMM была разработана из расчёта на то, что бы запретить ``значения из воздуха'' и разрешить базовые компиляторные оптимизации.
К сожалению, она не соблюдает последнее требование \cite{Sevcik-Aspinall:ECOOP08} ---
в рамках JMM некорректными являются оптимизации удаление чтения после чтения (redundant read after read elimination),
удаление чтения после записи (redundant read after write elimination),
удаление записи после чтения (redundant write after read elimination),
добавление неиспользуемого чтения (irrelevant read introduction) и другие.
Далее в этом разделе мы рассмотрим ключевые понятия модели.

Сценарий поведения программы в JMM представляется как граф, в котором вершинами
являются \emph{события} (actions, events), происходящие в памяти, а помеченными ребрами ---
отношения на событиях.
События бывают нескольких типов, из которых мы выделим четыре основных:
чтение, запись, захват замка (lock), высвобождение замка (unlock).
Чтения и записи, в свою очередь, бывают обычные (non-volatile) и \emph{синхронизирующие} (volatile).
Первые оперируют на обычных локациях в памяти (переменных), тогда как синхронизирующие -- на
\emph{изменчивых} (volatile) локациях.
Как понятно из названия соответствующего типа событий чтения и записи, изменчивые локации выделены как
локации, через обращение к которым происходит синхронизация.

Отметим пять отношений, используемых в сценариях поведения JMM.
Во-первых, \emph{программный порядок} (program order, $\lPO$).
Для каждого потока он является тотальным порядком на событиях, относящихся к этому потоку.
Во-вторых,  отношение \emph{``читает из''} (reads from, $\lRF$).
Оно связывает событие записи с читающими из него событиями.
В-третьих, \emph{синхронизационный порядок} (synchronization order, $\lSO$).
Это некоторый тотальный порядок на синхронизирующих событиях и событиях захвата и высвобождения замков,
который согласуется с $\lPO$ и $\lRF$ на синхронизирующих событиях.
В-четвертых, отношение \emph{``синхронизируется с''} (synchronizes-with, $\lSW$).
$\lSW$ связывает события $a$ и $b$, если $\lRF$ связывает $a$ и $b$ и эти события оперируют над изменчивой локацией,
или если они связаны $\lSO$ и $a$ является высвобождением некоторого замка, а $b$ --- захватом этого же замка.
В-пятых, отношение \emph{``предшествует''} (happens-before, $\lHB$).
$\lHB$ является транзитивным замыканием объединения $\lPO$ и $\lSW$, и именно это отношение определяет порядок
на событиях из определения \ref{def:datarace} для JMM.

Сценарий поведения считается корректным в JMM, только если выполняются \emph{аксиомы} модели.
Одной из аксиом является то, что событие чтения не может читать из события записи, если они находятся
в отношении $\lHB$ и существует событие записи в ту же локацию, которое находится между ними в отношении $\lHB$.
Формально,
$$
\begin{array}{l}
\forall r, w. \; \lRF(w, r) \land \lHB(w, r) \Rightarrow \\
\quad \not \exists w'. \; \lLOC(w) = \lLOC(w') \land \lHB(w, w') \land \lHB(w', r),
\end{array}$$
где $\lLOC$ --- это функция, которая по событию возвращает локацию, над которой событие оперирует.
Благодаря этой аксиоме, JMM запрещает результат $a = 1, b = 0$ для версии программы ${\rm MP}$, в которой локация
$y$ помечена как изменчивая.
\begin{equation*}
\tag{MP-volatile}\label{ex:MPvolatile}
\begin{tabular}{c}
  $\writeInst{x}{0}; \writeInst{y}{0};$ \\
\begin{tabular}{L || L L}
  \writeInst{x}{1}; & \readInstVolatile{a}{y}; & \valuefail{1} \\
  \writeInstVolatile{y}{1} & \readInst{b}{x} & \valuefail{0} \\
\end{tabular}
\end{tabular}
\end{equation*}
Для того, чтобы проверить данное утверждение, построим соответствующий граф.
\[
\begin{tikzpicture}[yscale=1,xscale=1.8]
  \node (01)  at (-2.5,2) {$p: \wlab{}{x}{0}$ };
  \node (02)  at (0,2) {$q: \wlab{volatile}{y}{0}$ };
  \node (1)  at (-2.5,1) {$r: \wlab{}{x}{1}$ };
  \node (2)  at (-2.5,0) {$s: \wlab{volatile}{y}{1}$ };
  \node (11) at (0,1)  {$t: \rlab{volatile}{y}{1}$ };
  \node (12) at (0,0)  {$u: \rlab{}{x}{0}$ };

  \draw[po] (1)  edge  (2);
  \draw[po] (11) edge (12);
  \draw[po] (01) edge (11);
  \draw[po] (02) edge (11);
  %% \draw[hb] (01) edge node[left] {\small $\lHB$} (1);
  \draw[po] (01) edge (1);
  \draw[po] (02) edge  (1);
  %% \draw[deps,bend left=20] (11)  edge node[right] {\small $\lDEPS$} (12);
  \draw[rf] (01)  edge node[above] {\small $\lRF$} (12);
  \draw[sw] (2)  edge node[below] {\small $\lSW$} (11);
  %% \draw[hb] (1) edge node[above] {\small $\lHB$} (12);
  %% \draw[mo,bend right=20] (01)  edge node[left] {\small $\lCO$} (1);
  %% \draw[mo,bend right=90] (02)  edge node[above] {} (2); %{\small $\lCO$} (2);
\end{tikzpicture}
\]
В этом графе шесть событий. События $p$ и $q$ соответствуют инициализирующим записям в локации $x$ и $y$,
а остальные --- инструкциям из ${\rm MP\text{-}volatile}$.
Недописанные дуги --- это дуги отношения $\lPO$. На этом рисунке не представлены дуги отношения $\lHB$,
однако $\lHB$ связывает $p$ и $r$ (т.к. $\lPO \suq \lHB$), а также $r$ и $u$ (т.к. $\lPO(r, s)$, $\lSW(s, t)$, $\lPO(t,u)$ и
$\lHB = (\lPO \cup \lSW)^{+}$).
Таким образом, данный граф противоречит приведенной выше аксиоме и не является корректным в JMM.

Отметим, что если бы локация $y$ не была бы помечена как изменчивая, тогда события $s$ и $t$ имели бы
обычный тип и между ними бы не было ребра $\lSW$, а значит аксиома бы выполнялась и результат $a = 1, b = 0$
был бы возможным.

%% Сценарий поведения программы в JMM представляется как кортеж следующего вида:
%% $$
%% \tup{P, A, \xrightarrow{po}, \xrightarrow{so}, W, V, \xrightarrow{sw}, \xrightarrow{hb}},
%% $$
%% где $P$ --- программа, $A$ --- множество событий (actions, events), $\xrightarrow{}$

%% В JMM локации в памяти (или переменные) разделяются на два типа: \emph{обычные} (normal) и \emph{изменчивые} (volatile).

Для того, чтобы запретить сценарии поведения со ``значениями из воздуха'', в JMM используется процесс
валидации сценариев.
В рамках процесса строится серия сценариев, каждый из которых является корректным с точки зрения аксиом JMM,
при этом последним в серии является валидируемый сценарий.
Также каждому сценарию в серии присваивается множество добавленных (committed) событий.
Эти множества монотонно растут в серии, а последнее равняется множеству всех событий в графе валидируемого сценария.
При этом на каждом шаге трансформации в серии сохраняется подмножество отношения $\lHB$, заданное на добавленных
событиях.

В работе \cite{Sevcik-Aspinall:ECOOP08} утверждается, что именно из-за процесса валидации упомянутые выше оптимизации
некорректны в JMM.

\subsection{Модель памяти C/C++}
\label{sec:cppmodel}
В последние годы научным сообществом было уделено особое внимание модели памяти C/C++,
которая появилась в стандартах языков в 2011 году \cite{C:11,CPP:11}.
Она не претерпела существенных изменений в последующих стандартах 2014 \cite{CPP:14} и 2017 \cite{CPP:17} годов,
и поэтому в литературе обычно не различают понятия ``модель памяти C/C++'' и ``модель памяти C/C++11''.
Далее мы будем использовать термин ``модель памяти C/C++11'' или ``C/C++11 MM''.

Базовым результатом о модели является её формализация в работе \cite{Batty-al:POPL11};
мы будем подразумевать под моделью C/C++11 именно эту формализацию.
Существуют работы, посвященные корректности компиляции и оптимизаций
\cite{Batty-al:POPL12,Vafeiadis-al:POPL15,Chakraborty-Vafeiadis:CGO16,Lahav-al:PLDI17,Batty-al:POPL16},
логикам для формальных рассуждений о программах
\cite{Turon-al:OOPSLA14,Vafeiadis-Narayan:OOPSLA13,Lahav-Vafeiadis:ICALP15,Doko-Vafeiadis:VMCAI16,Vafeiadis:CPP15}
и другим результатам о модели
\cite{Batty-al:POPL13,Batty-al:ESOP15,Lidbury-Donaldson:POPL17, Tassarotti-al:PLDI15,Doko-Vafeiadis:ESOP17}.
Как следствие, модель C/C++11 является одной из самых проработанных моделей памяти ЯП.
Тем не менее, она не лишена недостатков, в том числе ``значений из воздуха''.

\subsubsection{Виды обращений к памяти}
В модели C/C++11 локации бывают двух типов --- неатомарные (non-atomic) и атомарные (atomic).
В отличие от случая Java, разделение между ними менее строгое,
т.к. языки C/C++ разрешают совершать преобразование типов, и, как следствие,
на один и тот же адрес в памяти может ссылаться две переменных в программе, одна из которых будет
иметь атомарный тип, а другая --- неатомарный.
Как следствие, в C/C++11 MM обращения к одной и той же локации могут быть как неатомарными, так и атомарными.
Последние в свою очередь также подразделяются на несколько категорий в зависимости от типа обращения ---
чтение, запись или одновременное чтение-запись (RMW, read-modify-write).
Описание последних мы опустим для краткости.

Событие чтения может быть неатомарным, \emph{расслабленным} (relaxed, $\rlx$),
\emph{потребляющим} (consume, $\con$), \emph{приобретающим} (acquire, $\acq$)
или \emph{последовательно-консистентным} (sequentially-consistent, $\sco$).
Событие записи может быть неатомарным, расслабленным,
\emph{высвобождающим} (release, $\rel$)
или последовательно-консистентным.
В обоих случаях виды обращений упорядочены по тому, сколько гарантий они предоставляют.
Расслабленные обращения похожи на обычные обращения в модели JMM, тогда как
последовательно-консистентные --- на синхронизирующие.
Неатомарные обращения предоставляют наименьшие гарантии: если неатомарное обращение
является частью гонки по данным, то программа имеет неопределенное поведение в C/C++11 MM.
Приобретающее чтение и высвобождающая запись могут быть использованы для того,
чтобы запретить результат $a = 1, b = 0$ в версии программы, аналогично синхронизирующим
обращениям в случае JMM: %(см. рис. \ref{fig:MPrelAcq}).
%% \begin{figure}
\begin{equation*}
\label{ex:MPrelAcq}
\begin{tabular}{c}
  $\writeInstParam{\rlx}{x}{0}; \writeInstParam{\rlx}{y}{0};$ \\
\begin{tabular}{L || L L}
  \writeInstParam{\rlx}{x}{1}; & \readInstParam{\acq}{a}{y}; & \valuefail{1} \\
  \writeInstParam{\rel}{y}{1} & \readInstParam{\rlx}{b}{x} & \valuefail{0} \\
\end{tabular}
\end{tabular}
\end{equation*}
%% \caption{Программа ${\rm MP\text{-}rel\text{-}acq}$}
%% \label{fig:MPrelAcq}
%% \end{figure}
При этом, в отличие от синхронизирующих обращений JMM и $\sco$-обращений C/C++11 MM,
на высвобождающих и приобретающих событиях не существует тотального порядка,
обязательно учитывающего программный порядок, и, как следствие, следующая программа,
использующая высвобождающие записи, имеет сценарий поведения с результатом $a = 1, b = 1$:
\begin{equation*}
\tag{2W-rel}\label{ex:WWrel}
\begin{array}{c}
\begin{tabular}{L || L}
  \writeInstParam{\rel}{x}{1}; & \writeInstParam{\rel}{y}{1}; \\
  \writeInstParam{\rel}{y}{2} & \writeInstParam{\rel}{x}{2} \\
\end{tabular} \\
\readInstParam{\sco}{a}{x}; \valuecom{1} \\
\readInstParam{\sco}{b}{y}~ \valuecom{1}
\end{array}
\end{equation*}
тогда как она же с $\sco$-записями --- нет:
\begin{equation*}
\tag{2W-sc}\label{ex:WWsc}
\begin{array}{c}
\begin{tabular}{L || L}
  \writeInstParam{\sco}{x}{1}; & \writeInstParam{\sco}{y}{1}; \\
  \writeInstParam{\sco}{y}{2} & \writeInstParam{\sco}{x}{2} \\
\end{tabular} \\
\readInstParam{\sco}{a}{x}; \valuefail{1} \\
\readInstParam{\sco}{b}{y}~ \valuefail{1}
\end{array}
\end{equation*}

Идейно, высвобождающие записи не могут быть переставлены с предшествующими им (в программном порядке) записями
(ни на этапе компиляции, ни во время исполнения программы) и, будучи прочитанными приобретающими чтениями,
гарантируют, что читающий поток станет осведомлён о предшествующих записях.
Аналогично, приобретающие чтения не могут быть переставлены с последующими чтениями.

Потребляющие (consume) чтения являются ослабленной версией приобретающих чтений и предоставляют те же гарантии
только для последующих чтений, которые находятся в зависимости по данным от них.
Так, их будет недостаточно, чтобы гарантировать отсутствие сценария поведения $a = 1, b = 0$ в версии программы
${\rm MP\text{-}rel\text{-}acq}$, в которой $\acq$-чтение заменено на $\con$-чтение, однако будет достаточно,
чтобы гарантировать отсутствие сценария поведения $a = y, b = 0$ в следующей программе:
\begin{equation*}
\tag{MP-addr-con}\label{ex:MPaddrCon}
\begin{array}{c}
\writeInst{x}{0};
\writeInst{y}{0};
\writeInst{z}{x}; \\
\begin{tabular}{L || L L}
  \writeInstParam{\rlx}{y}{1}; & \readInstParam{\con}{a}{z}; & \valuefail{y} \\
  \writeInstParam{\rel}{z}{y} & \readInstParam{\rlx}{b}{a} & \valuefail{0} \\
\end{tabular}
\end{array}
\end{equation*}

%% В целом, модель С/C++11 предоставляет большую по сравнению с JMM вариативность в смысле обращений

\subsubsection{Сценарии поведения}
Аналогично модели JMM, в C/C++11 MM сценарий поведения программы представляется в виде графа,
вершинами которого являются события над памятью.
%% Каждое событие обладает соответствующей пометкой.
%% Так, например, для события чтения указывается его вид, целевая локация и прочитанное значение.
%% В сценариях поведения, также как и в JMM, фигурируют
Также в сценариях поведения фигурируют
отношения программного порядка $\lPO$, ``читает из'' $\lRF$, ``синхронизируется с'' $\lSW$
и ``предшествует'' $\lHB$.
При этом $\lSW$ и $\lHB$ определяются по-другому, так, в частности, $\lSW$ включает в себя подмножество $\lRF$,
связывающее высвобождающие записи с приобретающими чтениями, а $\lHB$ является транзитивным замыканием объединения
$\lPO$ и $\lSW$ в отсутствии $\con$-чтений (с ними определение становится сложнее).
Дополнительно в модели используются два важных отношения: $\lMO$ и $\lSC$.
Отношение $\lMO$, или \emph{порядок памяти} (memory order, coherence order), для каждой локации является полным порядком
на событиях записи в неё. Отношение $\lSC$ (sequential consistency order) является полным порядком на всех $\sco$-событиях
в сценарии поведения.

Также, как и в случае JMM, определяются аксиомы, которые ограничивают пространство возможных сценариев поведения.
Полный список аксиом представлен в \cite{Batty-al:POPL11} и \cite{Vafeiadis-Narayan:OOPSLA13}.
Отличием от JMM является то, что в модели C/C++11 не используется процесс верификации исполнения, который в JMM
используется для фильтрации сценариев поведения со ``значениями из воздуха''.
В итоге, с одной стороны, C/C++11 MM допускает такие поведения, но, с другой стороны, поддерживает большее число
компиляторных оптимизаций.

\subsubsection{Построение сценариев поведения по программе}
Построение сценариев поведения в модели C/C++11 состоит из трёх этапов
(формально процесс изложен в \cite{Vafeiadis-Narayan:OOPSLA13}).
На первом этапе по программе строится множество т.н. \emph{предзапусков} --- частичных графов сценариев
поведения, в которых присутствует только отношение $\lPO$.
При этом, поскольку события чтения не связываются с событиями записи, для каждого события чтения
прочитанное значение выбирается недетерминировано.
В частности, среди предзапусков программы ${\rm MP\text{-}rel\text{-}acq}$ будет следующий граф:
\[
\begin{tikzpicture}[yscale=1,xscale=1.8]
  \node (01)  at (-2,2) {$p: \wlab{\rlx}{x}{0}$ };
  \node (02)  at (0,2) {$q: \wlab{\rlx}{y}{0}$ };
  \node (1)  at (-2,1) {$r: \wlab{\rlx}{x}{1}$ };
  \node (2)  at (-2,0) {$s: \wlab{\rel}{y}{1}$ };
  \node (11) at (0,1)  {$t: \rlab{\acq}{y}{5}$ };
  \node (12) at (0,0)  {$u: \rlab{\rlx}{x}{9}$ };

  \draw[po] (1)  edge  (2);
  \draw[po] (11) edge (12);
  \draw[po] (01) edge (11);
  \draw[po] (02) edge (11);
  %% \draw[hb] (01) edge node[left] {\small $\lHB$} (1);
  \draw[po] (01) edge (1);
  \draw[po] (02) edge  (1);
  %% \draw[deps,bend left=20] (11)  edge node[right] {\small $\lDEPS$} (12);
  %% \draw[hb] (1) edge node[above] {\small $\lHB$} (12);
  %% \draw[mo,bend right=20] (01)  edge node[left] {\small $\lCO$} (1);
  %% \draw[mo,bend right=90] (02)  edge node[above] {} (2); %{\small $\lCO$} (2);
\end{tikzpicture}
\]
На втором этапе в каждый предзапуск недетерминировано добавляются дуги отношений $\lRF$, $\lSC$ и $\lMO$, по
которым также вычисляются производные отношения, такие как $\lSW$ и $\lHB$.
Полученные графы проверяются на базовую корректность.
В частности, проверяется, что если из события $e$ идёт $\lRF$-дуга в $f$,
то $e$ является событием записи, $f$ --- чтения, они оперируют над одной и той же локацией,
и прочитанное значение равняется записанному.
После второго этапа во множестве полученных сценариев поведения для программы ${\rm MP\text{-}rel\text{-}acq}$
есть следующий сценарий поведения (некоторые ребра опушены):
\[
\begin{tikzpicture}[yscale=1,xscale=1.8]
  \node (01)  at (-2,3) {$p: \wlab{\rlx}{x}{0}$ };
  \node (02)  at (0,3) {$q: \wlab{\rlx}{y}{0}$ };
  \node (1)  at (-2,1.5) {$r: \wlab{\rlx}{x}{1}$ };
  \node (2)  at (-2,0) {$s: \wlab{\rel}{y}{1}$ };
  \node (11) at (0,1.5)  {$t: \rlab{\acq}{y}{1}$ };
  \node (12) at (0,0)  {$u: \rlab{\rlx}{x}{0}$ };

  \draw[po] (1)  edge  (2);
  \draw[po] (11) edge (12);
  \draw[po] (01) edge (11);
  \draw[po] (02) edge (11);
  \draw[hb] (01) edge node[right] {\small $\lHB$} (1);
  %% \draw[po] (01) edge (1);
  \draw[po] (02) edge  (1);
  %% \draw[deps,bend left=20] (11)  edge node[right] {\small $\lDEPS$} (12);
  \draw[sw] (2) edge node[above] {\small $\lSW$} (11);
  \draw[hb] (1) edge node[below] {\small $\lHB$} (12);
  \draw[mo,bend right=20] (01)  edge node[left] {\small $\lMO$} (1);
  \draw[mo,bend right=90] (02)  edge node[above] {} (2); %{\small $\lCO$} (2);
\end{tikzpicture}
\]
На третьем этапе полученные сценарии поведения проверяются на соответствие аксиомам модели C/C++11.
Одна из таких аксиом аналогична приведённой выше для JMM:
$$
\begin{array}{l}
\forall r, w. \; \lRF(w, r) \land \lHB(w, r) \Rightarrow \\
\quad \not \exists w'. \; \lCO(w,w') \land \lHB(w, w') \land \lHB(w', r).
\end{array}
$$
Данная аксиома не выполняется для последнего приведенного сценария поведения,
и, как следствие, программа ${\rm MP\text{-}rel\text{-}acq}$ имеет только три корректных
сценария поведения в рамках модели C/C++11 (см. Рис. \ref{fig:MPrelAcqSem}),
соответствующих результатам $[a=0, b = 0]$, $[a = 0, b = 1]$ и $[a = 1, b = 1]$.

\newcommand{\smallLabelFont}{\scriptsize}

\begin{figure}
  \begin{tabular}{c c c}
\begin{tikzpicture}[yscale=1,xscale=1]
  \node (01)  at (-2.5,3) {\smallLabelFont $p: \wlab{\rlx}{x}{0}$ };
  \node (02)  at (0,3) {\smallLabelFont$q: \wlab{\rlx}{y}{0}$ };
  \node (1)  at (-2.5,1.5) {\smallLabelFont$r: \wlab{\rlx}{x}{1}$ };
  \node (2)  at (-2.5,0) {\smallLabelFont$s: \wlab{\rel}{y}{1}$ };
  \node (11) at (0,1.5)  {\smallLabelFont$t: \rlab{\acq}{y}{0}$ };
  \node (12) at (0,0)  {\smallLabelFont$u: \rlab{\rlx}{x}{0}$ };

  \draw[po] (1)  edge  (2);
  \draw[po] (11) edge (12);
  \draw[po] (01) edge (11);
  \draw[po] (02) edge (11);
  %% \draw[hb] (01) edge node[right] {\smallLabelFont $\lHB$} (1);
  \draw[po] (01) edge (1);
  \draw[po] (02) edge  (1);
  %% \draw[deps,bend left=20] (11)  edge node[right] {\small $\lDEPS$} (12);
  %% \draw[sw] (2) edge node[above] {\smallLabelFont $\lSW$} (11);
  %% \draw[hb] (1) edge node[below] {\smallLabelFont $\lHB$} (12);
  \draw[rf,bend left=20] (02) edge node[right] {\smallLabelFont $\lRF$} (11);
  \draw[rf] (01) edge node[below] {\smallLabelFont $\lRF$} (12);
  \draw[mo,bend right=20] (01)  edge node[left] {\smallLabelFont $\lMO$} (1);
  \draw[mo,bend right=90] (02)  edge node[above] {} (2); %{\small $\lCO$} (2);
\end{tikzpicture}
 &
\begin{tikzpicture}[yscale=1,xscale=1]
  \node (01)  at (-2.5,3) {\smallLabelFont $p: \wlab{\rlx}{x}{0}$ };
  \node (02)  at (0,3) {\smallLabelFont$q: \wlab{\rlx}{y}{0}$ };
  \node (1)  at (-2.5,1.5) {\smallLabelFont$r: \wlab{\rlx}{x}{1}$ };
  \node (2)  at (-2.5,0) {\smallLabelFont$s: \wlab{\rel}{y}{1}$ };
  \node (11) at (0,1.5)  {\smallLabelFont$t: \rlab{\acq}{y}{0}$ };
  \node (12) at (0,0)  {\smallLabelFont$u: \rlab{\rlx}{x}{1}$ };

  \draw[po] (1)  edge  (2);
  \draw[po] (11) edge (12);
  \draw[po] (01) edge (11);
  \draw[po] (02) edge (11);
  \draw[po] (01) edge (1);
  \draw[po] (02) edge  (1);
  %% \draw[deps,bend left=20] (11)  edge node[right] {\small $\lDEPS$} (12);
  \draw[rf,bend left=20] (02) edge node[right] {\smallLabelFont $\lRF$} (11);
  \draw[rf] (1)  edge node[below] {\smallLabelFont $\lRF$} (12);
  \draw[mo,bend right=20] (01)  edge node[left] {\smallLabelFont $\lMO$} (1);
  \draw[mo,bend right=90] (02)  edge node[above] {} (2); %{\small $\lCO$} (2);
\end{tikzpicture}
 &
\begin{tikzpicture}[yscale=1,xscale=1]
  \node (01)  at (-2.5,3) {\smallLabelFont $p: \wlab{\rlx}{x}{0}$ };
  \node (02)  at (0,3) {\smallLabelFont$q: \wlab{\rlx}{y}{0}$ };
  \node (1)  at (-2.5,1.5) {\smallLabelFont$r: \wlab{\rlx}{x}{1}$ };
  \node (2)  at (-2.5,0) {\smallLabelFont$s: \wlab{\rel}{y}{1}$ };
  \node (11) at (0,1.5)  {\smallLabelFont$t: \rlab{\acq}{y}{1}$ };
  \node (12) at (0,0)  {\smallLabelFont$u: \rlab{\rlx}{x}{1}$ };

  \draw[po] (1)  edge  (2);
  \draw[po] (11) edge (12);
  \draw[po] (01) edge (11);
  \draw[po] (02) edge (11);
  %% \draw[hb] (01) edge node[right] {\smallLabelFont $\lHB$} (1);
  \draw[po] (01) edge (1);
  \draw[po] (02) edge  (1);
  %% \draw[deps,bend left=20] (11)  edge node[right] {\small $\lDEPS$} (12);
  \draw[rf] (2) edge node[right] {} (11);
  \draw[rf] (1) edge node[below] {\smallLabelFont $\lRF$} (12);
  \draw[mo,bend right=20] (01)  edge node[left] {\smallLabelFont $\lMO$} (1);
  \draw[mo,bend right=90] (02)  edge node[above] {} (2); %{\small $\lCO$} (2);
\end{tikzpicture}
  \end{tabular}
  \caption{Сценарии поведения программы ${\rm MP\text{-}rel\text{-}acq}$ в модели C/C++11}
  \label{fig:MPrelAcqSem}
\end{figure}

\subsubsection{Проблема ``значений из воздуха''}
Для того, чтобы понять, откуда берется проблема ``значений из воздуха'' в модели C/C++11,
рассмотрим программу, которую мы уже обсуждали ранее:
\begin{equation*}
\tag{IF-OOTA-rlx}
\begin{tabular}{c}
  $\writeInstParam{\rlx}{x}{0}; \writeInstParam{\rlx}{y}{0};$ \\
\begin{tabular}{L || L}
  \readInstParam{\rlx}{a}{x}; & \readInstParam{\rlx}{b}{y}; \\
  \begin{array}{@{}l@{}}
  \iteml{a}{\writeInstParam{\rlx}{y}{1}}{\skipc}
  \end{array} &
  \begin{array}{@{}l@{}}
  \iteml{b}{\writeInstParam{\rlx}{x}{1}}{\skipc}
  \end{array} \\
\end{tabular}
\end{tabular}
\end{equation*}
Одним из корректных сценариев поведения этой программы в C/C++ MM является следующий граф,
\[
\begin{tikzpicture}[yscale=1,xscale=1.8]
  \node (01)  at (-2.5,3) {$p: \wlab{\rlx}{x}{0}$ };
  \node (02)  at (0,3) {$q: \wlab{\rlx}{y}{0}$ };
  \node (1)  at (-2.5,1.5) {$r: \rlab{\rlx}{x}{1}$ };
  \node (2)  at (-2.5,0) {$s: \wlab{\rlx}{y}{1}$ };
  \node (11) at (0,1.5)  {$t: \rlab{\rlx}{y}{1}$ };
  \node (12) at (0,0)  {$u: \wlab{\rlx}{x}{1}$ };

  \draw[po] (1)  edge  (2);
  \draw[po] (11) edge (12);
  \draw[po] (01) edge (11);
  \draw[po] (02) edge (11);
  %% \draw[hb] (01) edge node[right] {\smallLabelFont $\lHB$} (1);
  \draw[po] (01) edge (1);
  \draw[po] (02) edge  (1);
  %% \draw[deps,bend left=20] (11)  edge node[right] {\small $\lDEPS$} (12);
  %% \draw[sw] (2) edge node[above] {\smallLabelFont $\lSW$} (11);
  %% \draw[hb] (1) edge node[below] {\smallLabelFont $\lHB$} (12);
  \draw[rf] (2) edge node[below] {\small $\lRF$} (11);
  \draw[rf] (12) edge node[left] {} (1);
  %% \draw[rf] (01) edge node[below] {\smallLabelFont $\lRF$} (12);
  %% \draw[mo,bend right=20] (01)  edge node[left] {\smallLabelFont $\lMO$} (1);
  %% \draw[mo,bend right=90] (02)  edge node[above] {} (2); %{\small $\lCO$} (2);
\end{tikzpicture}
\]
\noindent
который обладает ``значениями из воздуха'', т.к. соответствует результату $a = 1, b = 1$.
В данном случае из программы и графа очевидно, что есть у события $r$ есть циклическая зависимость
от себя самого --- для того, чтобы событие $r$ прочитало $1$, событие $u$ должно записать $1$,
что возможно только если событие $t$ прочитало $1$, которая должна была быть записана событием $s$,
которое случается только если $r$ прочитало $1$!

Мы могли бы попробовать решить данную проблему, добавив в граф отношение зависимости по управлению, $\lCTRL$,
с рёбрами $(r, s)$ и $(t, u)$, а также дополнительную аксиому, которая требовала бы ацикличности
объединения отношений $\lCTRL$ и $\lRF$.
Тогда в приведенном графе был бы цикл $[r, s, t, u, r]$, и сценарий считался бы некорректным с точки
зрения модифицированной модели.

К сожалению, такое решение является неудовлетворительным с точки зрения целей модели C/C++11.
Рассмотрим следующую программу:
\begin{equation*}
\tag{IF-notOOTA-rlx}
\begin{tabular}{c}
  $\writeInstParam{\rlx}{x}{0}; \writeInstParam{\rlx}{y}{0};$ \\
\begin{tabular}{L || L}
  \readInstParam{\rlx}{a}{x}; & \readInstParam{\rlx}{b}{y}; \\
  \begin{array}{@{}l@{}}
  \iteml{a}{\writeInstParam{\rlx}{y}{1}}{\writeInstParam{\rlx}{y}{1}}
  \end{array} &
  \begin{array}{@{}l@{}}
  \iteml{b}{\writeInstParam{\rlx}{x}{1}}{\skipc}
  \end{array} \\
\end{tabular}
\end{tabular}
\end{equation*}
Программа ${\rm IF\text{-}notOOTA\text{-}rlx}$ отличается от ${\rm IF\text{-}OOTA\text{-}rlx}$ лишь тем, что
ветка $\kw{else}$ в первом потоке содержит инструкцию записи $\writeInstParam{\rlx}{y}{1}$.
Наличие этой инструкции позволяет компилятору сделать вывод, что $\writeInstParam{\rlx}{y}{1}$
не зависит от условия конструкции $\kw{if}$, а значит может быть вынесено из неё.
Далее вынесенная операция может быть переупорядочена с независимым чтением $\readInstParam{\rlx}{a}{x}$:
%% {\small
\begin{equation*}
\tag{IF-notOOTA-optimized}
\begin{tabular}{c}
  $\writeInstParam{\rlx}{x}{0}; \writeInstParam{\rlx}{y}{0};$ \\
\begin{tabular}{L || L}
  \writeInstParam{\rlx}{y}{1}; & \readInstParam{\rlx}{b}{y}; \\
  \readInstParam{\rlx}{a}{x}
  &
      \begin{array}{@{}l@{}}
      \iteml{b}{\writeInstParam{\rlx}{x}{1}}{\skipc}
      \end{array}
  \\
\end{tabular}
\end{tabular}
\end{equation*}
%% }
Для получившейся программы результат $a = 1, b = 1$ возможен и в модели SC.

Таким образом, для того, чтобы разрешить использованные трансформации,
модель C/C++11 должна разрешать результат $a = 1, b = 1$ для программы
${\rm IF\text{-}notOOTA\text{-}rlx}$.
Это означает, что мы не можем напрямую использовать предложенное ранее ``исправление'' модели, т.к.
добавление зависимостей по управлению в граф и дополнительной аксиомы в модель сделает результат
$a = 1, b = 1$ некорректным для ${\rm IF\text{-}notOOTA\text{-}rlx}$.

В чём же разница между зависимостями по управлению в левых потоках программ 
${\rm IF\text{-}OOTA\text{-}rlx}$ и ${\rm IF\text{-}notOOTA\text{-}rlx}$?
В обоих случаях есть синтаксическая зависимость инструкции $\writeInstParam{\rlx}{y}{1}$ от
$\readInstParam{\rlx}{a}{x}$, но семантическая зависимость ---
только в случае программы ${\rm IF\text{-}OOTA\text{-}rlx}$.
Соответственно проблема могла бы быть решена, если бы граф сценария поведения добавлялась
семантическая зависимость по управлению \cite{Batty-Sewell:WNote14}.
К сожалению, для более сложных примеров программ наличие семантической зависимости по управлению
требует детального анализа программы.
В следующем разделе мы рассмотрим, какие способы представления семантической зависимости
есть на данный момент.

%% Как следствие, эта программа имеет три корректных сценария поведения (см. Рис. \ref{fig:ifOOTASem}).
%% \begin{figure}
%% \begin{center}
%% \begin{tabular}{c c c}
%% \begin{tikzpicture}[yscale=1,xscale=1]
%%   \node (01)  at (-2.5,3) {\smallLabelFont $p: \wlab{\rlx}{x}{0}$ };
%%   \node (02)  at (0,3) {\smallLabelFont$q: \wlab{\rlx}{y}{0}$ };
%%   \node (1)  at (-2.5,1.5) {\smallLabelFont$r: \rlab{\rlx}{x}{0}$ };
%%   \node (2)  at (-2.5,0) {\smallLabelFont$s: \wlab{\rlx}{y}{1}$ };
%%   \node (11) at (0,1.5)  {\smallLabelFont$t: \rlab{\rlx}{y}{0}$ };
%%   %% \node (12) at (0,0)  {\smallLabelFont$u: \wlab{\rlx}{x}{1}$ };

%%   \draw[po] (1)  edge  (2);
%%   %% \draw[po] (11) edge (12);
%%   \draw[po] (01) edge (11);
%%   \draw[po] (02) edge (11);
%%   %% \draw[hb] (01) edge node[right] {\smallLabelFont $\lHB$} (1);
%%   \draw[po] (01) edge (1);
%%   \draw[po] (02) edge  (1);
%%   %% \draw[deps,bend left=20] (11)  edge node[right] {\small $\lDEPS$} (12);
%%   %% \draw[sw] (2) edge node[above] {\smallLabelFont $\lSW$} (11);
%%   %% \draw[hb] (1) edge node[below] {\smallLabelFont $\lHB$} (12);
%%   \draw[rf,bend left=20] (02) edge node[right] {\smallLabelFont $\lRF$} (11);
%%   \draw[rf,bend right=20] (01) edge node[left] {\smallLabelFont $\lRF$} (1);
%%   %% \draw[rf] (01) edge node[below] {\smallLabelFont $\lRF$} (12);
%%   %% \draw[mo,bend right=20] (01)  edge node[left] {\smallLabelFont $\lMO$} (1);
%%   %% \draw[mo,bend right=90] (02)  edge node[above] {} (2); %{\small $\lCO$} (2);
%% \end{tikzpicture}
%%  &
%% \begin{tikzpicture}[yscale=1,xscale=1]
%%   \node (01)  at (-2.5,3) {\smallLabelFont $p: \wlab{\rlx}{x}{0}$ };
%%   \node (02)  at (0,3) {\smallLabelFont$q: \wlab{\rlx}{y}{0}$ };
%%   \node (1)  at (-2.5,1.5) {\smallLabelFont$r: \rlab{\rlx}{x}{0}$ };
%%   \node (2)  at (-2.5,0) {\smallLabelFont$s: \wlab{\rlx}{y}{1}$ };
%%   \node (11) at (0,1.5)  {\smallLabelFont$t: \rlab{\rlx}{y}{1}$ };
%%   \node (12) at (0,0)  {\smallLabelFont$u: \wlab{\rlx}{x}{1}$ };

%%   \draw[po] (1)  edge  (2);
%%   \draw[po] (11) edge (12);
%%   \draw[po] (01) edge (11);
%%   \draw[po] (02) edge (11);
%%   %% \draw[hb] (01) edge node[right] {\smallLabelFont $\lHB$} (1);
%%   \draw[po] (01) edge (1);
%%   \draw[po] (02) edge  (1);
%%   %% \draw[deps,bend left=20] (11)  edge node[right] {\small $\lDEPS$} (12);
%%   %% \draw[sw] (2) edge node[above] {\smallLabelFont $\lSW$} (11);
%%   %% \draw[hb] (1) edge node[below] {\smallLabelFont $\lHB$} (12);
%%   \draw[rf,bend right=20] (01) edge node[left] {\smallLabelFont $\lRF$} (1);
%%   \draw[rf] (2) edge node[below] {\smallLabelFont $\lRF$} (11);
%%   %% \draw[rf] (12) edge node[left] {} (1);
%%   %% \draw[rf] (01) edge node[below] {\smallLabelFont $\lRF$} (12);
%%   %% \draw[mo,bend right=20] (01)  edge node[left] {\smallLabelFont $\lMO$} (1);
%%   %% \draw[mo,bend right=90] (02)  edge node[above] {} (2); %{\small $\lCO$} (2);
%% \end{tikzpicture}
%%  &
%% \begin{tikzpicture}[yscale=1,xscale=1]
%%   \node (01)  at (-2.5,3) {\smallLabelFont $p: \wlab{\rlx}{x}{0}$ };
%%   \node (02)  at (0,3) {\smallLabelFont$q: \wlab{\rlx}{y}{0}$ };
%%   \node (1)  at (-2.5,1.5) {\smallLabelFont$r: \rlab{\rlx}{x}{1}$ };
%%   \node (2)  at (-2.5,0) {\smallLabelFont$s: \wlab{\rlx}{y}{1}$ };
%%   \node (11) at (0,1.5)  {\smallLabelFont$t: \rlab{\rlx}{y}{1}$ };
%%   \node (12) at (0,0)  {\smallLabelFont$u: \wlab{\rlx}{x}{1}$ };

%%   \draw[po] (1)  edge  (2);
%%   \draw[po] (11) edge (12);
%%   \draw[po] (01) edge (11);
%%   \draw[po] (02) edge (11);
%%   %% \draw[hb] (01) edge node[right] {\smallLabelFont $\lHB$} (1);
%%   \draw[po] (01) edge (1);
%%   \draw[po] (02) edge  (1);
%%   %% \draw[deps,bend left=20] (11)  edge node[right] {\small $\lDEPS$} (12);
%%   %% \draw[sw] (2) edge node[above] {\smallLabelFont $\lSW$} (11);
%%   %% \draw[hb] (1) edge node[below] {\smallLabelFont $\lHB$} (12);
%%   \draw[rf] (2) edge node[below] {\smallLabelFont $\lRF$} (11);
%%   \draw[rf] (12) edge node[left] {} (1);
%%   %% \draw[rf] (01) edge node[below] {\smallLabelFont $\lRF$} (12);
%%   %% \draw[mo,bend right=20] (01)  edge node[left] {\smallLabelFont $\lMO$} (1);
%%   %% \draw[mo,bend right=90] (02)  edge node[above] {} (2); %{\small $\lCO$} (2);
%% \end{tikzpicture}
%% \end{tabular}
%% \end{center}
%%   \caption{Сценарии поведения программы ${\rm IF\text{-}notOOTA}$ в модели C/C++11}
%% \label{fig:ifOOTASem}
%% \end{figure}

%% Заметим, что мы можем получить третий граф с Рис. \ref{fig:ifOOTASem} по программе ${\rm IF\text{-}OOTA}$, используя
%% приведенный выше алгоритм построения сценариев поведения в модели C/C++11.
%% При этом для ${\rm IF\text{-}OOTA}$ результат $a = 1, b = 1$, представляемый этим графом,
%% имеет ``значения из воздуха'' и нежелателен.
%% К сожалению, в рамках текущего подхода построения сценариев поведения, запрет
%% таких сценариев для некоторых программ  не представляется возможным,
%% т.к. после построения предзапусков (первый шаг алгоритма) программа более не участвует
%% в процессе, хотя наличие или отсутствие ``значений из воздуха'' в некотором сценарий
%% является характеристикой программы.

Стоит отметить, что в стандартах C \cite{C:11} и C++ \cite{CPP:11, CPP:14} упомянутую проблему пытаются решить
путём прямого запрета сценариев поведения со ``значениями из воздуха''.
Данный запрет является неформальным, поскольку в стандарте отсутствует формальное определение
``значений из воздуха''.
Так, в \cite{Boehm-Demsky:MSPC14} отмечается, что это решение проблемы также неудовлетворительно.

%% \app{TODO: описать локальные изменения модели, предложенные Виктором и Ори.}

\subsection{Теоретические модели памяти}
В этом разделе мы вкратце рассмотрим альтернативные теоретические модели памяти для языков программирования.

Работа \cite{Nienhuis-al:OOPSLA16} представляет операционную семантику на базе модели C/C++11.
Эта семантика по предзапуску программы инкрементально строит полный сценарий поведения.
Данный подход решает проблему интеграции модели C/C++11 c остальным описанием стандарта \cite{Memarian-al:PLDI16},
однако оставляет проблему ``значений из воздуха'', а также не предоставляет операционной интуиции
о поведении программы.

В \cite{Crary-Sullivan:POPL15} предлагается альтернативный подход к пометке инструкций обращений к памяти.
Вместо того, чтобы помечать часть инструкций ``строгими'' модификаторами такими как $\acq$, $\rel$ и $\sco$,
и таким образом неявно запрещать переупорядочивания инструкций вокруг них, K. Crary и M. Sullivan предлагают
явно указывать в программе порядок исполнения каких пар инструкций должен быть сохранён.
Такой подход потенциально позволяет эффективнее компилировать программы в целевую платформу.
Сама модель памяти в данной работе представлена в операционном виде.
К недостаткам модели стоит отнести то, что в ней позволяются сценарии поведения со ``значениями из воздуха''.

В работе \cite{PichonPharabod-Sewell:POPL16} представлена модели памяти на основе \emph{структур событий}
(event structures) \cite{Winskel:AC86, Winskel:LTBT88}.
Так вместо того, чтобы представлять семантику программы как множество несвязанных графов,
в этом подходе она представляется как структура событий --- один большой граф,
в котором дополнительно появляется \emph{отношение конфликта}.
Последнее позволяет разделять вершины, относящиеся к разным сценарием поведения --- каждый максимальный подграф
структуры, в котором нет конфликтующих событий, является сценарием поведения в аксиоматическом смысле.
Поскольку все сценарии представляются согласованно в структуре событий, данная семантика может проверять
наличие семантической зависимости между событиями.
В частности, для программы ${\rm IF\text{-}notOOTA\text{-}rlx}$ семантика может заметить, что вне зависимости
от того, какое значение читается в регистр $a$ левым потоком, он исполняет запись $\writeInstParam{\rlx}{y}{1}$,
а, значит, между соответствующими чтением и записью нет зависимости.
Аналогично для программы ${\rm IF\text{-}OOTA\text{-}rlx}$ семантика может определить наличие зависимости.
Данная модель обладает тремя недостатками.
Во-первых, она поддерживает только фиксированное множество компиляторных оптимизаций,
которые явным образом представлены как переходы в модели.
Во-вторых, модель определена только для подмножества языка C/C++, содержащего только
неатомарные и расслабленные операции чтения и записи, а также захват и высвобождение замков.
В-третьих, модель не поддерживает эффективную компиляцию в модель
ARMv8 POP \cite{Flur-al:POPL16}\footnote{В главе \ref{sec:armpop} мы рассмотрим программу ${\rm ARM\text{-}weak}$.
Эта программа обладает слабым поведением, которое не проявляется в модели \cite{PichonPharabod-Sewell:POPL16}.}.

Близкий подход к заданию модели памяти без ``значений из воздуха'' представлен в \cite{Jeffrey-Riely:LICS16}.
В этой модели, в отличие от использования явных переписываний структуры событий с помощью фиксированного
набора оптимизаций, существует процесс валидации корректных сценариев поведения, похожий на аналогичный
механизм в JMM. Процесс валидации базируется на идеи \emph{игры} для двух игроков.
В ней первый игрок пытается обойти подграф структуры событий, соответствующий проверяемому сценарию,
тогда как второй игрок встревает в этот обход, добавляя в конфигурацию обхода произвольные вершины
и пытаясь помешать первому.
При наличии выигрышной стратегии у первого игрока считается, что сценарий исполнения корректен с точки зрения
модели.
Эта игра является представлением недетерминированного переключения контекстов со стороны процессора.
Для модели формально доказано утверждение, косвенно подтверждающие отсутствие проблемы ``значений из воздуха''.
К недостаткам стоит отнести то, что модель не поддерживает некоторые базовые оптимизации, в частности, 
перестановка независимых чтений.

%% \begin{table}[t]
%%   \begin{center}
%%   \begin{tabular}{r || c | c | c | c | c}
%%     {\bf НМ}& {\bf ЭК} & {\bf КО} & {\bf Нет OOTA} & {\bf Реж. C/C++11} & {\bf ОИ}  \\
%%     \midrule
%%     SC        \cite{Lamport:TC79}                 & \fail & \fail & \tick & -- & \tick \\
%%     C/C++11   \cite{Batty-al:POPL11}              & \tick & \tick$^{*}$ & \fail & \tick & \fail \\
%%     OpC/C++11 \cite{Nienhuis-al:OOPSLA16}         & \tick & \tick$^{*}$ & \fail & \tick & \fail \\
%%     Java      \cite{Manson-al:POPL05}             & \tick & \fail & \fail & -- & \fail \\
%%     EventOp   \cite{PichonPharabod-Sewell:POPL16} & \fail & \tick & \tick & \fail & \fail \\
%%     EventGame \cite{Jeffrey-Riely:LICS16}         & \fail & \fail & \tick & \fail & \fail \\
%%     RMC \cite{Crary-Sullivan:POPL15} & ? & \tick
%%   \end{tabular}
%%   \end{center}
%%   \label{tbl:plmmrequirements}
%%   \caption[Соответствие существующих моделей памяти для языков программирования основным требованиям]
%%     {Соответствие существующих моделей памяти для языков программирования основным требованиям, где
%%      {\bf НМ} --- название модели,
%%      {\bf ЭК} --- наличие эффективной схемы компиляции в целевые платформы,
%%      {\bf КО} --- поддержка компиляторных оптимизаций,
%%      {\bf Нет OOTA} --- отсутствие OOTA,
%%      {\bf Реж. C/C++11} --- поддержка режимов C/C++11,
%%      {\bf ОИ} --- обладает операционной интуицией;
%%      \tick --- выполняется,
%%      \fail --- не выполняется,
%%      \tick$^{*}$ --- выполняется для локально модифицированной модели,
%%      `--' --- критерий не применим
%%   }
%% \end{table}

%% \section{Различные подходы к заданию моделей памяти}

%% \subsection{Операционные модели}
%% \subsection{Аксиоматические (декларативные) модели}
%% \subsection{Денотационные модели}

%% Данное заключение неверно для моделей, в том числе для обещающей и ARMv8.3
%% моделей. Рассмотрим, как слабое поведение $a = 1, b = 0$ достигается при исполнении ${\rm MP}$
%% в обещающей модели памяти.

%% План
%% \begin{itemize} 
%%   \item Определение. Модель памяти
%%   \item Определение. Модель последовательной консистентности
%%   \item Мотивировка. Пример слабого исполнения
%%   \item Определение. Слабый сценарий исполнения
%%   \item Определение. Слабая модель памяти
%%   \item Существующие модели
%%   \begin{itemize}
%%     \item Языки
%%       \begin{itemize}
%%         \item C/C++
%%         \item Java
%%         \item ?? LLVM ??
%%         \item ?? .Net ??
%%       \end{itemize}
%%     \item Процессоры
%%       \begin{itemize}
%%         \item x86
%%         \item Power
%%         \item ARM
%%         \item DEC Alpha (видимая спекуляция потоков)
%%       \end{itemize}
%%   \end{itemize}
%%   \begin{itemize}
%%     \item Модель памяти C/C++11. Недостатки
%%       \begin{itemize}
%%         \item OOTA (out-of-thin-air)
%%         \item Нет операционной интуиции
%%       \end{itemize}
%%     \item Модель памяти Java. Недостатки
%%       \begin{itemize}
%%         \item Оптимизации некорректны
%%         \item Нет операционной интуиции
%%       \end{itemize}
%%   \end{itemize}
%%   \item Определение. Операционная модель памяти
%%   \item Определение. Декларативная (аксиоматическая) модель памяти
%% \end{itemize}


%% \section{Модели памяти}
%% \subsection{Виды моделей памяти}

\section{Выводы}
На основе проделанного обзора сделаны следующие выводы.
\begin{itemize}
  \item Модель памяти промышленного языка программирования должна удовлетворять, как минимум, трём критериям.
    Во-первых, должна существовать корректная схема компиляции в модель целевой процессорной
    архитектуры.
    Во-вторых, основные компиляторные оптимизации должны быть корректны в рамках модели.
    В-третьих, у модели должна отсутствовать проблема ``значений из воздуха''.
  \item При разработке новой модели памяти языка программирования нужно доказывать корректность эффективной компиляции
     в модели памяти целевых процессорных архитектур.
  \item Существующие модели памяти промышленных языков программирования не удовлетворяют всем приведённым выше
    критериям.
  \item Требуется разработать операционную модель памяти с синтаксисом модели C/C++11, которая
    не имеет проблемы ``значений из воздуха''.
  %% \item ``Обещающая'' модель памяти является перспективной альтернативой существующей модели памяти C/C++.
\end{itemize}
