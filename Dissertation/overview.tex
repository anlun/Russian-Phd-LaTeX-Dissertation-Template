\chapter{Обзор предметной области} \label{sec:overview}
В данной главе вводятся понятия: модель памяти, слабая модель памяти;
приводится примеры. Описываются
классы моделей памяти: операционные, аксиоматические (декларативные),
денотационные.
Рассматриваются существующие модели памяти языков программирования и
процессорных архитектур, а также требования, предъявляемые к ним.
Приводится описание проблемы ``значений из воздуха'' (OOTA, out-of-thin-air values).
Подробно описывается модель памяти C/C++11 \cite{Batty-al:POPL11}.
В конце главы приведены выводы о состоянии предметной области и о существующих
направлениях исследования.

\section{Модели памяти, слабые сценарии поведения}
Под \emph{моделью памяти} мы будем понимать семантику системы с многопоточностью.
В рамках диссертационного исследования рассматриваются два типа таких систем:
языки программирования и процессорные архитектуры.

Модели памяти разделяются по принципу того, какие ограничения на сценарии поведения
программ они предоставляют \cite{Kshemkalyani-Singhal:2011}.
Так, \emph{строгая консистентность} гарантирует, что любая запись в память становится мгновенно видна
всем потокам в системе. Эта модель требует наличия некоторого абсолютного счётчика времени, разделяемого между потоками системы,
что зачастую является недостижимым требованием. Менее строгая модель \emph{последовательной консистентности} \cite{Lamport:TC79}
(SC, sequential consistency)
предполагает, что любой сценарий исполнения может быть получен исполнением программных потоков на одном вычислительном
ядре с вытесняющей многозадачностью. Это означает, что все операции над памятью, совершаемые потоками в рамках сценария исполнения,
могут быть упорядочены, и полученный порядок согласуется с порядком инструкций в самих потоках.
Сценарии поведения программ, которые не могут быть получены в рамках модели SC, называются
\emph{слабыми}, а модели, допускающие слабые сценарии поведения, --- \emph{слабыми моделями памяти}.

Несмотря на то, что модель SC кажется наиболее естественной, а статья \cite{Lamport:TC79},
в которой модель описывается, называется ``How to make a multiprocessor computer that correctly executes multiprocess programs'',
современные процессорные архитектуры и языки программирования используют слабые модели памяти. Такое положение вещей
связано с тем, что слабые модели позволяют реализовать большее число оптимизаций как на уровне процессора
\cite{Hennessy-Patterson:BOOK}, так и на уровне компилятора \cite{Aho-al:BOOK86,Muchnick:BOOK97},
что увеличивает производительность программ.

Рассмотрим следующую программу ${\rm MP}$ (передача сообщения, message passing).
%% которая обладает слабым поведением на большинстве современных программных архитектур:
\begin{equation*}
\tag{MP}\label{ex:MP}
\begin{tabular}{L || L}
  \writeInst{x}{1}; & \readInst{a}{y}; ~\valuecom{1} \\
  \writeInst{y}{1}; & \readInst{b}{x}; ~\valuecom{0} \\
\end{tabular}
\end{equation*}
Эта программа является упрощенным примером передачи данных между потоками.
Первый поток записывает данные в локацию $x$ и потом выставляет флаг (локация $y$),
что данные подготовлены; в свою очередь второй поток проверяет флаг, а потом читает данные.
Модель SC гарантирует, что если второй поток увидел, что
флаг выставлен ($a = 1$), то он увидит и подготовленные данные ($b = 1$).
Тем не менее, эта программа имеет слабый сценарий исполнения ($a = 1, b = 0$) на таких архитектурах как Power, ARM.

С чем связано то, что на упомянутых выше архитектурах возможен результат $a = 1, b = 0$?
Оптимизирующий процессор при исполнении программы может выполнить независимые инструкции не по порядку.
Поскольку первая и вторая инструкции в левом потоке являются обращениями к разным локациям, то процессор может выполнить
сначала вторую запись, а потом --- первую.
Аналогичное верно и для инструкций в правом потоке.
После исполнения инструкций не по порядку хотя бы в одном потоке результат $a = 1, b = 0$ становится возможным.

Такой сценарий поведения также разрешается и моделями памяти некоторых языков программирования, например, стандартами языков
C11 \cite{C:11} и C++11 \cite{CPP:11}, поскольку оптимизирующий компилятор должен иметь возможность переупорядочить независимые обращения
к памяти.

\subsection{О корректности программы ${\rm MP}$. Гонки по данным}
Стоит отметить, что с точки зрения некоторых языков программирования программа ${\rm MP}$ может считаться некорректной,
т.к. в этой программе есть \emph{гонка по данным} \cite{Unger:ITC95}.
\begin{definition}
  \label{def:datarace}
  В программе есть \emph{гонка по данным}, если в некотором её сценарии исполнения существуют два неупорядоченных
  обращения к одной и той же ячейке памяти, причём как минимум одно из этих обращений является операцией записи.
\end{definition}
Данное определение до некоторой степени неформально, т.к. мы не определяем порядок на операциях над памятью.
Это связано с тем, что в разных моделях он определяется существенно по-разному.
Идейно, два обращения неупорядочены, если то, в каком порядке они будут исполнены, определяется не логикой
программы, а внешними факторами, такими как диспетчеризация потоков.

В отсутствии гонок по данным большинство слабых моделей памяти гарантируют, что все сценарии поведения программы
являются SC-поведениями. Для того, чтобы добиться отсутствия гонок даже при использовании общей памяти (shared memory),
применяют \emph{блокировки} (locks), которые упорядочивают обращения к разделяемому ресурсу.

Как следствие, один из способов задать модель памяти для языка программирования выглядит следующим образом:
``если в программе нет гонок по данным, то её поведение определяется моделью SC, иначе --- программа некорректна и
обладает неопределенным поведением (undefined behavior)''.
У такого способа есть, как минимум, два недостатка.
Во-первых, языки программирования  (например, Java), предоставляющие или пытающиеся предоставить
\emph{типобезопасность} (type safety), не могут использовать такой способ задания семантики,
т.к. гарантируют, что программа не может иметь неопределенное поведение, если она прошла проверку типов, а
наличие или отсутствие гонок по данным не может быть статически проверено. 
Во-вторых, многие высокопроизводительные алгоритмы многопоточного программирования используют парадигму
\emph{неблокирующей синхронизации} (non-blocking synchronization), которая существенным образом опирается
на гонки по данным. Более того, в большинстве случаев реализация самих блокировок использует гонки по данным,
что делает невозможным рассуждения о ней в рамках приведенной выше упрощённой модели.

Из вышесказанного следует, что модель памяти промышленного языка программирования должна давать семантику,
как минимум, некоторому кругу программ с гонками по данным.

\section{Требования к моделям памяти}
На данный момент существует множество моделей памяти, как для процессорных архитектур
\cite{Sewell-al:CACM10,Alglave-al:TOPLAS14,Flur-al:POPL16,Pulte-al:POPL18,Sarkar-al:PLDI11,Kavanagh-Brookes:CoRR17},
так и для языков программирования
\cite{Crary-Sullivan:POPL15,Lamport:TC79,Boudol-al:EXPRESS12,Boudol-Petri:POPL09,PichonPharabod-Sewell:POPL16,Jeffrey-Riely:LICS16,
Nienhuis-al:OOPSLA16,Batty-al:POPL11,Manson-al:POPL05}.
Существенным отличием между этими группами моделей является то, какие требования к ним предъявляются.

Модели процессорных архитектур должны описывать поведения существующих процессоров, а также оставлять пространство
для возможных оптимизаций в будущем.
Кроме того такие модели зачастую либо заданы \emph{операционно}, т.е. в терминах некоторой
абстрактной машины \cite{Diehl-al:FGCS00}, либо имеют эквивалентное операционное представление.
Это позволяет определить модель в терминах, близких и понятных разработчикам самой архитектуры, а также предоставить
операционную интуицию разработчикам компиляторов в эту платформу.

Модель памяти языка программирования должна быть представлена таким образом, чтобы, с одной стороны,
она разрешала манипуляции над кодом программы, совершаемые в рамках компиляторных оптимизаций, и давала возможность
эффективно компилировать программы в целевую процессорную архитектуру, а, с другой стороны, предоставляла
разумные гарантии для программиста.
Эти требования к модели языка программирования до некоторой степени противоречат друг другу, поэтому хорошая модель
соблюдает баланс между ними.
Для того, чтобы понять, в чём заключается противоречие данных требований, опишем их подробнее.

\subsection{Корректность компиляторных оптимизаций}
Пусть есть некоторый язык $\LL$ и его модель памяти $\MM$. Тогда под \emph{семантикой программы $\PP$ на языке $\LL$ в модели $\MM$}
мы будем понимать множество возможных сценариев поведения $\PP$ в $\MM$ и обозначать $\sem{\PP}_\MM$.
%% \begin{definition}
\emph{Оптимизацией над программами в языке $\LL$} мы будем называть функцию $\opt : \LL \rightarrow \LL$, действующую из
множества программ на языке $\LL$ в него же.
%% \end{definition}
\begin{definition}
  Оптимизация $\opt : \LL \rightarrow \LL$ называется \emph{корректной в модели $\MM$},
  $\correctOpt_\MM(\opt)$, если для любой программы $\PP$ на языке $\LL$
  семантика оптимизированной программы $\opt(\PP)$ является подмножеством семантики изначальной программы $\PP$.
  \[\forall \opt : \LL \rightarrow \LL. \; \correctOpt_\MM(\opt) \Leftrightarrow (\forall \PP \in \LL. \; \sem{\opt(\PP)}_\MM \subseteq \sem{\PP}_\MM). \]
\end{definition}

Какие компиляторные оптимизации должны быть корректны в рамках модели памяти языка программирования?
К сожалению, на данный момент научное сообщество не выработало полный список, однако из работ
\cite{Vafeiadis-al:POPL15,Morisset-al:PLDI13,Sevcik-Aspinall:ECOOP08} можно выделить пять основных групп таких оптимизаций.
\begin{enumerate}
  \item Локальные оптимизации, не меняющие обращения к памяти в возможных сценариях исполнения.
    Например, удаление условных переходов, зависимых от заведомо ложного условия:
    \[
      \begin{array}{l c l}
        \begin{array}{l}
        \assignInst{a}{0}; \\
        \iteml{a}{\readInst{b}{x}}{\skipc;} \\
        \readInst{c}{y}; \\
        \end{array}
        & \optarrow &
        \begin{array}{l}
          \assignInst{a}{0}; \\
          \skipc; \\
          \readInst{c}{y}
        \end{array}
      \end{array}
    \]
  \item Перестановка обращений к памяти.
    Например, перестановка инструкций чтения из разных локаций:
    \[
      \begin{array}{l c l}
        \begin{array}{l}
        \readInst{a}{x}; \\
        \readInst{b}{y}
        \end{array}
        & \optarrow &
        \begin{array}{l}
        \readInst{b}{y}; \\
        \readInst{a}{x}
        \end{array}
      \end{array}
    \]
  \item Устранение избыточных обращений к памяти.
    Например, устранение инструкции чтения, следующей за инструкциями чтения или записи в ту же локацию:
    \[
    \begin{array}{c c c}
      \begin{array}{l c l}
        \begin{array}{l}
        \readInst{a}{x}; \\
        \readInst{b}{x}
        \end{array}
        & \optarrow &
        \begin{array}{l}
        \readInst{a}{x}; \\
        \assignInst{b}{a}
        \end{array}
      \end{array}
      & \qquad &
      \begin{array}{l c l}
        \begin{array}{l}
        \writeInst{x}{a}; \\
        \readInst{b}{x}
        \end{array}
        & \optarrow &
        \begin{array}{l}
        \writeInst{x}{a}; \\
        \assignInst{b}{a}
        \end{array}
      \end{array}
    \end{array}
    \]
  \item Вставка избыточных обращений к памяти. Например, вставка инструкции чтения в переменную,
    значение которой далее нигде не используется.
  \item Глобальные оптимизации. Например, \emph{секвенциализация} (sequentialization),
    которая заменяет параллельную композицию потоков на последовательную:
    \[
      \begin{array}{l c l}
      C_1\;||\;C_2 & \optarrow & C_1;\;C_2
      \end{array}
    \]
\end{enumerate}

Желательно, чтобы оптимизаций, относящиеся к упомянутыми группам, были корректными, возможно, с некоторыми оговорками
в модели памяти языка программирования.
Для этого модель должна быть достаточно слабой, т.е. позволять для изначальной программы сценарии поведения, которые
возможны для программы после оптимизации.

\subsection{Наличие эффективной схемы компиляции}
Модель памяти языка программирования должна учитывать модель памяти целевой платформы.
Так, должна существовать корректная схема компиляции между моделями, позволять корректно компилировать программы.

\begin{definition}
Пусть есть некоторые языки $\LL$ и $\LowLL$ и соответствующие модели памяти $\MM$ и $\LowMM$.
%% причём $\LL$ является исходным языком, а $\LowLL$ --- целевым для некоторой схемы компиляции $\complScheme : \LL \rightarrow \LowLL$.
Функция $\complScheme : \LL \rightarrow \LowLL$ является \emph{корректной схемой компиляции из модели $\MM$ в модель $\LowMM$},
если для любой программы $\PP$ на языке $\LL$ семантика программы $\complScheme(\PP)$ в модели $\LowMM$ является подмножеством
семантики $\PP$ в модели $\MM$.
\end{definition}

Из определения следует, что чем слабее модель целевой платформы, т.е. чем больше существует сценариев поведения на целевой платформе,
тем больше ограничений накладывается на корректную схему компиляции.

Рассмотрим то, как должна быть устроена корректная схема компиляции из более строгой модели памяти в более слабую на примере
компиляции ранее приведенной программы ${\rm MP}$ из модели SC \cite{Lamport:TC79} в модель архитектуры Power \cite{Alglave-al:TOPLAS14}.
В рамках модели SC программа ${\rm MP}$ не имеет сценария поведения $a=1, b=0$, тогда как в модели Power такой сценарий возможен.
Для того, чтобы получить корректную компиляцию, в скомпилированную программу нужно вставить специальные инструкции, т.н. \emph{барьеры памяти}.
Барьеры вносят дополнительные ограничения на сценарии поведения программ.
Достигается это за счёт того, что барьеры запрещают некоторые компиляторные и процессорные оптимизации.
В архитектуре Power есть барьер $\hwsync$, который запрещает процессору переупорядочивать любые обращения к памяти,
Вставка такого барьера между инструкций в программе ${\rm MP}$ гарантирует отсутствие сценария поведения $a=1, b=0$ в модели
Power\footnote{Здесь и далее в
  диссертации мы используем один и тот же с точностью до барьеров и модификаторов чтения и записи синтаксис
  для описания как исходных, так и скомпилированных программ.
%% Мы могли бы использовать ассемблероподобный синтаксис для последних, но в этом нет необходимости ввиду того, что .
}.
\begin{equation*}
\tag{MP-hwsync}\label{ex:MP-hwsync}
\begin{tabular}{L || L}
  \writeInst{x}{1}; & \readInst{a}{y}; \\
  \hwsync;          &  \hwsync;        \\
  \writeInst{y}{1}; & \readInst{b}{x}; \\
\end{tabular}
\end{equation*}
На ряду с $\hwsync$ архитектура Power также предоставляет более слабый барьер $\lwsync$,
который запрещает только перестановки пар инструкций чтение-чтение, чтение-запись и запись-запись.
Такого барьера также достаточно, чтобы запретить сценарий $a=1, b=0$.
\begin{equation*}
\tag{MP-lwsync}\label{ex:MP-hwsync}
\begin{tabular}{L || L}
  \writeInst{x}{1}; & \readInst{a}{y}; \\
  \lwsync;          &  \lwsync;        \\
  \writeInst{y}{1}; & \readInst{b}{x}; \\
\end{tabular}
\end{equation*}
В данном случае схема компиляции, использующая барьер $\lwsync$, является более предпочтительной по сравнению
со $\hwsync$-схемой, т.к. барьер $\lwsync$ исполняется быстрее (или, как минимум, не медленнее), чем $\hwsync$
на реальных процессорах.

Если рассмотреть модель памяти языка программирования, которая разрешает сценарий поведения $a=1,b=0$
(на ряду со всеми остальными сценариями, возможными в рамках модели SC), то для компиляции программы
${\rm MP}$ из такой модели в модель Power не будет необходимости вставлять барьеры памяти.
Например, модели C/C++11 \cite{Batty-al:POPL11} и Java \cite{Manson-al:POPL05} разработаны таким образом, чтобы
обычные операции чтения и записи\footnote{В разделе \ref{sec:cppmodel} мы рассмотрим различные модификаторы, которыми могут
быть помечены инструкции работы с памятью в модели C/C++11, и ``обычные операции чтения и записи'' будут соответствовать
атомарным расслабленным и неатомарным инструкциям.
Все инструкции работы с памятью из примеров программ, приведённых к этому моменту, были ``обычными''.}
могли быть скомпилированы без вставки барьеров памяти в случае компиляции в платформы x86, Power и ARM.

Именно подобные схемы компиляции мы будем называть \emph{эффективными}.
Соответственно, как было видно из рассмотренных схем компиляции из модели SC в модель Power, между моделями
не существует эффективной компиляции.
Очевидно, что для того, чтобы существовала эффективная схема компиляции из модели языка программирования в модель
целевой платформы, должно выполняться следующее утверждение:
модель исходного языка должна позволять все сценарии поведения для программы без барьеров,
которые позволяет целевая модель памяти для скомпилированной версии программы, в которой также не используются барьеры.
Аналогично требованию на корректность оптимизаций, наличие эффективной схемы компиляции ``увеличивает'' число
слабых поведений, дозволяемых в рамках модели.

%% Поскольку барьеры памяти запрещают определенные оптимизации, их присутствие замедляет исполнение программ.
%% Для того, чтобы уменьшить такой эффект, но при этом сохранить корректность компиляции, 

\app{TODO: Описать цену сохранения SC.}
%% [13] D. Marino, A. Singh, T. Millstein, M. Musuvathi, and
%%      S. Narayanasamy. A case for an SC-preserving compiler. In

\subsection{Гарантии программисту} %Отсутствие ``значений из воздуха''}
Требование о том, что модель памяти языка программирования должна предоставлять разумные
гарантии программисту звучит крайне неформально.
Попробуем сформулировать его более конкретно.

Очевидно, что программист должен иметь представление о том, как ведется себя программа, над
которой он работает, а поведение программы как раз определяется моделью памяти.
Как следствие, желательно, чтобы модель памяти была как можно более простой и понятной,
а также существовал формальный инструментарий для рассуждения о программах в рамках модели.
Простота это очень субъективный критерий, особенно при сравнении слабых моделей памяти,
тогда как наличие и выразительная сила инструментов анализа программ может быть
использована для более точного сопоставления моделей.

Существуют различные методологии для анализа программ.
Среди них стоит выделить \emph{методы проверки моделей} (model checking) \cite{Peled-al:BOOK08,Clarke-al:BOOK99} и
\emph{верификации по Хоару} (Hoare logic) \cite{Hoare:CACM69}.
Оба метода зарекомендовали себя в приложении к модели SC
\cite{Owicki-Gries:AI76,Owicki-Gries:CACM76,OHearn:CONCUR04,Bornat-al:POPL05,Hobor-al:ESOP08,Dockins-al:ENTCS08,
Hobor-Gherghina:ESOP11,Gotsman-al:APLAS07,Jacobs-Piessens:POPL11,Svendsen-Birkedal:ESOP14,DinsdaleYoung-al:ECOOP10,Jung-al:POPL15,
LeyWild-Nanevski:POPL13,Sergey-al:PLDI15,Vechev-al:STTT13,Raychev-al:SAS13}.
Существуют также и работы, посвященные слабым моделям памяти
\cite{Kaiser-al:ECOOP17,Vafeiadis-Narayan:OOPSLA13,Turon-al:OOPSLA14,Lahav-Vafeiadis:ICALP15,Meshman-al:FMCAD15,Dan-al:SAS13}.
В последних отмечается, что если модель памяти разрешает сценарии поведения программ с т.н.
\emph{``значениями из воздуха''} (out-of-thin-air values, OOTA),
то класс свойств, которые могут быть проверены или доказаны для программ в рамках модели, существенным образом ограничивается.
В частности, модель памяти C/C++11 разрешает такие сценарии.

Что же такое ``значения из воздуха''? К сожалению, на данный момент не существует точного определения \cite{Boehm-Demsky:MSPC14},
однако существует набор примеров таких поведений, а также признак наличия ``значений из воздуха''.
Последний звучит следующим образом: если в сценарии поведения программы, в которой нет арифметических выражений,
появляется некоторое значение (например, это значение присваивается переменной или записывается в память), при чём это
значение явным образом не фигурирует в тексте программы, то такой сценарий обладает ``значениями из воздуха''.

Рассмотрим следующую программу:
\begin{equation*}
\tag{LB-OOTA}\label{ex:LBoota}
\begin{tabular}{c}
  $\writeInst{x}{0}; \writeInst{y}{0};$ \\
\begin{tabular}{L || L}
  \readInst{a}{x};  & \readInst{b}{y}; \\
  \writeInst{y}{a}; & \writeInst{x}{b}; \\
\end{tabular}
\end{tabular}
\end{equation*}
В этой программе нет арифметических операций и $0$ является единственным значением,
которое явным образом встречается в тексте программы.
По приведенному выше признаку любой сценарий поведения этой программы,
в результате которого значение переменной $a$ или $b$ отличается от $0$,
обладает ``значением из воздуха''. Такие сценарии разрешаются для этой программы
в рамках модели C/C++11 \cite{Batty-al:POPL11}.

Рассмотрим другую программу, некоторые сценарии исполнения которой в рамках
модели C/C++11 также считаются \cite{Boehm-Demsky:MSPC14} обладающими
``значениями из воздуха'', но не подпадающую под признак:
\begin{equation*}
\tag{IF-OOTA}\label{ex:IFoota}
\begin{tabular}{c}
  $\writeInst{x}{0}; \writeInst{y}{0};$ \\
\begin{tabular}{L || L}
  \readInst{a}{x}; & \readInst{b}{y}; \\
  \begin{array}{@{}l@{}}
  \iteml{a}{\writeInst{y}{1}}{\skipc;}
  \end{array} &
  \begin{array}{@{}l@{}}
  \iteml{b}{\writeInst{x}{1}}{\skipc;}
  \end{array} \\
\end{tabular}
\end{tabular}
\end{equation*}
Казалось бы, что единственным результатом исполнения этой программы может быть
$a = b = 0$, но модель C/C++11 также разрешает $a = b = 1$.

Сценарии поведения со ``значениями из воздуха'' всегда имеют некоторую
циклическую зависимость между встречаюшимися в них значениями.
Как следствие, они не проявляются на современных
процессорах\footnote{Сценарии поведения со ``значениями из воздуха''
проявляются на процессорах семейства DEC Alpha \cite{DecAlpha},
но данная архитектура снята с производства.}
и не могут быть получены как результат разумной оптимизации.
То, что некоторые модели разрешают такие сценарии обычно является
результатом того, что в рамках подхода, выбранного для задания модели,
тяжело или невозможно запретить ``значения из воздуха''
и, при этом, не запретить нужные оптимизации \cite{Batty-al:ESOP15}.

%% Таким образом, критерий предоставления разумных гарантий программисту
%% со стороны модели памяти 


%% Если модель разрешает манипуляции над кодом, такие как перестановка инструкций, это означает, что семантика изначальной
%% программы в рамках модели должна включать себя 

%% , абсолютное большинство которых являются слабыми моделями.
%% Все эти модели являются слабыми.

%% Среди процессорных моделей стоит выделить модели архитектур x86 \cite{Sewell-al:CACM10,Owens-al:TPHOL09},
%% Power \cite{Alglave-al:TOPLAS14,Sarkar-al:PLDI11} и ARM \cite{Flur-al:POPL16,Pulte-al:POPL18}, т.к. данные архитектуры являются
%% наиболее распространенными на данный момент.

%% В последние годы научное сообщество в сотрудничестве с индустрией разработало множество моделей памяти, как для процессорных архитектур
%% (x86-TSO \cite{Sewell-al:CACM10}, Power \cite{Alglave-al:TOPLAS14}, ARM \cite{Flur-al:POPL16,Pulte-al:POPL18}),
%% так и для языков программирования (Java \cite{Manson-al:POPL05}, C/C++11 \cite{Batty-al:POPL11}).
%% Все эти модели являются слабыми.

\section{Существующие модели памяти ЯП}
Среди моделей памяти, разработанных для языков программирования, есть как используемые на практике,
т.е. являющиеся частями стандартов языков \cite{Gosling-al:BOOK96,JavaStandard,C:11,CPP:11}, так и теоретические работы
\cite{Crary-Sullivan:POPL15,Lamport:TC79,Boudol-al:EXPRESS12,Boudol-Petri:POPL09,PichonPharabod-Sewell:POPL16,Jeffrey-Riely:LICS16}.
Далее в этом разделе мы обсудим модели памяти языков Javа \cite{JavaStandard} и C/C++ \cite{C:11,CPP:11},
выделим их достоинства и недостатки, а также рассмотрим, как упомянутые недостатки решаются в существующих
теоретических моделях.

\subsection{Модель памяти Java}
Впервые модель памяти для языка Java была представлена в стандарте 1996 года \cite{Gosling-al:BOOK96}.
Эта модель обладала рядом фундаментальных недостатков \cite{Pugh:JAVA99,Pugh:CPE00} и была заменена на
новую модель \cite{Manson-al:POPL05}, которую дальше мы будем называть моделью памяти Java, или JMM (Java memory model).
JMM была разработана из расчёта на то, что бы запретить ``значения из воздуха'' и разрешить базовые компиляторные оптимизации.
К сожалению, она не соблюдает последнее требование \cite{Sevcik-Aspinall:ECOOP08} ---
в рамках JMM некорректными являются оптимизации удаление чтения после чтения (redundant read after read elimination),
удаление чтения после записи (redundant read after write elimination),
удаление записи после чтения (redundant write after read elimination),
добавление неиспользуемого чтения (irrelevant read introduction) и другие.
Далее в этом разделе мы рассмотрим ключевые понятия модели.

Сценарий поведения программы в JMM представляется как граф, в котором вершинами
являются \emph{события} (actions, events), происходящие в памяти, а помеченными ребрами ---
отношения на событиях.
События бывают нескольких типов, из которых мы выделим четыре основных:
чтение, запись, захват замка (lock), высвобождение замка (unlock).
Чтения и записи, в свою очередь, бывают обычные (non-volatile) и \emph{синхронизирующие} (volatile).
Первые оперируют на обычных локациях в памяти (переменных), тогда как синхронизирующие -- на
\emph{изменчивых} (volatile) локациях.
Как понятно из названия соответствующего типа событий чтения и записи, изменчивые локации выделены как
локации, через обращение к которым происходит синхронизация.

Отметим пять отношений, используемых в сценариях поведения JMM.
Во-первых, \emph{программный порядок} (program order, $\lPO$).
Для каждого потока он является тотальным порядком на событиях, относящихся к этому потоку.
Во-вторых,  отношение \emph{``читает из''} (reads from, $\lRF$).
Оно связывает событие записи с читающими из него событиями.
В-третьих, \emph{синхронизационный порядок} (synchronization order, $\lSO$).
Это некоторый тотальный порядок на синхронизирующих событиях и событиях захвата и высвобождения замков,
который согласуется с $\lPO$ и $\lRF$ на синхронизирующих событиях.
В-четвертых, отношение \emph{``синхронизируется с''} (synchronizes-with, $\lSW$).
$\lSW$ связывает события $a$ и $b$, если $\lRF$ связывает $a$ и $b$ и эти события оперируют над изменчивой локацией,
или если они связаны $\lSO$ и $a$ является высвобождением некоторого замка, а $b$ --- захватом этого же замка.
В-пятых, отношение \emph{``предшествует''} (happens-before, $\lHB$).
$\lHB$ является транзитивным замыканием объединения $\lPO$ и $\lSW$, и именно это отношение определяет порядок
на событиях из определения \ref{def:datarace} для JMM.

Сценарий исполнения считается корректным в JMM, только если выполняются \emph{аксиомы} модели.
Одной из аксиом является то, что событие чтения не может читать из события записи, если они находятся
в отношении $\lHB$ и существует событие записи в ту же локацию, которое находится между ними в отношении $\lHB$.
Формально,
$$
\begin{array}{l}
\forall r, w. \; \lRF(w, r) \land \lHB(w, r) \Rightarrow \\
\quad \not \exists w'. \; \lLOC(w) = \lLOC(w') \land \lHB(w, w') \land \lHB(w', r),
\end{array}$$
где $\lLOC$ --- это функция, которая по событию возвращает локацию, над которой событие оперирует.
Благодаря этой аксиоме, JMM запрещает результат $a = 1, b = 0$ для версии программы ${\rm MP}$, в которой локация
$y$ помечена как изменчивая.
\begin{equation*}
\tag{MP-volatile}\label{ex:MPvolatile}
\begin{tabular}{L || L L}
  \writeInst{x}{1}; & \readInstVolatile{a}{y}; & \valuefail{1} \\
  \writeInstVolatile{y}{1}; & \readInst{b}{x}; & \valuefail{0} \\
\end{tabular}
\end{equation*}
Для того, чтобы проверить данное утверждение, построим соответствующий граф.
\[
\begin{tikzpicture}[yscale=1,xscale=1.8]
  \node (01)  at (-2.5,2) {$a: \wlab{}{x}{0}$ };
  \node (02)  at (0,2) {$b: \wlab{volatile}{y}{0}$ };
  \node (1)  at (-2.5,1) {$c: \wlab{}{x}{1}$ };
  \node (2)  at (-2.5,0) {$d: \wlab{volatile}{y}{1}$ };
  \node (11) at (0,1)  {$e: \rlab{volatile}{y}{1}$ };
  \node (12) at (0,0)  {$f: \rlab{}{x}{0}$ };

  \draw[po] (1)  edge  (2);
  \draw[po] (11) edge (12);
  \draw[po] (01) edge (11);
  \draw[po] (02) edge (11);
  %% \draw[hb] (01) edge node[left] {\small $\lHB$} (1);
  \draw[po] (01) edge (1);
  \draw[po] (02) edge  (1);
  %% \draw[deps,bend left=20] (11)  edge node[right] {\small $\lDEPS$} (12);
  \draw[rf] (01)  edge node[above] {\small $\lRF$} (12);
  \draw[sw] (2)  edge node[below] {\small $\lSW$} (11);
  %% \draw[hb] (1) edge node[above] {\small $\lHB$} (12);
  %% \draw[mo,bend right=20] (01)  edge node[left] {\small $\lCO$} (1);
  %% \draw[mo,bend right=90] (02)  edge node[above] {} (2); %{\small $\lCO$} (2);
\end{tikzpicture}
\]
В этом графе шесть событий. События $a$ и $b$ соответствуют инициализирующим записям в локации $x$ и $y$,
а остальные --- инструкциям из ${\rm MP\text{-}volatile}$.
Недописанные дуги --- это дуги отношения $\lPO$. На этом рисунке не представлены дуги отношения $\lHB$,
однако $\lHB$ связывает $a$ и $c$ (т.к. $\lPO \suq \lHB$), а также $c$ и $f$ (т.к. $\lPO(c, d)$, $\lSW(d, e)$, $\lPO(e,f)$ и
$\lHB = (\lPO \cup \lSW)^{+}$).
Таким образом, данный граф противоречит приведенной выше аксиоме и не является корректным в JMM.

Отметим, что если бы локация $y$ не была бы помечена как изменчивая, тогда события $d$ и $e$ имели бы
обычный тип и между ними бы не было ребра $\lSW$, а значит аксиома бы выполнялась и результат $a = 1; b = 0$
был бы возможным.

%% Сценарий поведения программы в JMM представляется как кортеж следующего вида:
%% $$
%% \tup{P, A, \xrightarrow{po}, \xrightarrow{so}, W, V, \xrightarrow{sw}, \xrightarrow{hb}},
%% $$
%% где $P$ --- программа, $A$ --- множество событий (actions, events), $\xrightarrow{}$

%% В JMM локации в памяти (или переменные) разделяются на два типа: \emph{обычные} (normal) и \emph{изменчивые} (volatile).

Для того, чтобы запретить сценарии поведения со ``значениями из воздуха'', в JMM используется процесс
валидации сценариев.
В рамках процесса строится серия сценариев, каждый из которых является корректным с точки зрения аксиом JMM,
при этом последним в серии является валидируемый сценарий.
Также каждому сценарию в серии присваивается множество добавленных (committed) событий.
Эти множества монотонно растут в серии, а последнее равняется множеству всех событий в графе валидируемого сценария.
При этом на каждом шаге трансформации в серии сохраняется подмножество отношения $\lHB$, заданное на добавленных
событиях.

В работе \cite{Sevcik-Aspinall:ECOOP08} утверждается, что именно из-за процесса валидации упомянутые выше оптимизации
некорректны в JMM.

\subsection{Модель памяти C/C++}
\label{sec:cppmodel}
В последние годы научным сообществом было уделено особое внимание модели памяти C/C++,
которая появилась в стандартах языков в 2011 году \cite{C:11,CPP:11}.
Она не претерпела существенных изменений в последующих стандартах 2014 \cite{CPP:14} и 2017 \cite{CPP:17} годов,
и поэтому в литературе обычно не различают понятия ``модель памяти C/C++'' и ``модель памяти C/C++11''.
Далее мы будем использовать термин ``модель памяти C/C++11'' или ``C/C++11 MM''.

Базовым результатом о модели является её формализация в работе \cite{Batty-al:POPL11};
мы будем подразумевать под моделью C/C++11 именно эту формализацию.
Существуют работы, посвященные корректности компиляции и оптимизаций
\cite{Batty-al:POPL12,Vafeiadis-al:POPL15,Chakraborty-Vafeiadis:CGO16,Lahav-al:PLDI17,Batty-al:POPL16},
логикам для формальных рассуждений о программах
\cite{Turon-al:OOPSLA14,Vafeiadis-Narayan:OOPSLA13,Lahav-Vafeiadis:ICALP15,Doko-Vafeiadis:VMCAI16,Vafeiadis:CPP15}
и другим результатам о модели
\cite{Batty-al:POPL13,Batty-al:ESOP15,Lidbury-Donaldson:POPL17, Tassarotti-al:PLDI15,Doko-Vafeiadis:ESOP17}.
Как следствие, модель C/C++11 является одной из самых проработанных моделей памяти ЯП.
Тем не менее, она не лишена недостатков, в том числе ``значений из воздуха''.

Аналогично модели JMM, в C/C++11 MM сценарий поведения программы представляется в виде графа,
вершинами которого также являются события над памятью,
а локации бывают двух типов --- неатомарные (non-atomic) и атомарные (atomic).
В отличие от случая Java, разделение между ними менее строгое,
т.к. языки C/C++ разрешают совершать преобразование типов, и, как следствие,
на один и тот же адрес в памяти может ссылаться две переменных в программе, одна из которых будет
иметь атомарный тип, а другая --- неатомарный.
Как следствие, в C/C++11 MM обращения к одной и той же локации могут быть как неатомарными, так и атомарными.
Последние в свою очередь также подразделяются на несколько категорий в зависимости от типа обращения ---
чтение, запись или одновременное чтение-запись (RMW, read-modify-write).
Описание последних мы опустим для краткости.

Событие чтения может быть неатомарным, \emph{расслабленным} (relaxed),
\emph{потребляющим} (consume), \emph{приобретающим} (acquire)
или \emph{последовательно-консистентным} (sc, sequentially-consistent).
Событие записи может быть неатомарным, \emph{расслабленным} (relaxed),
\emph{высвобождающим} (release)
или \emph{последовательно-консистентным} (sc, sequentially-consistent).
В обоих случаях виды обращений упорядочены по тому, сколько гарантий они предоставляют.
Расслабленные обращения похожи на обычные обращения в модели JMM, тогда как
последовательно-консистентные --- на синхронизирующие.
Неатомарные обращения предоставляют наименьшие гарантии: если неатомарное обращение
является частью гонки по данным, то программа имеет неопределенное поведение в C/C++11 MM.

%% События имеют несколько типов, среди которых: чтение, запись, атомарное чтение-запись (RMW, read-modify-write),
%% барьер памяти, захват замка, высвобождение замка.


\app{TODO: описать базовые механизмы модели, построение исполнений в модели и т.д.}

\begin{table}[t]
  \begin{center}
  \begin{tabular}{r || c | c | c | c | c}
    {\bf НМ}& {\bf ЭК} & {\bf КО} & {\bf Нет OOTA} & {\bf Реж. C/C++11} & {\bf ОИ}  \\
    \midrule
    SC        \cite{Lamport:TC79}                 & \fail & \fail & \tick & -- & \tick \\
    C/C++11   \cite{Batty-al:POPL11}              & \tick & \tick$^{*}$ & \fail & \tick & \fail \\
    OpC/C++11 \cite{Nienhuis-al:OOPSLA16}         & \tick & \tick$^{*}$ & \fail & \tick & \fail \\
    Java      \cite{Manson-al:POPL05}             & \tick & \fail & \fail & -- & \fail \\
    EventOp   \cite{PichonPharabod-Sewell:POPL16} & \fail & \tick & \tick & \fail & \fail \\
    EventGame \cite{Jeffrey-Riely:LICS16}         & \fail & \fail & \tick & \fail & \fail \\
  \end{tabular}
  \end{center}
  \label{tbl:plmmrequirements}
  \caption[Соответствие существующих моделей памяти для языков программирования основным требованиям]
    {Соответствие существующих моделей памяти для языков программирования основным требованиям, где
     {\bf НМ} --- название модели,
     {\bf ЭК} --- наличие эффективной схемы компиляции в целевые платформы,
     {\bf КО} --- поддержка компиляторных оптимизаций,
     {\bf Нет OOTA} --- отсутствие OOTA,
     {\bf Реж. C/C++11} --- поддержка режимов C/C++11,
     {\bf ОИ} --- обладает операционной интуицией;
     \tick --- выполняется,
     \fail --- не выполняется,
     \tick$^{*}$ --- выполняется для локально модифицированной модели,
     `--' --- критерий не применим
  }
\end{table}



%% \section{Различные подходы к заданию моделей памяти}

%% \subsection{Операционные модели}
%% \subsection{Аксиоматические (декларативные) модели}
%% \subsection{Денотационные модели}

%% Данное заключение неверно для моделей, в том числе для обещающей и ARMv8.3
%% моделей. Рассмотрим, как слабое поведение $a = 1, b = 0$ достигается при исполнении ${\rm MP}$
%% в обещающей модели памяти.

%% План
%% \begin{itemize} 
%%   \item Определение. Модель памяти
%%   \item Определение. Модель последовательной консистентности
%%   \item Мотивировка. Пример слабого исполнения
%%   \item Определение. Слабый сценарий исполнения
%%   \item Определение. Слабая модель памяти
%%   \item Существующие модели
%%   \begin{itemize}
%%     \item Языки
%%       \begin{itemize}
%%         \item C/C++
%%         \item Java
%%         \item ?? LLVM ??
%%         \item ?? .Net ??
%%       \end{itemize}
%%     \item Процессоры
%%       \begin{itemize}
%%         \item x86
%%         \item Power
%%         \item ARM
%%         \item DEC Alpha (видимая спекуляция потоков)
%%       \end{itemize}
%%   \end{itemize}
%%   \begin{itemize}
%%     \item Модель памяти C/C++11. Недостатки
%%       \begin{itemize}
%%         \item OOTA (out-of-thin-air)
%%         \item Нет операционной интуиции
%%       \end{itemize}
%%     \item Модель памяти Java. Недостатки
%%       \begin{itemize}
%%         \item Оптимизации некорректны
%%         \item Нет операционной интуиции
%%       \end{itemize}
%%   \end{itemize}
%%   \item Определение. Операционная модель памяти
%%   \item Определение. Декларативная (аксиоматическая) модель памяти
%% \end{itemize}


%% \section{Модели памяти}
%% \subsection{Виды моделей памяти}

\section{Выводы}
%% На основе ранее выполненного обзора делаются следующие выводы.
\begin{itemize}
  \item Модель памяти промышленного языка программирования должна удовлетворять, как минимум, трём критериям.
    Во-первых, должна существовать корректная схема компиляции в модель целевой процессорной
    архитектуры.
    Во-вторых, основные компиляторные оптимизации должны быть корректны в рамках модели.
    В-третьих, у модели должна отсутствовать проблема ``значений из воздуха''.
  \item При разработке новой модели памяти языка программирования нужно доказывать корректность эффективной компиляции
     в модели памяти целевых процессорных архитектур.
  \item Существующие модели памяти промышленных языков программирования не удовлетворяют всем приведённым выше
    критериям.
  \item Требуется разработать операционную модель памяти с синтаксисом модели C/C++11, которая
    не имеет проблемы ``значений из воздуха''.
  %% \item ``Обещающая'' модель памяти является перспективной альтернативой существующей модели памяти C/C++.
\end{itemize}
