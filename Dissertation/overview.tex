\chapter{Обзор предметной области} \label{sec:overview}
В данной главе вводится понятие модели памяти, слабой модели памяти,
приводится примеры слабых сценариев поведения программ. Описываются
классы моделей памяти: операционные, аксиоматические (декларативные),
денотационные.
Рассматриваются существующие модели памяти языков программирования и
процессорных архитектур, а также требования, предъявляемые к ним.
Приводится подробное описание модели памяти C/C++11 \cite{Batty-al:POPL11}.
Описывается проблема ``значений из воздуха'' (OOTA, out-of-thin-air values).
В конце главы приведены выводы о состоянии предметной области и о существующих
направлениях исследования в ней.

\section{Модели памяти, слабые сценарии поведения}
Под \emph{моделью памяти} мы будем понимать семантику системы с многопоточностью.
В рамках диссертационного исследования рассматриваются два типа таких систем:
языки программирования и процессорные архитектуры.

Модели памяти разделяются по принципу того, какие ограничения на сценарии поведения
программ, запущенных в системе определения модели, они предоставляют \cite{Kshemkalyani-Singhal:2011}.
Так, \emph{строгая консистентность} гарантирует, что любая запись в память становится мгновенно видна
всем потокам в системе. Эта модель требует наличия некоторого абсолютного времени, разделяемого между потоками системы,
что зачастую является недостижимым требованием. Менее строгая модель \emph{последовательной консистентности} \cite{Lamport:TC79}
(SC, sequential consistency)
предполагает, что любой сценарий исполнения может быть получен исполнением программных потоков на одном вычислительном
ядре с вытесняющей многозадачностью. Это означает, что все операции над памятью, совершаемые потоками в рамках сценария исполнения,
могут быть упорядочены, и полученный порядок согласуется с порядком инструкций в самих потоках.
Сценарии поведения программ, которые не могут быть получены в рамках модели SC, называются
\emph{слабыми}, а модели, допускающие слабые сценарии поведения, --- \emph{слабыми моделями памяти}.

Несмотря на то, что модель SC кажется наиболее естественной, а статья \cite{Lamport:TC79},
в которой модель описывается, называется ``How to make a multiprocessor computer that correctly executes multiprocess programs'',
современные процессорные архитектуры и языки программирования используют слабые модели памяти. Такое положение вещей
связано с тем, что слабые модели позволяют реализовать большее число оптимизаций как на уровне процессора, так и на уровне
компилятора, что увеличивает производительность программ.

Рассмотрим следующую программу ${\rm MP}$ (передача сообщения, message passing).
%% которая обладает слабым поведением на большинстве современных программных архитектур:
\begin{equation*}
\tag{MP}\label{ex:MP}
\begin{tabular}{L || L}
  \writeInst{x}{1}; & \readInst{a}{y}; ~\valuecom{1} \\
  \writeInst{y}{1}; & \readInst{b}{x}; ~\valuecom{0} \\
\end{tabular}
\end{equation*}
Эта программа является упрощенным вариантом шаблона, используемого для передачи
данных между потоками. Первый поток записывает данные в локацию $x$ и потом выставляет флаг (локация $y$),
что данные подготовлены; в свою очередь второй поток проверяет флаг, а потом читает данные.
Модель SC гарантирует, что если второй поток увидел, что
флаг выставлен ($a = 1$), то он увидит и подготовленные данные ($b = 1$).
Тем не менее, эта программа имеет слабый сценарий исполнения ($a = 1, b = 0$) на таких архитектурах как Power, ARM.

С чем связано то, что на упомянутых выше архитектурах возможен результат $a = 1, b = 0$?
Оптимизирующий процессор при исполнении программы может выполнить независимые инструкции не по порядку.
Поскольку первая и вторая инструкции в левом потоке являются обращениями к разным локациям, то процессор может выполнить
сначала вторую запись, а потом --- первую.
Аналогичное верно и для инструкций в правом потоке.
После исполнения инструкций не по порядку хотя бы в одном потоке результат $a = 1, b = 0$ становится возможным.

Такой сценарий поведения также разрешается и моделями памяти некоторых языков программирования, например, стандартами языков
C11 \cite{C:11} и C++11 \cite{CPP:11}, поскольку оптимизирующий компилятор должен иметь возможность переупорядочить независимые обращения
к памяти.

\section{Требования к моделям памяти}
На данный момент существует множество моделей памяти, как для процессорных архитектур
\cite{Sewell-al:CACM10,Alglave-al:TOPLAS14,Flur-al:POPL16,Pulte-al:POPL18,Sarkar-al:PLDI11,Kavanagh-Brookes:CoRR17},
так и для языков программирования
\cite{Crary-Sullivan:POPL15,Lamport:TC79,Boudol-al:EXPRESS12,Boudol-Petri:POPL09,PichonPharabod-Sewell:POPL16,Jeffrey-Riely:LICS16,
Nienhuis-al:OOPSLA16,Batty-al:POPL11,Manson-al:POPL05}.
Существенным отличием между этими группами моделей является то, какие требования к ним предъявляются.

Модели процессорных архитектур должны описывать поведения существующих процессоров, а также оставлять пространство
для возможных оптимизаций в будущем.
Кроме того такие модели зачастую либо заданы \emph{операционно}, т.е. в терминах некоторой
абстрактной машины \cite{Diehl-al:FGCS00}, либо имеют эквивалентное операционное представление.
Это позволяет определить модель в терминах, близких и понятных разработчикам самой архитектуры, а также предоставить
операционную интуицию разработчикам компиляторов в эту платформу.

Модель памяти языка программирования должна быть представлена таким образом, чтобы, с одной стороны,
разрешать манипуляции над кодом программы, совершаемые в рамках компиляторных оптимизаций, и давать возможность
эффективно компилировать программы в целевую процессорную архитектуру, а, с другой стороны, предоставлять
разумные гарантии для программиста, использующего данный язык.
Эти требования к модели языка программирования до некоторой степени противоречат друг другу, поэтому хорошая модель
соблюдает баланс между ними.
Для того, чтобы понять, в чём заключается противоречие данных требований, опишем их подробнее.

\subsection{Корректность компиляторных оптимизаций}
Пусть есть некоторый язык $\LL$ и его модель памяти $\MM$. Тогда под \emph{семантикой программы $\PP$ на языке $\LL$ в модели $\MM$}
мы будем понимать множество возможных сценариев поведения $\PP$ в $\MM$ и обозначать $\sem{\PP}_\MM$.
%% \begin{definition}
\emph{Оптимизацией над программами в языке $\LL$} мы будем называть функцию $\opt : \LL \rightarrow \LL$, действующую из
множества программ на языке $\LL$ в него же.
%% \end{definition}
\begin{definition}
  Оптимизация $\opt : \LL \rightarrow \LL$ называется \emph{корректной в модели $\MM$},
  $\correctOpt_\MM(\opt)$, если для любой программы $\PP$ на языке $\LL$
  семантика оптимизированной программы $\opt(\PP)$ является подмножеством семантики изначальной программы $\PP$.
  \[\forall \opt : \LL \rightarrow \LL. \; \correctOpt_\MM(\opt) \Leftrightarrow (\forall \PP \in \LL. \; \sem{\opt(\PP)}_\MM \subseteq \sem{\PP}_\MM). \]
\end{definition}

Какие компиляторные оптимизации должны быть корректны в рамках модели памяти языка программирования?
К сожалению, на данный момент научное сообщество не выработало полный список, однако из работ
\cite{Vafeiadis-al:POPL15,Morisset-al:PLDI13,Sevcik-Aspinall:ECOOP08} можно выделить пять основных групп таких оптимизаций.
\begin{enumerate}
  \item Локальные оптимизации, не меняющие обращения к памяти в возможных сценариях исполнения.
    Например, удаление условных переходов, зависимых от заведомо ложного условия:
    \[
      \begin{array}{l c l}
        \begin{array}{l}
        \assignInst{a}{0}; \\
        \iteml{a}{\readInst{b}{x}}{\skipc;} \\
        \readInst{c}{y}; \\
        \end{array}
        & \optarrow &
        \begin{array}{l}
          \assignInst{a}{0}; \\
          \skipc; \\
          \readInst{c}{y}
        \end{array}
      \end{array}
    \]
  \item Перестановка обращений к памяти.
    Например, перестановка инструкций чтения из разных локаций:
    \[
      \begin{array}{l c l}
        \begin{array}{l}
        \readInst{a}{x}; \\
        \readInst{b}{y}
        \end{array}
        & \optarrow &
        \begin{array}{l}
        \readInst{b}{y}; \\
        \readInst{a}{x}
        \end{array}
      \end{array}
    \]
  \item Устранение избыточных обращений к памяти.
    Например, устранение инструкции чтения, следующей за инструкциями чтения или записи в ту же локацию:
    \[
    \begin{array}{c c c}
      \begin{array}{l c l}
        \begin{array}{l}
        \readInst{a}{x}; \\
        \readInst{b}{x}
        \end{array}
        & \optarrow &
        \begin{array}{l}
        \readInst{a}{x}; \\
        \assignInst{b}{a}
        \end{array}
      \end{array}
      & \qquad &
      \begin{array}{l c l}
        \begin{array}{l}
        \writeInst{x}{a}; \\
        \readInst{b}{x}
        \end{array}
        & \optarrow &
        \begin{array}{l}
        \writeInst{x}{a}; \\
        \assignInst{b}{a}
        \end{array}
      \end{array}
    \end{array}
    \]
  \item Вставка избыточных обращений к памяти. Например, вставка инструкции чтения в переменную,
    значение которой далее нигде не используется.
  \item Глобальные оптимизации. Например, \emph{секвенциализация} (sequentialization),
    которая заменяет параллельную композицию потоков на последовательную:
    \[
      \begin{array}{l c l}
      C_1\;||\;C_2 & \optarrow & C_1;\;C_2
      \end{array}
    \]
\end{enumerate}

Желательно, чтобы оптимизаций, относящиеся к упомянутыми группам, были корректными, возможно, с некоторыми оговорками
в модели памяти языка программирования.
Для этого модель должна быть достаточно слабой, т.е. позволять для изначальной программы сценарии поведения, которые
возможны для программы после оптимизации.

\subsection{Наличие эффективной схемы компиляции}
Модель памяти языка программирования должна учитывать модель памяти целевой платформы.
Так, должна существовать корректная схема компиляции между моделями, позволять корректно компилировать программы.

\begin{definition}
Пусть есть некоторые языки $\LL$ и $\LowLL$ и соответствующие модели памяти $\MM$ и $\LowMM$.
%% причём $\LL$ является исходным языком, а $\LowLL$ --- целевым для некоторой схемы компиляции $\complScheme : \LL \rightarrow \LowLL$.
Функция $\complScheme : \LL \rightarrow \LowLL$ является \emph{корректной схемой компиляции из модели $\MM$ в модель $\LowMM$},
если для любой программы $\PP$ на языке $\LL$ семантика программы $\complScheme(\PP)$ в модели $\LowMM$ является подмножеством
семантики $\PP$ в модели $\MM$.
\end{definition}

Из определения следует, что чем слабее модель целевой платформы, т.е. чем больше существует сценариев поведения на целевой платформе,
тем больше ограничений накладывается на корректную схему компиляции.

Рассмотрим то, как должна быть устроена корректная схема компиляции из более строгой модели памяти в более слабую на примере
компиляции ранее приведенной программы ${\rm MP}$ из модели SC \cite{Lamport:TC79} в модель архитектуры Power \cite{Alglave-al:TOPLAS14}.
В рамках модели SC программа ${\rm MP}$ не имеет сценария поведения $a=1, b=0$, тогда как в модели Power такой сценарий возможен.
Для того, чтобы получить корректную компиляцию, в скомпилированную программу нужно вставить специальные инструкции, т.н. \emph{барьеры памяти}.
Барьеры вносят дополнительные ограничения на сценарии поведения программ.
Достигается это за счёт того, что барьеры запрещают некоторые компиляторные и процессорные оптимизации.
В архитектуре Power есть барьер $\hwsync$, который запрещает процессору переупорядочивать любые обращения к памяти,
Вставка такого барьера между инструкций в программе ${\rm MP}$ гарантирует отсутствие сценария поведения $a=1, b=0$ в моделе Power
\footnote{Здесь и далее в диссертации мы используем один и тот же с точностью до барьеров и модификаторов чтения и записи синтаксис
  для описания как исходных, так и скомпилированных программ.
%% Мы могли бы использовать ассемблероподобный синтаксис для последних, но в этом нет необходимости ввиду того, что .
}.
\begin{equation*}
\tag{MP-hwsync}\label{ex:MP-hwsync}
\begin{tabular}{L || L}
  \writeInst{x}{1}; & \readInst{a}{y}; \\
  \hwsync;          &  \hwsync;        \\
  \writeInst{y}{1}; & \readInst{b}{x}; \\
\end{tabular}
\end{equation*}
На ряду с $\hwsync$ архитектура Power также предоставляет более слабый барьер $\lwsync$,
который запрещает только перестановки пар инструкций чтение-чтение, чтение-запись и запись-запись.
Такого барьера также достаточно, чтобы запретить сценарий $a=1, b=0$.
\begin{equation*}
\tag{MP-lwsync}\label{ex:MP-hwsync}
\begin{tabular}{L || L}
  \writeInst{x}{1}; & \readInst{a}{y}; \\
  \lwsync;          &  \lwsync;        \\
  \writeInst{y}{1}; & \readInst{b}{x}; \\
\end{tabular}
\end{equation*}
В данном случае схема компиляции, использующая барьер $\lwsync$, является более предпочтительной по сравнению
со $\hwsync$-схемой, т.к. барьер $\lwsync$ исполняется быстрее (или, как минимум, не медленнее), чем $\hwsync$
на реальных процессорах.

Если рассмотреть модель памяти языка программирования, которая разрешает сценарий поведения $a=1,b=0$
(на ряду со всеми остальными сценариями, возможными в рамках модели SC), то для компиляции программы
${\rm MP}$ из такой модели в модель Power не будет необходимости вставлять барьеры памяти.
Например, модели C/C++11 \cite{Batty-al:POPL11} и Java \cite{Manson-al:POPL05} разработаны таким образом, чтобы
обычные операции чтения и записи\footnote{В разделе \ref{sec:cppmodel} мы рассмотрим различные модификаторы, которыми могут
быть помечены инструкции работы с памятью в модели C/C++11, и ``обычные операции чтения и записи'' будут соответствовать
атомарным расслабленным и неатомарным инструкциям.
Все инструкции работы с памятью из примеров программ, приведённых к этому моменту, были ``обычными''.}
могли быть скомпилированы без вставки барьеров памяти в случае компиляции в платформы x86, Power и ARM.

Именно подобные схемы компиляции мы будем называть \emph{эффективными}.
Соответственно, как было видно из рассмотренных схем компиляции из модели SC в модель Power, между моделями
не существует эффективной компиляции.
Очевидно, что для того, чтобы существовала эффективная схема компиляции из модели языка программирования в модель
целевой платформы, для любой программы без барьеров памяти из исходного языка модель языка должна быть
позволять все сценарии поведения, которые позволяет целевая модель памяти для скомпилированной без барьеров
программы.
Аналогично требованию на корректность оптимизаций, требование наличия корректной схемы компиляции устремляет
модель языка программирования к большей слабости.

%% Поскольку барьеры памяти запрещают определенные оптимизации, их присутствие замедляет исполнение программ.
%% Для того, чтобы уменьшить такой эффект, но при этом сохранить корректность компиляции, 

\subsection{Гарантии программисту} %Отсутствие ``значений из воздуха''}
Требование о том, что модель памяти языка программирования должна предоставлять разумные
гарантии программисту звучит крайне неформально.
Попробуем сформулировать его более конкретно.

Очевидно, что программист должен иметь представление о том, как ведется себя программа, над
которой он работает, а поведение программы как раз определяется моделью памяти.
Как следствие, желательно, чтобы модель памяти была как можно более простой и понятной,
а также существовал формальный инструментарий для рассуждения о программах в рамках модели.
Простота это очень субъективный критерий, особенно при сравнении слабых моделей памяти,
тогда как наличие и выразительная сила инструментов анализа программ может быть
использована для более точного сопоставления моделей.

Существуют различные методологии для анализа программ.
Среди них стоит выделить \emph{методы проверки моделей} (model checking) \cite{Peled-al:BOOK08,Clarke-al:BOOK99}
и \emph{верификации по Хоару} (Hoare logic) \cite{Hoare:CACM69}.

Самой понятной и естественной моделью поведения многопоточных программ, как уже было отмечено ранее,
является модель SC.
Для этой модели были разработаны 


должна быть максимально проста для во

, о предоставлении разумных
гарантий программисту
Тем не менее, попробуем сформулировать его конкретнее.


Тем не менее, оно может быть сформулировано в 

Несмотря на то, что требование к модели памяти языка програо предоставлении разумных гарантий программисту 

Данное требование является наиболее размытым и нефор

%% Если модель разрешает манипуляции над кодом, такие как перестановка инструкций, это означает, что семантика изначальной
%% программы в рамках модели должна включать себя 

%% , абсолютное большинство которых являются слабыми моделями.
%% Все эти модели являются слабыми.

%% Среди процессорных моделей стоит выделить модели архитектур x86 \cite{Sewell-al:CACM10,Owens-al:TPHOL09},
%% Power \cite{Alglave-al:TOPLAS14,Sarkar-al:PLDI11} и ARM \cite{Flur-al:POPL16,Pulte-al:POPL18}, т.к. данные архитектуры являются
%% наиболее распространенными на данный момент.

%% В последние годы научное сообщество в сотрудничестве с индустрией разработало множество моделей памяти, как для процессорных архитектур
%% (x86-TSO \cite{Sewell-al:CACM10}, Power \cite{Alglave-al:TOPLAS14}, ARM \cite{Flur-al:POPL16,Pulte-al:POPL18}),
%% так и для языков программирования (Java \cite{Manson-al:POPL05}, C/C++11 \cite{Batty-al:POPL11}).
%% Все эти модели являются слабыми.

Упомянутые выше модели памяти процессорных архитектур являются 


\cite{Batty-al:ESOP15}

%% \cite{Crary-Sullivan:POPL15,Lamport:TC79,Boudol-al:EXPRESS12,Boudol-Petri:POPL09,PichonPharabod-Sewell:POPL16,Jeffrey-Riely:LICS16,
\begin{table}[t]
  \begin{center}
  \begin{tabular}{r || c | c | c | c | c}
    {\bf НМ}& {\bf ЭК} & {\bf КО} & {\bf Нет OOTA} & {\bf Реж. C/C++11} & {\bf ОИ}  \\
    \midrule
    SC        \cite{Lamport:TC79}                 & \fail & \fail & \tick & -- & \tick \\
    C/C++11   \cite{Batty-al:POPL11}              & \tick & \tick$^{*}$ & \fail & \tick & \fail \\
    OpC/C++11 \cite{Nienhuis-al:OOPSLA16}         & \tick & \tick$^{*}$ & \fail & \tick & \fail \\
    Java      \cite{Manson-al:POPL05}             & \tick & \fail & \fail & -- & \fail \\
    EventOp   \cite{PichonPharabod-Sewell:POPL16} & \fail & \tick & \tick & \fail & \fail \\
    EventGame \cite{Jeffrey-Riely:LICS16}         & \fail & \fail & \tick & \fail & \fail \\
  \end{tabular}
  \end{center}
  \label{tbl:plmmrequirements}
  \caption{Соответствие существующих моделей памяти для языков программирования основным требованиям, где
    {\bf НМ} --- название модели,
    {\bf ЭК} --- наличие эффективной схемы компиляции в целевые платформы,
    {\bf КО} --- поддержка компиляторных оптимизаций,
    {\bf Нет OOTA} --- отсутствие OOTA,
    {\bf Реж. C/C++11} --- поддержка режимов C/C++11,
    {\bf ОИ} --- обладает операционной интуицией;
    \tick --- выполняется,
    \fail --- не выполняется,
    \tick$^{*}$ --- выполняется для локально модифицированной модели,
    `--' --- критерий не применим
  }
\end{table}

\section{Различные подходы к заданию моделей памяти}

\subsection{Операционные модели}
\subsection{Аксиоматические (декларативные) модели}
\subsection{Денотационные модели}

\section{Модель памяти C/C++11}
\label{sec:cppmodel}

Данной модели памяти посвящено множество работ
\cite{Batty-al:POPL12,Batty-al:POPL13,Lahav-al:PLDI17,Chakraborty-Vafeiadis:CGO16,Vafeiadis-al:POPL15,Vafeiadis:CPP15}

В том числе были предложены логики для рассуждений о программах в этой модели
\cite{Turon-al:OOPSLA14,Vafeiadis-Narayan:OOPSLA13,Lahav-Vafeiadis:ICALP15,Doko-Vafeiadis:VMCAI16}
и использованы для доказательства корректности
алгоритмов в рамках модели (например, RCU \cite{Tassarotti-al:PLDI15,Doko-Vafeiadis:ESOP17}).

%% Данное заключение неверно для моделей, в том числе для обещающей и ARMv8.3
%% моделей. Рассмотрим, как слабое поведение $a = 1, b = 0$ достигается при исполнении ${\rm MP}$
%% в обещающей модели памяти.

%% План
%% \begin{itemize} 
%%   \item Определение. Модель памяти
%%   \item Определение. Модель последовательной консистентности
%%   \item Мотивировка. Пример слабого исполнения
%%   \item Определение. Слабый сценарий исполнения
%%   \item Определение. Слабая модель памяти
%%   \item Существующие модели
%%   \begin{itemize}
%%     \item Языки
%%       \begin{itemize}
%%         \item C/C++
%%         \item Java
%%         \item ?? LLVM ??
%%         \item ?? .Net ??
%%       \end{itemize}
%%     \item Процессоры
%%       \begin{itemize}
%%         \item x86
%%         \item Power
%%         \item ARM
%%         \item DEC Alpha (видимая спекуляция потоков)
%%       \end{itemize}
%%   \end{itemize}
%%   \begin{itemize}
%%     \item Модель памяти C/C++11. Недостатки
%%       \begin{itemize}
%%         \item OOTA (out-of-thin-air)
%%         \item Нет операционной интуиции
%%       \end{itemize}
%%     \item Модель памяти Java. Недостатки
%%       \begin{itemize}
%%         \item Оптимизации некорректны
%%         \item Нет операционной интуиции
%%       \end{itemize}
%%   \end{itemize}
%%   \item Определение. Операционная модель памяти
%%   \item Определение. Декларативная (аксиоматическая) модель памяти
%% \end{itemize}


%% \section{Модели памяти}
%% \subsection{Виды моделей памяти}

\section{Выводы}
%% На основе ранее выполненного обзора делаются следующие выводы.
\begin{itemize}
  \item Модель памяти промышленного языка программирования должна удовлетворять, как минимум, трём критериям.
    Во-первых, должна существовать корректная схема компиляции в модель целевой процессорной
    архитектуры.
    Во-вторых, основные компиляторные оптимизации должны быть корректны в рамках модели.
    В-третьих, у модели должна отсутствовать проблема ``значений из воздуха''.
  \item При разработке новой модели памяти языка программирования нужно доказывать корректность эффективной компиляции
     в модели памяти целевых процессорных архитектур.
  \item Существующие модели памяти промышленных языков программирования не удовлетворяют всем приведённым выше
    критериям.
  \item Требуется разработать операционную модель памяти с синтаксисом модели C/C++11, которая
    не имеет проблемы ``значений из воздуха''.
  %% \item ``Обещающая'' модель памяти является перспективной альтернативой существующей модели памяти C/C++.
\end{itemize}
